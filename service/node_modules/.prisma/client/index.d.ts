
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Tutor
 * 
 */
export type Tutor = $Result.DefaultSelection<Prisma.$TutorPayload>
/**
 * Model AcademicTutor
 * 
 */
export type AcademicTutor = $Result.DefaultSelection<Prisma.$AcademicTutorPayload>
/**
 * Model EnterpriseTutor
 * 
 */
export type EnterpriseTutor = $Result.DefaultSelection<Prisma.$EnterpriseTutorPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Internship
 * 
 */
export type Internship = $Result.DefaultSelection<Prisma.$InternshipPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model CdC
 * 
 */
export type CdC = $Result.DefaultSelection<Prisma.$CdCPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Evaluation
 * 
 */
export type Evaluation = $Result.DefaultSelection<Prisma.$EvaluationPayload>
/**
 * Model StudentEvaluation
 * 
 */
export type StudentEvaluation = $Result.DefaultSelection<Prisma.$StudentEvaluationPayload>
/**
 * Model CompanyEvaluation
 * 
 */
export type CompanyEvaluation = $Result.DefaultSelection<Prisma.$CompanyEvaluationPayload>
/**
 * Model Soutenance
 * 
 */
export type Soutenance = $Result.DefaultSelection<Prisma.$SoutenancePayload>
/**
 * Model SoutenanceEvaluation
 * 
 */
export type SoutenanceEvaluation = $Result.DefaultSelection<Prisma.$SoutenanceEvaluationPayload>
/**
 * Model ReportEvaluation
 * 
 */
export type ReportEvaluation = $Result.DefaultSelection<Prisma.$ReportEvaluationPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.tutor`: Exposes CRUD operations for the **Tutor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tutors
    * const tutors = await prisma.tutor.findMany()
    * ```
    */
  get tutor(): Prisma.TutorDelegate<ExtArgs>;

  /**
   * `prisma.academicTutor`: Exposes CRUD operations for the **AcademicTutor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicTutors
    * const academicTutors = await prisma.academicTutor.findMany()
    * ```
    */
  get academicTutor(): Prisma.AcademicTutorDelegate<ExtArgs>;

  /**
   * `prisma.enterpriseTutor`: Exposes CRUD operations for the **EnterpriseTutor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnterpriseTutors
    * const enterpriseTutors = await prisma.enterpriseTutor.findMany()
    * ```
    */
  get enterpriseTutor(): Prisma.EnterpriseTutorDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.internship`: Exposes CRUD operations for the **Internship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Internships
    * const internships = await prisma.internship.findMany()
    * ```
    */
  get internship(): Prisma.InternshipDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.cdC`: Exposes CRUD operations for the **CdC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CdCS
    * const cdCS = await prisma.cdC.findMany()
    * ```
    */
  get cdC(): Prisma.CdCDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.evaluation`: Exposes CRUD operations for the **Evaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluations
    * const evaluations = await prisma.evaluation.findMany()
    * ```
    */
  get evaluation(): Prisma.EvaluationDelegate<ExtArgs>;

  /**
   * `prisma.studentEvaluation`: Exposes CRUD operations for the **StudentEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentEvaluations
    * const studentEvaluations = await prisma.studentEvaluation.findMany()
    * ```
    */
  get studentEvaluation(): Prisma.StudentEvaluationDelegate<ExtArgs>;

  /**
   * `prisma.companyEvaluation`: Exposes CRUD operations for the **CompanyEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyEvaluations
    * const companyEvaluations = await prisma.companyEvaluation.findMany()
    * ```
    */
  get companyEvaluation(): Prisma.CompanyEvaluationDelegate<ExtArgs>;

  /**
   * `prisma.soutenance`: Exposes CRUD operations for the **Soutenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Soutenances
    * const soutenances = await prisma.soutenance.findMany()
    * ```
    */
  get soutenance(): Prisma.SoutenanceDelegate<ExtArgs>;

  /**
   * `prisma.soutenanceEvaluation`: Exposes CRUD operations for the **SoutenanceEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SoutenanceEvaluations
    * const soutenanceEvaluations = await prisma.soutenanceEvaluation.findMany()
    * ```
    */
  get soutenanceEvaluation(): Prisma.SoutenanceEvaluationDelegate<ExtArgs>;

  /**
   * `prisma.reportEvaluation`: Exposes CRUD operations for the **ReportEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportEvaluations
    * const reportEvaluations = await prisma.reportEvaluation.findMany()
    * ```
    */
  get reportEvaluation(): Prisma.ReportEvaluationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.9.1
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Admin: 'Admin',
    Student: 'Student',
    Tutor: 'Tutor',
    AcademicTutor: 'AcademicTutor',
    EnterpriseTutor: 'EnterpriseTutor',
    Company: 'Company',
    Internship: 'Internship',
    Document: 'Document',
    CdC: 'CdC',
    Report: 'Report',
    Evaluation: 'Evaluation',
    StudentEvaluation: 'StudentEvaluation',
    CompanyEvaluation: 'CompanyEvaluation',
    Soutenance: 'Soutenance',
    SoutenanceEvaluation: 'SoutenanceEvaluation',
    ReportEvaluation: 'ReportEvaluation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'admin' | 'student' | 'tutor' | 'academicTutor' | 'enterpriseTutor' | 'company' | 'internship' | 'document' | 'cdC' | 'report' | 'evaluation' | 'studentEvaluation' | 'companyEvaluation' | 'soutenance' | 'soutenanceEvaluation' | 'reportEvaluation'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Tutor: {
        payload: Prisma.$TutorPayload<ExtArgs>
        fields: Prisma.TutorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TutorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          findFirst: {
            args: Prisma.TutorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TutorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          findMany: {
            args: Prisma.TutorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>[]
          }
          create: {
            args: Prisma.TutorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          createMany: {
            args: Prisma.TutorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TutorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          update: {
            args: Prisma.TutorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          deleteMany: {
            args: Prisma.TutorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TutorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TutorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          aggregate: {
            args: Prisma.TutorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTutor>
          }
          groupBy: {
            args: Prisma.TutorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TutorGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutorCountArgs<ExtArgs>,
            result: $Utils.Optional<TutorCountAggregateOutputType> | number
          }
        }
      }
      AcademicTutor: {
        payload: Prisma.$AcademicTutorPayload<ExtArgs>
        fields: Prisma.AcademicTutorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicTutorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicTutorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicTutorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicTutorPayload>
          }
          findFirst: {
            args: Prisma.AcademicTutorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicTutorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicTutorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicTutorPayload>
          }
          findMany: {
            args: Prisma.AcademicTutorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicTutorPayload>[]
          }
          create: {
            args: Prisma.AcademicTutorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicTutorPayload>
          }
          createMany: {
            args: Prisma.AcademicTutorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AcademicTutorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicTutorPayload>
          }
          update: {
            args: Prisma.AcademicTutorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicTutorPayload>
          }
          deleteMany: {
            args: Prisma.AcademicTutorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicTutorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AcademicTutorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicTutorPayload>
          }
          aggregate: {
            args: Prisma.AcademicTutorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAcademicTutor>
          }
          groupBy: {
            args: Prisma.AcademicTutorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AcademicTutorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicTutorCountArgs<ExtArgs>,
            result: $Utils.Optional<AcademicTutorCountAggregateOutputType> | number
          }
        }
      }
      EnterpriseTutor: {
        payload: Prisma.$EnterpriseTutorPayload<ExtArgs>
        fields: Prisma.EnterpriseTutorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnterpriseTutorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterpriseTutorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnterpriseTutorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterpriseTutorPayload>
          }
          findFirst: {
            args: Prisma.EnterpriseTutorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterpriseTutorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnterpriseTutorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterpriseTutorPayload>
          }
          findMany: {
            args: Prisma.EnterpriseTutorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterpriseTutorPayload>[]
          }
          create: {
            args: Prisma.EnterpriseTutorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterpriseTutorPayload>
          }
          createMany: {
            args: Prisma.EnterpriseTutorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EnterpriseTutorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterpriseTutorPayload>
          }
          update: {
            args: Prisma.EnterpriseTutorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterpriseTutorPayload>
          }
          deleteMany: {
            args: Prisma.EnterpriseTutorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EnterpriseTutorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EnterpriseTutorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterpriseTutorPayload>
          }
          aggregate: {
            args: Prisma.EnterpriseTutorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEnterpriseTutor>
          }
          groupBy: {
            args: Prisma.EnterpriseTutorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EnterpriseTutorGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnterpriseTutorCountArgs<ExtArgs>,
            result: $Utils.Optional<EnterpriseTutorCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Internship: {
        payload: Prisma.$InternshipPayload<ExtArgs>
        fields: Prisma.InternshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InternshipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InternshipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          findFirst: {
            args: Prisma.InternshipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InternshipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          findMany: {
            args: Prisma.InternshipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>[]
          }
          create: {
            args: Prisma.InternshipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          createMany: {
            args: Prisma.InternshipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InternshipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          update: {
            args: Prisma.InternshipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          deleteMany: {
            args: Prisma.InternshipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InternshipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InternshipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          aggregate: {
            args: Prisma.InternshipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInternship>
          }
          groupBy: {
            args: Prisma.InternshipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InternshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.InternshipCountArgs<ExtArgs>,
            result: $Utils.Optional<InternshipCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      CdC: {
        payload: Prisma.$CdCPayload<ExtArgs>
        fields: Prisma.CdCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CdCFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CdCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CdCFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CdCPayload>
          }
          findFirst: {
            args: Prisma.CdCFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CdCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CdCFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CdCPayload>
          }
          findMany: {
            args: Prisma.CdCFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CdCPayload>[]
          }
          create: {
            args: Prisma.CdCCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CdCPayload>
          }
          createMany: {
            args: Prisma.CdCCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CdCDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CdCPayload>
          }
          update: {
            args: Prisma.CdCUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CdCPayload>
          }
          deleteMany: {
            args: Prisma.CdCDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CdCUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CdCUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CdCPayload>
          }
          aggregate: {
            args: Prisma.CdCAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCdC>
          }
          groupBy: {
            args: Prisma.CdCGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CdCGroupByOutputType>[]
          }
          count: {
            args: Prisma.CdCCountArgs<ExtArgs>,
            result: $Utils.Optional<CdCCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Evaluation: {
        payload: Prisma.$EvaluationPayload<ExtArgs>
        fields: Prisma.EvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findFirst: {
            args: Prisma.EvaluationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findMany: {
            args: Prisma.EvaluationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          create: {
            args: Prisma.EvaluationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          createMany: {
            args: Prisma.EvaluationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EvaluationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          update: {
            args: Prisma.EvaluationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          aggregate: {
            args: Prisma.EvaluationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvaluation>
          }
          groupBy: {
            args: Prisma.EvaluationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationCountArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationCountAggregateOutputType> | number
          }
        }
      }
      StudentEvaluation: {
        payload: Prisma.$StudentEvaluationPayload<ExtArgs>
        fields: Prisma.StudentEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentEvaluationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentEvaluationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEvaluationPayload>
          }
          findFirst: {
            args: Prisma.StudentEvaluationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentEvaluationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEvaluationPayload>
          }
          findMany: {
            args: Prisma.StudentEvaluationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEvaluationPayload>[]
          }
          create: {
            args: Prisma.StudentEvaluationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEvaluationPayload>
          }
          createMany: {
            args: Prisma.StudentEvaluationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentEvaluationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEvaluationPayload>
          }
          update: {
            args: Prisma.StudentEvaluationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.StudentEvaluationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentEvaluationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentEvaluationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEvaluationPayload>
          }
          aggregate: {
            args: Prisma.StudentEvaluationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentEvaluation>
          }
          groupBy: {
            args: Prisma.StudentEvaluationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentEvaluationCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentEvaluationCountAggregateOutputType> | number
          }
        }
      }
      CompanyEvaluation: {
        payload: Prisma.$CompanyEvaluationPayload<ExtArgs>
        fields: Prisma.CompanyEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyEvaluationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyEvaluationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyEvaluationPayload>
          }
          findFirst: {
            args: Prisma.CompanyEvaluationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyEvaluationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyEvaluationPayload>
          }
          findMany: {
            args: Prisma.CompanyEvaluationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyEvaluationPayload>[]
          }
          create: {
            args: Prisma.CompanyEvaluationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyEvaluationPayload>
          }
          createMany: {
            args: Prisma.CompanyEvaluationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CompanyEvaluationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyEvaluationPayload>
          }
          update: {
            args: Prisma.CompanyEvaluationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.CompanyEvaluationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyEvaluationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyEvaluationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyEvaluationPayload>
          }
          aggregate: {
            args: Prisma.CompanyEvaluationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompanyEvaluation>
          }
          groupBy: {
            args: Prisma.CompanyEvaluationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyEvaluationCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyEvaluationCountAggregateOutputType> | number
          }
        }
      }
      Soutenance: {
        payload: Prisma.$SoutenancePayload<ExtArgs>
        fields: Prisma.SoutenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoutenanceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoutenanceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          findFirst: {
            args: Prisma.SoutenanceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoutenanceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          findMany: {
            args: Prisma.SoutenanceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>[]
          }
          create: {
            args: Prisma.SoutenanceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          createMany: {
            args: Prisma.SoutenanceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SoutenanceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          update: {
            args: Prisma.SoutenanceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          deleteMany: {
            args: Prisma.SoutenanceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SoutenanceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SoutenanceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          aggregate: {
            args: Prisma.SoutenanceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSoutenance>
          }
          groupBy: {
            args: Prisma.SoutenanceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SoutenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoutenanceCountArgs<ExtArgs>,
            result: $Utils.Optional<SoutenanceCountAggregateOutputType> | number
          }
        }
      }
      SoutenanceEvaluation: {
        payload: Prisma.$SoutenanceEvaluationPayload<ExtArgs>
        fields: Prisma.SoutenanceEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoutenanceEvaluationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenanceEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoutenanceEvaluationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenanceEvaluationPayload>
          }
          findFirst: {
            args: Prisma.SoutenanceEvaluationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenanceEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoutenanceEvaluationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenanceEvaluationPayload>
          }
          findMany: {
            args: Prisma.SoutenanceEvaluationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenanceEvaluationPayload>[]
          }
          create: {
            args: Prisma.SoutenanceEvaluationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenanceEvaluationPayload>
          }
          createMany: {
            args: Prisma.SoutenanceEvaluationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SoutenanceEvaluationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenanceEvaluationPayload>
          }
          update: {
            args: Prisma.SoutenanceEvaluationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenanceEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.SoutenanceEvaluationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SoutenanceEvaluationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SoutenanceEvaluationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoutenanceEvaluationPayload>
          }
          aggregate: {
            args: Prisma.SoutenanceEvaluationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSoutenanceEvaluation>
          }
          groupBy: {
            args: Prisma.SoutenanceEvaluationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SoutenanceEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoutenanceEvaluationCountArgs<ExtArgs>,
            result: $Utils.Optional<SoutenanceEvaluationCountAggregateOutputType> | number
          }
        }
      }
      ReportEvaluation: {
        payload: Prisma.$ReportEvaluationPayload<ExtArgs>
        fields: Prisma.ReportEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportEvaluationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportEvaluationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportEvaluationPayload>
          }
          findFirst: {
            args: Prisma.ReportEvaluationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportEvaluationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportEvaluationPayload>
          }
          findMany: {
            args: Prisma.ReportEvaluationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportEvaluationPayload>[]
          }
          create: {
            args: Prisma.ReportEvaluationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportEvaluationPayload>
          }
          createMany: {
            args: Prisma.ReportEvaluationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReportEvaluationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportEvaluationPayload>
          }
          update: {
            args: Prisma.ReportEvaluationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.ReportEvaluationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportEvaluationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportEvaluationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportEvaluationPayload>
          }
          aggregate: {
            args: Prisma.ReportEvaluationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReportEvaluation>
          }
          groupBy: {
            args: Prisma.ReportEvaluationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportEvaluationCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportEvaluationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    evaluations: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | StudentCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }



  /**
   * Count Type TutorCountOutputType
   */

  export type TutorCountOutputType = {
    academicTutors: number
    enterpriseTutors: number
  }

  export type TutorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicTutors?: boolean | TutorCountOutputTypeCountAcademicTutorsArgs
    enterpriseTutors?: boolean | TutorCountOutputTypeCountEnterpriseTutorsArgs
  }

  // Custom InputTypes

  /**
   * TutorCountOutputType without action
   */
  export type TutorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorCountOutputType
     */
    select?: TutorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TutorCountOutputType without action
   */
  export type TutorCountOutputTypeCountAcademicTutorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicTutorWhereInput
  }


  /**
   * TutorCountOutputType without action
   */
  export type TutorCountOutputTypeCountEnterpriseTutorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnterpriseTutorWhereInput
  }



  /**
   * Count Type AcademicTutorCountOutputType
   */

  export type AcademicTutorCountOutputType = {
    students: number
  }

  export type AcademicTutorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | AcademicTutorCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes

  /**
   * AcademicTutorCountOutputType without action
   */
  export type AcademicTutorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutorCountOutputType
     */
    select?: AcademicTutorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AcademicTutorCountOutputType without action
   */
  export type AcademicTutorCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }



  /**
   * Count Type EnterpriseTutorCountOutputType
   */

  export type EnterpriseTutorCountOutputType = {
    students: number
  }

  export type EnterpriseTutorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | EnterpriseTutorCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes

  /**
   * EnterpriseTutorCountOutputType without action
   */
  export type EnterpriseTutorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutorCountOutputType
     */
    select?: EnterpriseTutorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EnterpriseTutorCountOutputType without action
   */
  export type EnterpriseTutorCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }



  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    internships: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    internships?: boolean | CompanyCountOutputTypeCountInternshipsArgs
  }

  // Custom InputTypes

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInternshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternshipWhereInput
  }



  /**
   * Count Type InternshipCountOutputType
   */

  export type InternshipCountOutputType = {
    evaluations: number
    documents: number
  }

  export type InternshipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | InternshipCountOutputTypeCountEvaluationsArgs
    documents?: boolean | InternshipCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes

  /**
   * InternshipCountOutputType without action
   */
  export type InternshipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipCountOutputType
     */
    select?: InternshipCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InternshipCountOutputType without action
   */
  export type InternshipCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * InternshipCountOutputType without action
   */
  export type InternshipCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }



  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    CdC: number
    Report: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CdC?: boolean | DocumentCountOutputTypeCountCdCArgs
    Report?: boolean | DocumentCountOutputTypeCountReportArgs
  }

  // Custom InputTypes

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountCdCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CdCWhereInput
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }



  /**
   * Count Type EvaluationCountOutputType
   */

  export type EvaluationCountOutputType = {
    ReportEvaluation: number
    studentEvals: number
    companyEvals: number
  }

  export type EvaluationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReportEvaluation?: boolean | EvaluationCountOutputTypeCountReportEvaluationArgs
    studentEvals?: boolean | EvaluationCountOutputTypeCountStudentEvalsArgs
    companyEvals?: boolean | EvaluationCountOutputTypeCountCompanyEvalsArgs
  }

  // Custom InputTypes

  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationCountOutputType
     */
    select?: EvaluationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeCountReportEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportEvaluationWhereInput
  }


  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeCountStudentEvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEvaluationWhereInput
  }


  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeCountCompanyEvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyEvaluationWhereInput
  }



  /**
   * Count Type SoutenanceCountOutputType
   */

  export type SoutenanceCountOutputType = {
    evaluations: number
  }

  export type SoutenanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | SoutenanceCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes

  /**
   * SoutenanceCountOutputType without action
   */
  export type SoutenanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceCountOutputType
     */
    select?: SoutenanceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SoutenanceCountOutputType without action
   */
  export type SoutenanceCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoutenanceEvaluationWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    password: string | null
    email: string | null
    role: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    password: string | null
    email: string | null
    role: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    password: number
    email: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    password?: true
    email?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    password?: true
    email?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    password?: true
    email?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    password: string
    email: string
    role: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    admin?: boolean | User$adminArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    tutor?: boolean | User$tutorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | User$adminArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    tutor?: boolean | User$tutorArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      tutor: Prisma.$TutorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string
      lastName: string
      password: string
      email: string
      role: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    tutor<T extends User$tutorArgs<ExtArgs> = {}>(args?: Subset<T, User$tutorArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }


  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }


  /**
   * User.tutor
   */
  export type User$tutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
    where?: TutorWhereInput
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    adminId: string | null
    userId: number | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    adminId: string | null
    userId: number | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    adminId: number
    userId: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    adminId: string
    userId: number
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    adminId?: boolean
    userId?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adminId: string
      userId: number
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }


  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminCreateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly adminId: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
  }



  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    internshipId: number | null
    academicTutorId: number | null
    enterpriseTutorId: number | null
  }

  export type StudentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    internshipId: number | null
    academicTutorId: number | null
    enterpriseTutorId: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: number | null
    promotion: string | null
    userId: number | null
    internshipId: number | null
    academicTutorId: number | null
    enterpriseTutorId: number | null
  }

  export type StudentMaxAggregateOutputType = {
    id: number | null
    promotion: string | null
    userId: number | null
    internshipId: number | null
    academicTutorId: number | null
    enterpriseTutorId: number | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    promotion: number
    userId: number
    internshipId: number
    academicTutorId: number
    enterpriseTutorId: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    id?: true
    userId?: true
    internshipId?: true
    academicTutorId?: true
    enterpriseTutorId?: true
  }

  export type StudentSumAggregateInputType = {
    id?: true
    userId?: true
    internshipId?: true
    academicTutorId?: true
    enterpriseTutorId?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    promotion?: true
    userId?: true
    internshipId?: true
    academicTutorId?: true
    enterpriseTutorId?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    promotion?: true
    userId?: true
    internshipId?: true
    academicTutorId?: true
    enterpriseTutorId?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    promotion?: true
    userId?: true
    internshipId?: true
    academicTutorId?: true
    enterpriseTutorId?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: number
    promotion: string
    userId: number
    internshipId: number | null
    academicTutorId: number | null
    enterpriseTutorId: number | null
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotion?: boolean
    userId?: boolean
    internshipId?: boolean
    academicTutorId?: boolean
    enterpriseTutorId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    internship?: boolean | Student$internshipArgs<ExtArgs>
    evaluations?: boolean | Student$evaluationsArgs<ExtArgs>
    academicTutor?: boolean | Student$academicTutorArgs<ExtArgs>
    enterpriseTutor?: boolean | Student$enterpriseTutorArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    promotion?: boolean
    userId?: boolean
    internshipId?: boolean
    academicTutorId?: boolean
    enterpriseTutorId?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    internship?: boolean | Student$internshipArgs<ExtArgs>
    evaluations?: boolean | Student$evaluationsArgs<ExtArgs>
    academicTutor?: boolean | Student$academicTutorArgs<ExtArgs>
    enterpriseTutor?: boolean | Student$enterpriseTutorArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      internship: Prisma.$InternshipPayload<ExtArgs> | null
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      academicTutor: Prisma.$AcademicTutorPayload<ExtArgs> | null
      enterpriseTutor: Prisma.$EnterpriseTutorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      promotion: string
      userId: number
      internshipId: number | null
      academicTutorId: number | null
      enterpriseTutorId: number | null
    }, ExtArgs["result"]["student"]>
    composites: {}
  }


  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends StudentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentCreateArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Students.
     *     @param {StudentCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const student = await prisma.student.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends StudentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends StudentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    internship<T extends Student$internshipArgs<ExtArgs> = {}>(args?: Subset<T, Student$internshipArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    evaluations<T extends Student$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    academicTutor<T extends Student$academicTutorArgs<ExtArgs> = {}>(args?: Subset<T, Student$academicTutorArgs<ExtArgs>>): Prisma__AcademicTutorClient<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    enterpriseTutor<T extends Student$enterpriseTutorArgs<ExtArgs> = {}>(args?: Subset<T, Student$enterpriseTutorArgs<ExtArgs>>): Prisma__EnterpriseTutorClient<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'Int'>
    readonly promotion: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'Int'>
    readonly internshipId: FieldRef<"Student", 'Int'>
    readonly academicTutorId: FieldRef<"Student", 'Int'>
    readonly enterpriseTutorId: FieldRef<"Student", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }


  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }


  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }


  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }


  /**
   * Student.internship
   */
  export type Student$internshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    where?: InternshipWhereInput
  }


  /**
   * Student.evaluations
   */
  export type Student$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Student.academicTutor
   */
  export type Student$academicTutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    where?: AcademicTutorWhereInput
  }


  /**
   * Student.enterpriseTutor
   */
  export type Student$enterpriseTutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    where?: EnterpriseTutorWhereInput
  }


  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
  }



  /**
   * Model Tutor
   */

  export type AggregateTutor = {
    _count: TutorCountAggregateOutputType | null
    _avg: TutorAvgAggregateOutputType | null
    _sum: TutorSumAggregateOutputType | null
    _min: TutorMinAggregateOutputType | null
    _max: TutorMaxAggregateOutputType | null
  }

  export type TutorAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TutorSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TutorMinAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TutorMaxAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TutorCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type TutorAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TutorSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TutorMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TutorMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TutorCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type TutorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tutor to aggregate.
     */
    where?: TutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutors to fetch.
     */
    orderBy?: TutorOrderByWithRelationInput | TutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tutors
    **/
    _count?: true | TutorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TutorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TutorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutorMaxAggregateInputType
  }

  export type GetTutorAggregateType<T extends TutorAggregateArgs> = {
        [P in keyof T & keyof AggregateTutor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutor[P]>
      : GetScalarType<T[P], AggregateTutor[P]>
  }




  export type TutorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorWhereInput
    orderBy?: TutorOrderByWithAggregationInput | TutorOrderByWithAggregationInput[]
    by: TutorScalarFieldEnum[] | TutorScalarFieldEnum
    having?: TutorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutorCountAggregateInputType | true
    _avg?: TutorAvgAggregateInputType
    _sum?: TutorSumAggregateInputType
    _min?: TutorMinAggregateInputType
    _max?: TutorMaxAggregateInputType
  }

  export type TutorGroupByOutputType = {
    id: number
    userId: number
    _count: TutorCountAggregateOutputType | null
    _avg: TutorAvgAggregateOutputType | null
    _sum: TutorSumAggregateOutputType | null
    _min: TutorMinAggregateOutputType | null
    _max: TutorMaxAggregateOutputType | null
  }

  type GetTutorGroupByPayload<T extends TutorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutorGroupByOutputType[P]>
            : GetScalarType<T[P], TutorGroupByOutputType[P]>
        }
      >
    >


  export type TutorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    academicTutors?: boolean | Tutor$academicTutorsArgs<ExtArgs>
    enterpriseTutors?: boolean | Tutor$enterpriseTutorsArgs<ExtArgs>
    _count?: boolean | TutorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutor"]>

  export type TutorSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type TutorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    academicTutors?: boolean | Tutor$academicTutorsArgs<ExtArgs>
    enterpriseTutors?: boolean | Tutor$enterpriseTutorsArgs<ExtArgs>
    _count?: boolean | TutorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TutorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tutor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      academicTutors: Prisma.$AcademicTutorPayload<ExtArgs>[]
      enterpriseTutors: Prisma.$EnterpriseTutorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
    }, ExtArgs["result"]["tutor"]>
    composites: {}
  }


  type TutorGetPayload<S extends boolean | null | undefined | TutorDefaultArgs> = $Result.GetResult<Prisma.$TutorPayload, S>

  type TutorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TutorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TutorCountAggregateInputType | true
    }

  export interface TutorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tutor'], meta: { name: 'Tutor' } }
    /**
     * Find zero or one Tutor that matches the filter.
     * @param {TutorFindUniqueArgs} args - Arguments to find a Tutor
     * @example
     * // Get one Tutor
     * const tutor = await prisma.tutor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TutorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TutorFindUniqueArgs<ExtArgs>>
    ): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tutor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TutorFindUniqueOrThrowArgs} args - Arguments to find a Tutor
     * @example
     * // Get one Tutor
     * const tutor = await prisma.tutor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TutorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TutorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tutor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorFindFirstArgs} args - Arguments to find a Tutor
     * @example
     * // Get one Tutor
     * const tutor = await prisma.tutor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TutorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TutorFindFirstArgs<ExtArgs>>
    ): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tutor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorFindFirstOrThrowArgs} args - Arguments to find a Tutor
     * @example
     * // Get one Tutor
     * const tutor = await prisma.tutor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TutorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TutorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tutors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tutors
     * const tutors = await prisma.tutor.findMany()
     * 
     * // Get first 10 Tutors
     * const tutors = await prisma.tutor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutorWithIdOnly = await prisma.tutor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TutorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TutorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tutor.
     * @param {TutorCreateArgs} args - Arguments to create a Tutor.
     * @example
     * // Create one Tutor
     * const Tutor = await prisma.tutor.create({
     *   data: {
     *     // ... data to create a Tutor
     *   }
     * })
     * 
    **/
    create<T extends TutorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TutorCreateArgs<ExtArgs>>
    ): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tutors.
     *     @param {TutorCreateManyArgs} args - Arguments to create many Tutors.
     *     @example
     *     // Create many Tutors
     *     const tutor = await prisma.tutor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TutorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TutorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tutor.
     * @param {TutorDeleteArgs} args - Arguments to delete one Tutor.
     * @example
     * // Delete one Tutor
     * const Tutor = await prisma.tutor.delete({
     *   where: {
     *     // ... filter to delete one Tutor
     *   }
     * })
     * 
    **/
    delete<T extends TutorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TutorDeleteArgs<ExtArgs>>
    ): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tutor.
     * @param {TutorUpdateArgs} args - Arguments to update one Tutor.
     * @example
     * // Update one Tutor
     * const tutor = await prisma.tutor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TutorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TutorUpdateArgs<ExtArgs>>
    ): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tutors.
     * @param {TutorDeleteManyArgs} args - Arguments to filter Tutors to delete.
     * @example
     * // Delete a few Tutors
     * const { count } = await prisma.tutor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TutorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TutorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tutors
     * const tutor = await prisma.tutor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TutorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TutorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tutor.
     * @param {TutorUpsertArgs} args - Arguments to update or create a Tutor.
     * @example
     * // Update or create a Tutor
     * const tutor = await prisma.tutor.upsert({
     *   create: {
     *     // ... data to create a Tutor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tutor we want to update
     *   }
     * })
    **/
    upsert<T extends TutorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TutorUpsertArgs<ExtArgs>>
    ): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorCountArgs} args - Arguments to filter Tutors to count.
     * @example
     * // Count the number of Tutors
     * const count = await prisma.tutor.count({
     *   where: {
     *     // ... the filter for the Tutors we want to count
     *   }
     * })
    **/
    count<T extends TutorCountArgs>(
      args?: Subset<T, TutorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tutor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutorAggregateArgs>(args: Subset<T, TutorAggregateArgs>): Prisma.PrismaPromise<GetTutorAggregateType<T>>

    /**
     * Group by Tutor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutorGroupByArgs['orderBy'] }
        : { orderBy?: TutorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tutor model
   */
  readonly fields: TutorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tutor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    academicTutors<T extends Tutor$academicTutorsArgs<ExtArgs> = {}>(args?: Subset<T, Tutor$academicTutorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'findMany'> | Null>;

    enterpriseTutors<T extends Tutor$enterpriseTutorsArgs<ExtArgs> = {}>(args?: Subset<T, Tutor$enterpriseTutorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tutor model
   */ 
  interface TutorFieldRefs {
    readonly id: FieldRef<"Tutor", 'Int'>
    readonly userId: FieldRef<"Tutor", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Tutor findUnique
   */
  export type TutorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter, which Tutor to fetch.
     */
    where: TutorWhereUniqueInput
  }


  /**
   * Tutor findUniqueOrThrow
   */
  export type TutorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter, which Tutor to fetch.
     */
    where: TutorWhereUniqueInput
  }


  /**
   * Tutor findFirst
   */
  export type TutorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter, which Tutor to fetch.
     */
    where?: TutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutors to fetch.
     */
    orderBy?: TutorOrderByWithRelationInput | TutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tutors.
     */
    cursor?: TutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tutors.
     */
    distinct?: TutorScalarFieldEnum | TutorScalarFieldEnum[]
  }


  /**
   * Tutor findFirstOrThrow
   */
  export type TutorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter, which Tutor to fetch.
     */
    where?: TutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutors to fetch.
     */
    orderBy?: TutorOrderByWithRelationInput | TutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tutors.
     */
    cursor?: TutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tutors.
     */
    distinct?: TutorScalarFieldEnum | TutorScalarFieldEnum[]
  }


  /**
   * Tutor findMany
   */
  export type TutorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter, which Tutors to fetch.
     */
    where?: TutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutors to fetch.
     */
    orderBy?: TutorOrderByWithRelationInput | TutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tutors.
     */
    cursor?: TutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutors.
     */
    skip?: number
    distinct?: TutorScalarFieldEnum | TutorScalarFieldEnum[]
  }


  /**
   * Tutor create
   */
  export type TutorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * The data needed to create a Tutor.
     */
    data: XOR<TutorCreateInput, TutorUncheckedCreateInput>
  }


  /**
   * Tutor createMany
   */
  export type TutorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tutors.
     */
    data: TutorCreateManyInput | TutorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tutor update
   */
  export type TutorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * The data needed to update a Tutor.
     */
    data: XOR<TutorUpdateInput, TutorUncheckedUpdateInput>
    /**
     * Choose, which Tutor to update.
     */
    where: TutorWhereUniqueInput
  }


  /**
   * Tutor updateMany
   */
  export type TutorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tutors.
     */
    data: XOR<TutorUpdateManyMutationInput, TutorUncheckedUpdateManyInput>
    /**
     * Filter which Tutors to update
     */
    where?: TutorWhereInput
  }


  /**
   * Tutor upsert
   */
  export type TutorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * The filter to search for the Tutor to update in case it exists.
     */
    where: TutorWhereUniqueInput
    /**
     * In case the Tutor found by the `where` argument doesn't exist, create a new Tutor with this data.
     */
    create: XOR<TutorCreateInput, TutorUncheckedCreateInput>
    /**
     * In case the Tutor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutorUpdateInput, TutorUncheckedUpdateInput>
  }


  /**
   * Tutor delete
   */
  export type TutorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter which Tutor to delete.
     */
    where: TutorWhereUniqueInput
  }


  /**
   * Tutor deleteMany
   */
  export type TutorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tutors to delete
     */
    where?: TutorWhereInput
  }


  /**
   * Tutor.academicTutors
   */
  export type Tutor$academicTutorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    where?: AcademicTutorWhereInput
    orderBy?: AcademicTutorOrderByWithRelationInput | AcademicTutorOrderByWithRelationInput[]
    cursor?: AcademicTutorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicTutorScalarFieldEnum | AcademicTutorScalarFieldEnum[]
  }


  /**
   * Tutor.enterpriseTutors
   */
  export type Tutor$enterpriseTutorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    where?: EnterpriseTutorWhereInput
    orderBy?: EnterpriseTutorOrderByWithRelationInput | EnterpriseTutorOrderByWithRelationInput[]
    cursor?: EnterpriseTutorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnterpriseTutorScalarFieldEnum | EnterpriseTutorScalarFieldEnum[]
  }


  /**
   * Tutor without action
   */
  export type TutorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TutorInclude<ExtArgs> | null
  }



  /**
   * Model AcademicTutor
   */

  export type AggregateAcademicTutor = {
    _count: AcademicTutorCountAggregateOutputType | null
    _avg: AcademicTutorAvgAggregateOutputType | null
    _sum: AcademicTutorSumAggregateOutputType | null
    _min: AcademicTutorMinAggregateOutputType | null
    _max: AcademicTutorMaxAggregateOutputType | null
  }

  export type AcademicTutorAvgAggregateOutputType = {
    id: number | null
    tutorId: number | null
  }

  export type AcademicTutorSumAggregateOutputType = {
    id: number | null
    tutorId: number | null
  }

  export type AcademicTutorMinAggregateOutputType = {
    id: number | null
    tutorId: number | null
  }

  export type AcademicTutorMaxAggregateOutputType = {
    id: number | null
    tutorId: number | null
  }

  export type AcademicTutorCountAggregateOutputType = {
    id: number
    tutorId: number
    _all: number
  }


  export type AcademicTutorAvgAggregateInputType = {
    id?: true
    tutorId?: true
  }

  export type AcademicTutorSumAggregateInputType = {
    id?: true
    tutorId?: true
  }

  export type AcademicTutorMinAggregateInputType = {
    id?: true
    tutorId?: true
  }

  export type AcademicTutorMaxAggregateInputType = {
    id?: true
    tutorId?: true
  }

  export type AcademicTutorCountAggregateInputType = {
    id?: true
    tutorId?: true
    _all?: true
  }

  export type AcademicTutorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicTutor to aggregate.
     */
    where?: AcademicTutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicTutors to fetch.
     */
    orderBy?: AcademicTutorOrderByWithRelationInput | AcademicTutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicTutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicTutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicTutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicTutors
    **/
    _count?: true | AcademicTutorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicTutorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicTutorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicTutorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicTutorMaxAggregateInputType
  }

  export type GetAcademicTutorAggregateType<T extends AcademicTutorAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicTutor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicTutor[P]>
      : GetScalarType<T[P], AggregateAcademicTutor[P]>
  }




  export type AcademicTutorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicTutorWhereInput
    orderBy?: AcademicTutorOrderByWithAggregationInput | AcademicTutorOrderByWithAggregationInput[]
    by: AcademicTutorScalarFieldEnum[] | AcademicTutorScalarFieldEnum
    having?: AcademicTutorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicTutorCountAggregateInputType | true
    _avg?: AcademicTutorAvgAggregateInputType
    _sum?: AcademicTutorSumAggregateInputType
    _min?: AcademicTutorMinAggregateInputType
    _max?: AcademicTutorMaxAggregateInputType
  }

  export type AcademicTutorGroupByOutputType = {
    id: number
    tutorId: number
    _count: AcademicTutorCountAggregateOutputType | null
    _avg: AcademicTutorAvgAggregateOutputType | null
    _sum: AcademicTutorSumAggregateOutputType | null
    _min: AcademicTutorMinAggregateOutputType | null
    _max: AcademicTutorMaxAggregateOutputType | null
  }

  type GetAcademicTutorGroupByPayload<T extends AcademicTutorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicTutorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicTutorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicTutorGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicTutorGroupByOutputType[P]>
        }
      >
    >


  export type AcademicTutorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tutorId?: boolean
    tutor?: boolean | TutorDefaultArgs<ExtArgs>
    students?: boolean | AcademicTutor$studentsArgs<ExtArgs>
    _count?: boolean | AcademicTutorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicTutor"]>

  export type AcademicTutorSelectScalar = {
    id?: boolean
    tutorId?: boolean
  }

  export type AcademicTutorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | TutorDefaultArgs<ExtArgs>
    students?: boolean | AcademicTutor$studentsArgs<ExtArgs>
    _count?: boolean | AcademicTutorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AcademicTutorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicTutor"
    objects: {
      tutor: Prisma.$TutorPayload<ExtArgs>
      students: Prisma.$StudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tutorId: number
    }, ExtArgs["result"]["academicTutor"]>
    composites: {}
  }


  type AcademicTutorGetPayload<S extends boolean | null | undefined | AcademicTutorDefaultArgs> = $Result.GetResult<Prisma.$AcademicTutorPayload, S>

  type AcademicTutorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcademicTutorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcademicTutorCountAggregateInputType | true
    }

  export interface AcademicTutorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicTutor'], meta: { name: 'AcademicTutor' } }
    /**
     * Find zero or one AcademicTutor that matches the filter.
     * @param {AcademicTutorFindUniqueArgs} args - Arguments to find a AcademicTutor
     * @example
     * // Get one AcademicTutor
     * const academicTutor = await prisma.academicTutor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AcademicTutorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicTutorFindUniqueArgs<ExtArgs>>
    ): Prisma__AcademicTutorClient<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AcademicTutor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AcademicTutorFindUniqueOrThrowArgs} args - Arguments to find a AcademicTutor
     * @example
     * // Get one AcademicTutor
     * const academicTutor = await prisma.academicTutor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AcademicTutorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicTutorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AcademicTutorClient<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AcademicTutor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTutorFindFirstArgs} args - Arguments to find a AcademicTutor
     * @example
     * // Get one AcademicTutor
     * const academicTutor = await prisma.academicTutor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AcademicTutorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicTutorFindFirstArgs<ExtArgs>>
    ): Prisma__AcademicTutorClient<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AcademicTutor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTutorFindFirstOrThrowArgs} args - Arguments to find a AcademicTutor
     * @example
     * // Get one AcademicTutor
     * const academicTutor = await prisma.academicTutor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AcademicTutorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicTutorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AcademicTutorClient<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AcademicTutors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTutorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicTutors
     * const academicTutors = await prisma.academicTutor.findMany()
     * 
     * // Get first 10 AcademicTutors
     * const academicTutors = await prisma.academicTutor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicTutorWithIdOnly = await prisma.academicTutor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AcademicTutorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicTutorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AcademicTutor.
     * @param {AcademicTutorCreateArgs} args - Arguments to create a AcademicTutor.
     * @example
     * // Create one AcademicTutor
     * const AcademicTutor = await prisma.academicTutor.create({
     *   data: {
     *     // ... data to create a AcademicTutor
     *   }
     * })
     * 
    **/
    create<T extends AcademicTutorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicTutorCreateArgs<ExtArgs>>
    ): Prisma__AcademicTutorClient<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AcademicTutors.
     *     @param {AcademicTutorCreateManyArgs} args - Arguments to create many AcademicTutors.
     *     @example
     *     // Create many AcademicTutors
     *     const academicTutor = await prisma.academicTutor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AcademicTutorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicTutorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicTutor.
     * @param {AcademicTutorDeleteArgs} args - Arguments to delete one AcademicTutor.
     * @example
     * // Delete one AcademicTutor
     * const AcademicTutor = await prisma.academicTutor.delete({
     *   where: {
     *     // ... filter to delete one AcademicTutor
     *   }
     * })
     * 
    **/
    delete<T extends AcademicTutorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicTutorDeleteArgs<ExtArgs>>
    ): Prisma__AcademicTutorClient<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AcademicTutor.
     * @param {AcademicTutorUpdateArgs} args - Arguments to update one AcademicTutor.
     * @example
     * // Update one AcademicTutor
     * const academicTutor = await prisma.academicTutor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AcademicTutorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicTutorUpdateArgs<ExtArgs>>
    ): Prisma__AcademicTutorClient<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AcademicTutors.
     * @param {AcademicTutorDeleteManyArgs} args - Arguments to filter AcademicTutors to delete.
     * @example
     * // Delete a few AcademicTutors
     * const { count } = await prisma.academicTutor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AcademicTutorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicTutorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicTutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTutorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicTutors
     * const academicTutor = await prisma.academicTutor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AcademicTutorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicTutorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicTutor.
     * @param {AcademicTutorUpsertArgs} args - Arguments to update or create a AcademicTutor.
     * @example
     * // Update or create a AcademicTutor
     * const academicTutor = await prisma.academicTutor.upsert({
     *   create: {
     *     // ... data to create a AcademicTutor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicTutor we want to update
     *   }
     * })
    **/
    upsert<T extends AcademicTutorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicTutorUpsertArgs<ExtArgs>>
    ): Prisma__AcademicTutorClient<$Result.GetResult<Prisma.$AcademicTutorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AcademicTutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTutorCountArgs} args - Arguments to filter AcademicTutors to count.
     * @example
     * // Count the number of AcademicTutors
     * const count = await prisma.academicTutor.count({
     *   where: {
     *     // ... the filter for the AcademicTutors we want to count
     *   }
     * })
    **/
    count<T extends AcademicTutorCountArgs>(
      args?: Subset<T, AcademicTutorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicTutorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicTutor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTutorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicTutorAggregateArgs>(args: Subset<T, AcademicTutorAggregateArgs>): Prisma.PrismaPromise<GetAcademicTutorAggregateType<T>>

    /**
     * Group by AcademicTutor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicTutorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicTutorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicTutorGroupByArgs['orderBy'] }
        : { orderBy?: AcademicTutorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicTutorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicTutorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicTutor model
   */
  readonly fields: AcademicTutorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicTutor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicTutorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tutor<T extends TutorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutorDefaultArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    students<T extends AcademicTutor$studentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicTutor$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AcademicTutor model
   */ 
  interface AcademicTutorFieldRefs {
    readonly id: FieldRef<"AcademicTutor", 'Int'>
    readonly tutorId: FieldRef<"AcademicTutor", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * AcademicTutor findUnique
   */
  export type AcademicTutorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    /**
     * Filter, which AcademicTutor to fetch.
     */
    where: AcademicTutorWhereUniqueInput
  }


  /**
   * AcademicTutor findUniqueOrThrow
   */
  export type AcademicTutorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    /**
     * Filter, which AcademicTutor to fetch.
     */
    where: AcademicTutorWhereUniqueInput
  }


  /**
   * AcademicTutor findFirst
   */
  export type AcademicTutorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    /**
     * Filter, which AcademicTutor to fetch.
     */
    where?: AcademicTutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicTutors to fetch.
     */
    orderBy?: AcademicTutorOrderByWithRelationInput | AcademicTutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicTutors.
     */
    cursor?: AcademicTutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicTutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicTutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicTutors.
     */
    distinct?: AcademicTutorScalarFieldEnum | AcademicTutorScalarFieldEnum[]
  }


  /**
   * AcademicTutor findFirstOrThrow
   */
  export type AcademicTutorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    /**
     * Filter, which AcademicTutor to fetch.
     */
    where?: AcademicTutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicTutors to fetch.
     */
    orderBy?: AcademicTutorOrderByWithRelationInput | AcademicTutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicTutors.
     */
    cursor?: AcademicTutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicTutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicTutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicTutors.
     */
    distinct?: AcademicTutorScalarFieldEnum | AcademicTutorScalarFieldEnum[]
  }


  /**
   * AcademicTutor findMany
   */
  export type AcademicTutorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    /**
     * Filter, which AcademicTutors to fetch.
     */
    where?: AcademicTutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicTutors to fetch.
     */
    orderBy?: AcademicTutorOrderByWithRelationInput | AcademicTutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicTutors.
     */
    cursor?: AcademicTutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicTutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicTutors.
     */
    skip?: number
    distinct?: AcademicTutorScalarFieldEnum | AcademicTutorScalarFieldEnum[]
  }


  /**
   * AcademicTutor create
   */
  export type AcademicTutorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicTutor.
     */
    data: XOR<AcademicTutorCreateInput, AcademicTutorUncheckedCreateInput>
  }


  /**
   * AcademicTutor createMany
   */
  export type AcademicTutorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicTutors.
     */
    data: AcademicTutorCreateManyInput | AcademicTutorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AcademicTutor update
   */
  export type AcademicTutorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicTutor.
     */
    data: XOR<AcademicTutorUpdateInput, AcademicTutorUncheckedUpdateInput>
    /**
     * Choose, which AcademicTutor to update.
     */
    where: AcademicTutorWhereUniqueInput
  }


  /**
   * AcademicTutor updateMany
   */
  export type AcademicTutorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicTutors.
     */
    data: XOR<AcademicTutorUpdateManyMutationInput, AcademicTutorUncheckedUpdateManyInput>
    /**
     * Filter which AcademicTutors to update
     */
    where?: AcademicTutorWhereInput
  }


  /**
   * AcademicTutor upsert
   */
  export type AcademicTutorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicTutor to update in case it exists.
     */
    where: AcademicTutorWhereUniqueInput
    /**
     * In case the AcademicTutor found by the `where` argument doesn't exist, create a new AcademicTutor with this data.
     */
    create: XOR<AcademicTutorCreateInput, AcademicTutorUncheckedCreateInput>
    /**
     * In case the AcademicTutor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicTutorUpdateInput, AcademicTutorUncheckedUpdateInput>
  }


  /**
   * AcademicTutor delete
   */
  export type AcademicTutorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
    /**
     * Filter which AcademicTutor to delete.
     */
    where: AcademicTutorWhereUniqueInput
  }


  /**
   * AcademicTutor deleteMany
   */
  export type AcademicTutorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicTutors to delete
     */
    where?: AcademicTutorWhereInput
  }


  /**
   * AcademicTutor.students
   */
  export type AcademicTutor$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * AcademicTutor without action
   */
  export type AcademicTutorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicTutor
     */
    select?: AcademicTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicTutorInclude<ExtArgs> | null
  }



  /**
   * Model EnterpriseTutor
   */

  export type AggregateEnterpriseTutor = {
    _count: EnterpriseTutorCountAggregateOutputType | null
    _avg: EnterpriseTutorAvgAggregateOutputType | null
    _sum: EnterpriseTutorSumAggregateOutputType | null
    _min: EnterpriseTutorMinAggregateOutputType | null
    _max: EnterpriseTutorMaxAggregateOutputType | null
  }

  export type EnterpriseTutorAvgAggregateOutputType = {
    id: number | null
    tutorId: number | null
  }

  export type EnterpriseTutorSumAggregateOutputType = {
    id: number | null
    tutorId: number | null
  }

  export type EnterpriseTutorMinAggregateOutputType = {
    id: number | null
    tutorId: number | null
  }

  export type EnterpriseTutorMaxAggregateOutputType = {
    id: number | null
    tutorId: number | null
  }

  export type EnterpriseTutorCountAggregateOutputType = {
    id: number
    tutorId: number
    _all: number
  }


  export type EnterpriseTutorAvgAggregateInputType = {
    id?: true
    tutorId?: true
  }

  export type EnterpriseTutorSumAggregateInputType = {
    id?: true
    tutorId?: true
  }

  export type EnterpriseTutorMinAggregateInputType = {
    id?: true
    tutorId?: true
  }

  export type EnterpriseTutorMaxAggregateInputType = {
    id?: true
    tutorId?: true
  }

  export type EnterpriseTutorCountAggregateInputType = {
    id?: true
    tutorId?: true
    _all?: true
  }

  export type EnterpriseTutorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnterpriseTutor to aggregate.
     */
    where?: EnterpriseTutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseTutors to fetch.
     */
    orderBy?: EnterpriseTutorOrderByWithRelationInput | EnterpriseTutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnterpriseTutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseTutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseTutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnterpriseTutors
    **/
    _count?: true | EnterpriseTutorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnterpriseTutorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnterpriseTutorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnterpriseTutorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnterpriseTutorMaxAggregateInputType
  }

  export type GetEnterpriseTutorAggregateType<T extends EnterpriseTutorAggregateArgs> = {
        [P in keyof T & keyof AggregateEnterpriseTutor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnterpriseTutor[P]>
      : GetScalarType<T[P], AggregateEnterpriseTutor[P]>
  }




  export type EnterpriseTutorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnterpriseTutorWhereInput
    orderBy?: EnterpriseTutorOrderByWithAggregationInput | EnterpriseTutorOrderByWithAggregationInput[]
    by: EnterpriseTutorScalarFieldEnum[] | EnterpriseTutorScalarFieldEnum
    having?: EnterpriseTutorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnterpriseTutorCountAggregateInputType | true
    _avg?: EnterpriseTutorAvgAggregateInputType
    _sum?: EnterpriseTutorSumAggregateInputType
    _min?: EnterpriseTutorMinAggregateInputType
    _max?: EnterpriseTutorMaxAggregateInputType
  }

  export type EnterpriseTutorGroupByOutputType = {
    id: number
    tutorId: number
    _count: EnterpriseTutorCountAggregateOutputType | null
    _avg: EnterpriseTutorAvgAggregateOutputType | null
    _sum: EnterpriseTutorSumAggregateOutputType | null
    _min: EnterpriseTutorMinAggregateOutputType | null
    _max: EnterpriseTutorMaxAggregateOutputType | null
  }

  type GetEnterpriseTutorGroupByPayload<T extends EnterpriseTutorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnterpriseTutorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnterpriseTutorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnterpriseTutorGroupByOutputType[P]>
            : GetScalarType<T[P], EnterpriseTutorGroupByOutputType[P]>
        }
      >
    >


  export type EnterpriseTutorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tutorId?: boolean
    tutor?: boolean | TutorDefaultArgs<ExtArgs>
    students?: boolean | EnterpriseTutor$studentsArgs<ExtArgs>
    _count?: boolean | EnterpriseTutorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enterpriseTutor"]>

  export type EnterpriseTutorSelectScalar = {
    id?: boolean
    tutorId?: boolean
  }

  export type EnterpriseTutorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | TutorDefaultArgs<ExtArgs>
    students?: boolean | EnterpriseTutor$studentsArgs<ExtArgs>
    _count?: boolean | EnterpriseTutorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EnterpriseTutorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnterpriseTutor"
    objects: {
      tutor: Prisma.$TutorPayload<ExtArgs>
      students: Prisma.$StudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tutorId: number
    }, ExtArgs["result"]["enterpriseTutor"]>
    composites: {}
  }


  type EnterpriseTutorGetPayload<S extends boolean | null | undefined | EnterpriseTutorDefaultArgs> = $Result.GetResult<Prisma.$EnterpriseTutorPayload, S>

  type EnterpriseTutorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnterpriseTutorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnterpriseTutorCountAggregateInputType | true
    }

  export interface EnterpriseTutorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnterpriseTutor'], meta: { name: 'EnterpriseTutor' } }
    /**
     * Find zero or one EnterpriseTutor that matches the filter.
     * @param {EnterpriseTutorFindUniqueArgs} args - Arguments to find a EnterpriseTutor
     * @example
     * // Get one EnterpriseTutor
     * const enterpriseTutor = await prisma.enterpriseTutor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnterpriseTutorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseTutorFindUniqueArgs<ExtArgs>>
    ): Prisma__EnterpriseTutorClient<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EnterpriseTutor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EnterpriseTutorFindUniqueOrThrowArgs} args - Arguments to find a EnterpriseTutor
     * @example
     * // Get one EnterpriseTutor
     * const enterpriseTutor = await prisma.enterpriseTutor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnterpriseTutorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseTutorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EnterpriseTutorClient<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EnterpriseTutor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseTutorFindFirstArgs} args - Arguments to find a EnterpriseTutor
     * @example
     * // Get one EnterpriseTutor
     * const enterpriseTutor = await prisma.enterpriseTutor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnterpriseTutorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseTutorFindFirstArgs<ExtArgs>>
    ): Prisma__EnterpriseTutorClient<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EnterpriseTutor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseTutorFindFirstOrThrowArgs} args - Arguments to find a EnterpriseTutor
     * @example
     * // Get one EnterpriseTutor
     * const enterpriseTutor = await prisma.enterpriseTutor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnterpriseTutorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseTutorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EnterpriseTutorClient<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EnterpriseTutors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseTutorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnterpriseTutors
     * const enterpriseTutors = await prisma.enterpriseTutor.findMany()
     * 
     * // Get first 10 EnterpriseTutors
     * const enterpriseTutors = await prisma.enterpriseTutor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enterpriseTutorWithIdOnly = await prisma.enterpriseTutor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnterpriseTutorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseTutorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EnterpriseTutor.
     * @param {EnterpriseTutorCreateArgs} args - Arguments to create a EnterpriseTutor.
     * @example
     * // Create one EnterpriseTutor
     * const EnterpriseTutor = await prisma.enterpriseTutor.create({
     *   data: {
     *     // ... data to create a EnterpriseTutor
     *   }
     * })
     * 
    **/
    create<T extends EnterpriseTutorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseTutorCreateArgs<ExtArgs>>
    ): Prisma__EnterpriseTutorClient<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EnterpriseTutors.
     *     @param {EnterpriseTutorCreateManyArgs} args - Arguments to create many EnterpriseTutors.
     *     @example
     *     // Create many EnterpriseTutors
     *     const enterpriseTutor = await prisma.enterpriseTutor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnterpriseTutorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseTutorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EnterpriseTutor.
     * @param {EnterpriseTutorDeleteArgs} args - Arguments to delete one EnterpriseTutor.
     * @example
     * // Delete one EnterpriseTutor
     * const EnterpriseTutor = await prisma.enterpriseTutor.delete({
     *   where: {
     *     // ... filter to delete one EnterpriseTutor
     *   }
     * })
     * 
    **/
    delete<T extends EnterpriseTutorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseTutorDeleteArgs<ExtArgs>>
    ): Prisma__EnterpriseTutorClient<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EnterpriseTutor.
     * @param {EnterpriseTutorUpdateArgs} args - Arguments to update one EnterpriseTutor.
     * @example
     * // Update one EnterpriseTutor
     * const enterpriseTutor = await prisma.enterpriseTutor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnterpriseTutorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseTutorUpdateArgs<ExtArgs>>
    ): Prisma__EnterpriseTutorClient<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EnterpriseTutors.
     * @param {EnterpriseTutorDeleteManyArgs} args - Arguments to filter EnterpriseTutors to delete.
     * @example
     * // Delete a few EnterpriseTutors
     * const { count } = await prisma.enterpriseTutor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnterpriseTutorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseTutorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnterpriseTutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseTutorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnterpriseTutors
     * const enterpriseTutor = await prisma.enterpriseTutor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnterpriseTutorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseTutorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EnterpriseTutor.
     * @param {EnterpriseTutorUpsertArgs} args - Arguments to update or create a EnterpriseTutor.
     * @example
     * // Update or create a EnterpriseTutor
     * const enterpriseTutor = await prisma.enterpriseTutor.upsert({
     *   create: {
     *     // ... data to create a EnterpriseTutor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnterpriseTutor we want to update
     *   }
     * })
    **/
    upsert<T extends EnterpriseTutorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseTutorUpsertArgs<ExtArgs>>
    ): Prisma__EnterpriseTutorClient<$Result.GetResult<Prisma.$EnterpriseTutorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EnterpriseTutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseTutorCountArgs} args - Arguments to filter EnterpriseTutors to count.
     * @example
     * // Count the number of EnterpriseTutors
     * const count = await prisma.enterpriseTutor.count({
     *   where: {
     *     // ... the filter for the EnterpriseTutors we want to count
     *   }
     * })
    **/
    count<T extends EnterpriseTutorCountArgs>(
      args?: Subset<T, EnterpriseTutorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnterpriseTutorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnterpriseTutor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseTutorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnterpriseTutorAggregateArgs>(args: Subset<T, EnterpriseTutorAggregateArgs>): Prisma.PrismaPromise<GetEnterpriseTutorAggregateType<T>>

    /**
     * Group by EnterpriseTutor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseTutorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnterpriseTutorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnterpriseTutorGroupByArgs['orderBy'] }
        : { orderBy?: EnterpriseTutorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnterpriseTutorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnterpriseTutorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnterpriseTutor model
   */
  readonly fields: EnterpriseTutorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnterpriseTutor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnterpriseTutorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tutor<T extends TutorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutorDefaultArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    students<T extends EnterpriseTutor$studentsArgs<ExtArgs> = {}>(args?: Subset<T, EnterpriseTutor$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EnterpriseTutor model
   */ 
  interface EnterpriseTutorFieldRefs {
    readonly id: FieldRef<"EnterpriseTutor", 'Int'>
    readonly tutorId: FieldRef<"EnterpriseTutor", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EnterpriseTutor findUnique
   */
  export type EnterpriseTutorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    /**
     * Filter, which EnterpriseTutor to fetch.
     */
    where: EnterpriseTutorWhereUniqueInput
  }


  /**
   * EnterpriseTutor findUniqueOrThrow
   */
  export type EnterpriseTutorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    /**
     * Filter, which EnterpriseTutor to fetch.
     */
    where: EnterpriseTutorWhereUniqueInput
  }


  /**
   * EnterpriseTutor findFirst
   */
  export type EnterpriseTutorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    /**
     * Filter, which EnterpriseTutor to fetch.
     */
    where?: EnterpriseTutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseTutors to fetch.
     */
    orderBy?: EnterpriseTutorOrderByWithRelationInput | EnterpriseTutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnterpriseTutors.
     */
    cursor?: EnterpriseTutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseTutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseTutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnterpriseTutors.
     */
    distinct?: EnterpriseTutorScalarFieldEnum | EnterpriseTutorScalarFieldEnum[]
  }


  /**
   * EnterpriseTutor findFirstOrThrow
   */
  export type EnterpriseTutorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    /**
     * Filter, which EnterpriseTutor to fetch.
     */
    where?: EnterpriseTutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseTutors to fetch.
     */
    orderBy?: EnterpriseTutorOrderByWithRelationInput | EnterpriseTutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnterpriseTutors.
     */
    cursor?: EnterpriseTutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseTutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseTutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnterpriseTutors.
     */
    distinct?: EnterpriseTutorScalarFieldEnum | EnterpriseTutorScalarFieldEnum[]
  }


  /**
   * EnterpriseTutor findMany
   */
  export type EnterpriseTutorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    /**
     * Filter, which EnterpriseTutors to fetch.
     */
    where?: EnterpriseTutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseTutors to fetch.
     */
    orderBy?: EnterpriseTutorOrderByWithRelationInput | EnterpriseTutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnterpriseTutors.
     */
    cursor?: EnterpriseTutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseTutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseTutors.
     */
    skip?: number
    distinct?: EnterpriseTutorScalarFieldEnum | EnterpriseTutorScalarFieldEnum[]
  }


  /**
   * EnterpriseTutor create
   */
  export type EnterpriseTutorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    /**
     * The data needed to create a EnterpriseTutor.
     */
    data: XOR<EnterpriseTutorCreateInput, EnterpriseTutorUncheckedCreateInput>
  }


  /**
   * EnterpriseTutor createMany
   */
  export type EnterpriseTutorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnterpriseTutors.
     */
    data: EnterpriseTutorCreateManyInput | EnterpriseTutorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EnterpriseTutor update
   */
  export type EnterpriseTutorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    /**
     * The data needed to update a EnterpriseTutor.
     */
    data: XOR<EnterpriseTutorUpdateInput, EnterpriseTutorUncheckedUpdateInput>
    /**
     * Choose, which EnterpriseTutor to update.
     */
    where: EnterpriseTutorWhereUniqueInput
  }


  /**
   * EnterpriseTutor updateMany
   */
  export type EnterpriseTutorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnterpriseTutors.
     */
    data: XOR<EnterpriseTutorUpdateManyMutationInput, EnterpriseTutorUncheckedUpdateManyInput>
    /**
     * Filter which EnterpriseTutors to update
     */
    where?: EnterpriseTutorWhereInput
  }


  /**
   * EnterpriseTutor upsert
   */
  export type EnterpriseTutorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    /**
     * The filter to search for the EnterpriseTutor to update in case it exists.
     */
    where: EnterpriseTutorWhereUniqueInput
    /**
     * In case the EnterpriseTutor found by the `where` argument doesn't exist, create a new EnterpriseTutor with this data.
     */
    create: XOR<EnterpriseTutorCreateInput, EnterpriseTutorUncheckedCreateInput>
    /**
     * In case the EnterpriseTutor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnterpriseTutorUpdateInput, EnterpriseTutorUncheckedUpdateInput>
  }


  /**
   * EnterpriseTutor delete
   */
  export type EnterpriseTutorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
    /**
     * Filter which EnterpriseTutor to delete.
     */
    where: EnterpriseTutorWhereUniqueInput
  }


  /**
   * EnterpriseTutor deleteMany
   */
  export type EnterpriseTutorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnterpriseTutors to delete
     */
    where?: EnterpriseTutorWhereInput
  }


  /**
   * EnterpriseTutor.students
   */
  export type EnterpriseTutor$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * EnterpriseTutor without action
   */
  export type EnterpriseTutorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseTutor
     */
    select?: EnterpriseTutorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseTutorInclude<ExtArgs> | null
  }



  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    name: string
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    internships?: boolean | Company$internshipsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    internships?: boolean | Company$internshipsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      internships: Prisma.$InternshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["company"]>
    composites: {}
  }


  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CompanyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends CompanyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Companies.
     *     @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const company = await prisma.company.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CompanyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends CompanyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    internships<T extends Company$internshipsArgs<ExtArgs> = {}>(args?: Subset<T, Company$internshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly name: FieldRef<"Company", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }


  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }


  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }


  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }


  /**
   * Company.internships
   */
  export type Company$internshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    where?: InternshipWhereInput
    orderBy?: InternshipOrderByWithRelationInput | InternshipOrderByWithRelationInput[]
    cursor?: InternshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternshipScalarFieldEnum | InternshipScalarFieldEnum[]
  }


  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
  }



  /**
   * Model Internship
   */

  export type AggregateInternship = {
    _count: InternshipCountAggregateOutputType | null
    _avg: InternshipAvgAggregateOutputType | null
    _sum: InternshipSumAggregateOutputType | null
    _min: InternshipMinAggregateOutputType | null
    _max: InternshipMaxAggregateOutputType | null
  }

  export type InternshipAvgAggregateOutputType = {
    id: number | null
    salary: number | null
    companyId: number | null
    tutorId: number | null
  }

  export type InternshipSumAggregateOutputType = {
    id: number | null
    salary: number | null
    companyId: number | null
    tutorId: number | null
  }

  export type InternshipMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    salary: number | null
    companyId: number | null
    tutorId: number | null
  }

  export type InternshipMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    salary: number | null
    companyId: number | null
    tutorId: number | null
  }

  export type InternshipCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startDate: number
    endDate: number
    salary: number
    companyId: number
    tutorId: number
    _all: number
  }


  export type InternshipAvgAggregateInputType = {
    id?: true
    salary?: true
    companyId?: true
    tutorId?: true
  }

  export type InternshipSumAggregateInputType = {
    id?: true
    salary?: true
    companyId?: true
    tutorId?: true
  }

  export type InternshipMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    salary?: true
    companyId?: true
    tutorId?: true
  }

  export type InternshipMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    salary?: true
    companyId?: true
    tutorId?: true
  }

  export type InternshipCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    salary?: true
    companyId?: true
    tutorId?: true
    _all?: true
  }

  export type InternshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Internship to aggregate.
     */
    where?: InternshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Internships to fetch.
     */
    orderBy?: InternshipOrderByWithRelationInput | InternshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InternshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Internships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Internships
    **/
    _count?: true | InternshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InternshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InternshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternshipMaxAggregateInputType
  }

  export type GetInternshipAggregateType<T extends InternshipAggregateArgs> = {
        [P in keyof T & keyof AggregateInternship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternship[P]>
      : GetScalarType<T[P], AggregateInternship[P]>
  }




  export type InternshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternshipWhereInput
    orderBy?: InternshipOrderByWithAggregationInput | InternshipOrderByWithAggregationInput[]
    by: InternshipScalarFieldEnum[] | InternshipScalarFieldEnum
    having?: InternshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternshipCountAggregateInputType | true
    _avg?: InternshipAvgAggregateInputType
    _sum?: InternshipSumAggregateInputType
    _min?: InternshipMinAggregateInputType
    _max?: InternshipMaxAggregateInputType
  }

  export type InternshipGroupByOutputType = {
    id: number
    title: string
    description: string
    startDate: Date
    endDate: Date
    salary: number
    companyId: number
    tutorId: number
    _count: InternshipCountAggregateOutputType | null
    _avg: InternshipAvgAggregateOutputType | null
    _sum: InternshipSumAggregateOutputType | null
    _min: InternshipMinAggregateOutputType | null
    _max: InternshipMaxAggregateOutputType | null
  }

  type GetInternshipGroupByPayload<T extends InternshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternshipGroupByOutputType[P]>
            : GetScalarType<T[P], InternshipGroupByOutputType[P]>
        }
      >
    >


  export type InternshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    salary?: boolean
    companyId?: boolean
    tutorId?: boolean
    evaluations?: boolean | Internship$evaluationsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    documents?: boolean | Internship$documentsArgs<ExtArgs>
    student?: boolean | Internship$studentArgs<ExtArgs>
    _count?: boolean | InternshipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internship"]>

  export type InternshipSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    salary?: boolean
    companyId?: boolean
    tutorId?: boolean
  }

  export type InternshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | Internship$evaluationsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    documents?: boolean | Internship$documentsArgs<ExtArgs>
    student?: boolean | Internship$studentArgs<ExtArgs>
    _count?: boolean | InternshipCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InternshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Internship"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      startDate: Date
      endDate: Date
      salary: number
      companyId: number
      tutorId: number
    }, ExtArgs["result"]["internship"]>
    composites: {}
  }


  type InternshipGetPayload<S extends boolean | null | undefined | InternshipDefaultArgs> = $Result.GetResult<Prisma.$InternshipPayload, S>

  type InternshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InternshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InternshipCountAggregateInputType | true
    }

  export interface InternshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Internship'], meta: { name: 'Internship' } }
    /**
     * Find zero or one Internship that matches the filter.
     * @param {InternshipFindUniqueArgs} args - Arguments to find a Internship
     * @example
     * // Get one Internship
     * const internship = await prisma.internship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InternshipFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InternshipFindUniqueArgs<ExtArgs>>
    ): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Internship that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InternshipFindUniqueOrThrowArgs} args - Arguments to find a Internship
     * @example
     * // Get one Internship
     * const internship = await prisma.internship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InternshipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InternshipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Internship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipFindFirstArgs} args - Arguments to find a Internship
     * @example
     * // Get one Internship
     * const internship = await prisma.internship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InternshipFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InternshipFindFirstArgs<ExtArgs>>
    ): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Internship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipFindFirstOrThrowArgs} args - Arguments to find a Internship
     * @example
     * // Get one Internship
     * const internship = await prisma.internship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InternshipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InternshipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Internships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Internships
     * const internships = await prisma.internship.findMany()
     * 
     * // Get first 10 Internships
     * const internships = await prisma.internship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internshipWithIdOnly = await prisma.internship.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InternshipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InternshipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Internship.
     * @param {InternshipCreateArgs} args - Arguments to create a Internship.
     * @example
     * // Create one Internship
     * const Internship = await prisma.internship.create({
     *   data: {
     *     // ... data to create a Internship
     *   }
     * })
     * 
    **/
    create<T extends InternshipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InternshipCreateArgs<ExtArgs>>
    ): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Internships.
     *     @param {InternshipCreateManyArgs} args - Arguments to create many Internships.
     *     @example
     *     // Create many Internships
     *     const internship = await prisma.internship.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InternshipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InternshipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Internship.
     * @param {InternshipDeleteArgs} args - Arguments to delete one Internship.
     * @example
     * // Delete one Internship
     * const Internship = await prisma.internship.delete({
     *   where: {
     *     // ... filter to delete one Internship
     *   }
     * })
     * 
    **/
    delete<T extends InternshipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InternshipDeleteArgs<ExtArgs>>
    ): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Internship.
     * @param {InternshipUpdateArgs} args - Arguments to update one Internship.
     * @example
     * // Update one Internship
     * const internship = await prisma.internship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InternshipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InternshipUpdateArgs<ExtArgs>>
    ): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Internships.
     * @param {InternshipDeleteManyArgs} args - Arguments to filter Internships to delete.
     * @example
     * // Delete a few Internships
     * const { count } = await prisma.internship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InternshipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InternshipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Internships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Internships
     * const internship = await prisma.internship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InternshipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InternshipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Internship.
     * @param {InternshipUpsertArgs} args - Arguments to update or create a Internship.
     * @example
     * // Update or create a Internship
     * const internship = await prisma.internship.upsert({
     *   create: {
     *     // ... data to create a Internship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Internship we want to update
     *   }
     * })
    **/
    upsert<T extends InternshipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InternshipUpsertArgs<ExtArgs>>
    ): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Internships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipCountArgs} args - Arguments to filter Internships to count.
     * @example
     * // Count the number of Internships
     * const count = await prisma.internship.count({
     *   where: {
     *     // ... the filter for the Internships we want to count
     *   }
     * })
    **/
    count<T extends InternshipCountArgs>(
      args?: Subset<T, InternshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Internship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternshipAggregateArgs>(args: Subset<T, InternshipAggregateArgs>): Prisma.PrismaPromise<GetInternshipAggregateType<T>>

    /**
     * Group by Internship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InternshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InternshipGroupByArgs['orderBy'] }
        : { orderBy?: InternshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InternshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Internship model
   */
  readonly fields: InternshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Internship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InternshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluations<T extends Internship$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Internship$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    documents<T extends Internship$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Internship$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    student<T extends Internship$studentArgs<ExtArgs> = {}>(args?: Subset<T, Internship$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Internship model
   */ 
  interface InternshipFieldRefs {
    readonly id: FieldRef<"Internship", 'Int'>
    readonly title: FieldRef<"Internship", 'String'>
    readonly description: FieldRef<"Internship", 'String'>
    readonly startDate: FieldRef<"Internship", 'DateTime'>
    readonly endDate: FieldRef<"Internship", 'DateTime'>
    readonly salary: FieldRef<"Internship", 'Int'>
    readonly companyId: FieldRef<"Internship", 'Int'>
    readonly tutorId: FieldRef<"Internship", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Internship findUnique
   */
  export type InternshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter, which Internship to fetch.
     */
    where: InternshipWhereUniqueInput
  }


  /**
   * Internship findUniqueOrThrow
   */
  export type InternshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter, which Internship to fetch.
     */
    where: InternshipWhereUniqueInput
  }


  /**
   * Internship findFirst
   */
  export type InternshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter, which Internship to fetch.
     */
    where?: InternshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Internships to fetch.
     */
    orderBy?: InternshipOrderByWithRelationInput | InternshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Internships.
     */
    cursor?: InternshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Internships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Internships.
     */
    distinct?: InternshipScalarFieldEnum | InternshipScalarFieldEnum[]
  }


  /**
   * Internship findFirstOrThrow
   */
  export type InternshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter, which Internship to fetch.
     */
    where?: InternshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Internships to fetch.
     */
    orderBy?: InternshipOrderByWithRelationInput | InternshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Internships.
     */
    cursor?: InternshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Internships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Internships.
     */
    distinct?: InternshipScalarFieldEnum | InternshipScalarFieldEnum[]
  }


  /**
   * Internship findMany
   */
  export type InternshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter, which Internships to fetch.
     */
    where?: InternshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Internships to fetch.
     */
    orderBy?: InternshipOrderByWithRelationInput | InternshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Internships.
     */
    cursor?: InternshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Internships.
     */
    skip?: number
    distinct?: InternshipScalarFieldEnum | InternshipScalarFieldEnum[]
  }


  /**
   * Internship create
   */
  export type InternshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Internship.
     */
    data: XOR<InternshipCreateInput, InternshipUncheckedCreateInput>
  }


  /**
   * Internship createMany
   */
  export type InternshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Internships.
     */
    data: InternshipCreateManyInput | InternshipCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Internship update
   */
  export type InternshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Internship.
     */
    data: XOR<InternshipUpdateInput, InternshipUncheckedUpdateInput>
    /**
     * Choose, which Internship to update.
     */
    where: InternshipWhereUniqueInput
  }


  /**
   * Internship updateMany
   */
  export type InternshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Internships.
     */
    data: XOR<InternshipUpdateManyMutationInput, InternshipUncheckedUpdateManyInput>
    /**
     * Filter which Internships to update
     */
    where?: InternshipWhereInput
  }


  /**
   * Internship upsert
   */
  export type InternshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Internship to update in case it exists.
     */
    where: InternshipWhereUniqueInput
    /**
     * In case the Internship found by the `where` argument doesn't exist, create a new Internship with this data.
     */
    create: XOR<InternshipCreateInput, InternshipUncheckedCreateInput>
    /**
     * In case the Internship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InternshipUpdateInput, InternshipUncheckedUpdateInput>
  }


  /**
   * Internship delete
   */
  export type InternshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter which Internship to delete.
     */
    where: InternshipWhereUniqueInput
  }


  /**
   * Internship deleteMany
   */
  export type InternshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Internships to delete
     */
    where?: InternshipWhereInput
  }


  /**
   * Internship.evaluations
   */
  export type Internship$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Internship.documents
   */
  export type Internship$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Internship.student
   */
  export type Internship$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }


  /**
   * Internship without action
   */
  export type InternshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
    internshipId: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
    internshipId: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: number | null
    documentType: string | null
    internshipId: number | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: number | null
    documentType: string | null
    internshipId: number | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    fileName: number
    filePath: number
    fileType: number
    fileSize: number
    documentType: number
    internshipId: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
    internshipId?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
    internshipId?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    documentType?: true
    internshipId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    documentType?: true
    internshipId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    documentType?: true
    internshipId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: number | null
    documentType: string
    internshipId: number | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    documentType?: boolean
    internshipId?: boolean
    CdC?: boolean | Document$CdCArgs<ExtArgs>
    Report?: boolean | Document$ReportArgs<ExtArgs>
    Internship?: boolean | Document$InternshipArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    documentType?: boolean
    internshipId?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CdC?: boolean | Document$CdCArgs<ExtArgs>
    Report?: boolean | Document$ReportArgs<ExtArgs>
    Internship?: boolean | Document$InternshipArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      CdC: Prisma.$CdCPayload<ExtArgs>[]
      Report: Prisma.$ReportPayload<ExtArgs>[]
      Internship: Prisma.$InternshipPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileName: string
      filePath: string
      fileType: string
      fileSize: number | null
      documentType: string
      internshipId: number | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CdC<T extends Document$CdCArgs<ExtArgs> = {}>(args?: Subset<T, Document$CdCArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CdCPayload<ExtArgs>, T, 'findMany'> | Null>;

    Report<T extends Document$ReportArgs<ExtArgs> = {}>(args?: Subset<T, Document$ReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'> | Null>;

    Internship<T extends Document$InternshipArgs<ExtArgs> = {}>(args?: Subset<T, Document$InternshipArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly fileName: FieldRef<"Document", 'String'>
    readonly filePath: FieldRef<"Document", 'String'>
    readonly fileType: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly documentType: FieldRef<"Document", 'String'>
    readonly internshipId: FieldRef<"Document", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data?: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document.CdC
   */
  export type Document$CdCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
    where?: CdCWhereInput
    orderBy?: CdCOrderByWithRelationInput | CdCOrderByWithRelationInput[]
    cursor?: CdCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CdCScalarFieldEnum | CdCScalarFieldEnum[]
  }


  /**
   * Document.Report
   */
  export type Document$ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Document.Internship
   */
  export type Document$InternshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternshipInclude<ExtArgs> | null
    where?: InternshipWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model CdC
   */

  export type AggregateCdC = {
    _count: CdCCountAggregateOutputType | null
    _avg: CdCAvgAggregateOutputType | null
    _sum: CdCSumAggregateOutputType | null
    _min: CdCMinAggregateOutputType | null
    _max: CdCMaxAggregateOutputType | null
  }

  export type CdCAvgAggregateOutputType = {
    id: number | null
  }

  export type CdCSumAggregateOutputType = {
    id: number | null
  }

  export type CdCMinAggregateOutputType = {
    id: number | null
    file: string | null
    documentId: string | null
  }

  export type CdCMaxAggregateOutputType = {
    id: number | null
    file: string | null
    documentId: string | null
  }

  export type CdCCountAggregateOutputType = {
    id: number
    file: number
    documentId: number
    _all: number
  }


  export type CdCAvgAggregateInputType = {
    id?: true
  }

  export type CdCSumAggregateInputType = {
    id?: true
  }

  export type CdCMinAggregateInputType = {
    id?: true
    file?: true
    documentId?: true
  }

  export type CdCMaxAggregateInputType = {
    id?: true
    file?: true
    documentId?: true
  }

  export type CdCCountAggregateInputType = {
    id?: true
    file?: true
    documentId?: true
    _all?: true
  }

  export type CdCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CdC to aggregate.
     */
    where?: CdCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CdCS to fetch.
     */
    orderBy?: CdCOrderByWithRelationInput | CdCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CdCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CdCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CdCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CdCS
    **/
    _count?: true | CdCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CdCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CdCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CdCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CdCMaxAggregateInputType
  }

  export type GetCdCAggregateType<T extends CdCAggregateArgs> = {
        [P in keyof T & keyof AggregateCdC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCdC[P]>
      : GetScalarType<T[P], AggregateCdC[P]>
  }




  export type CdCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CdCWhereInput
    orderBy?: CdCOrderByWithAggregationInput | CdCOrderByWithAggregationInput[]
    by: CdCScalarFieldEnum[] | CdCScalarFieldEnum
    having?: CdCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CdCCountAggregateInputType | true
    _avg?: CdCAvgAggregateInputType
    _sum?: CdCSumAggregateInputType
    _min?: CdCMinAggregateInputType
    _max?: CdCMaxAggregateInputType
  }

  export type CdCGroupByOutputType = {
    id: number
    file: string
    documentId: string
    _count: CdCCountAggregateOutputType | null
    _avg: CdCAvgAggregateOutputType | null
    _sum: CdCSumAggregateOutputType | null
    _min: CdCMinAggregateOutputType | null
    _max: CdCMaxAggregateOutputType | null
  }

  type GetCdCGroupByPayload<T extends CdCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CdCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CdCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CdCGroupByOutputType[P]>
            : GetScalarType<T[P], CdCGroupByOutputType[P]>
        }
      >
    >


  export type CdCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file?: boolean
    documentId?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cdC"]>

  export type CdCSelectScalar = {
    id?: boolean
    file?: boolean
    documentId?: boolean
  }

  export type CdCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }


  export type $CdCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CdC"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      file: string
      documentId: string
    }, ExtArgs["result"]["cdC"]>
    composites: {}
  }


  type CdCGetPayload<S extends boolean | null | undefined | CdCDefaultArgs> = $Result.GetResult<Prisma.$CdCPayload, S>

  type CdCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CdCFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CdCCountAggregateInputType | true
    }

  export interface CdCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CdC'], meta: { name: 'CdC' } }
    /**
     * Find zero or one CdC that matches the filter.
     * @param {CdCFindUniqueArgs} args - Arguments to find a CdC
     * @example
     * // Get one CdC
     * const cdC = await prisma.cdC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CdCFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CdCFindUniqueArgs<ExtArgs>>
    ): Prisma__CdCClient<$Result.GetResult<Prisma.$CdCPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CdC that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CdCFindUniqueOrThrowArgs} args - Arguments to find a CdC
     * @example
     * // Get one CdC
     * const cdC = await prisma.cdC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CdCFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CdCFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CdCClient<$Result.GetResult<Prisma.$CdCPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CdC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CdCFindFirstArgs} args - Arguments to find a CdC
     * @example
     * // Get one CdC
     * const cdC = await prisma.cdC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CdCFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CdCFindFirstArgs<ExtArgs>>
    ): Prisma__CdCClient<$Result.GetResult<Prisma.$CdCPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CdC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CdCFindFirstOrThrowArgs} args - Arguments to find a CdC
     * @example
     * // Get one CdC
     * const cdC = await prisma.cdC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CdCFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CdCFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CdCClient<$Result.GetResult<Prisma.$CdCPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CdCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CdCFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CdCS
     * const cdCS = await prisma.cdC.findMany()
     * 
     * // Get first 10 CdCS
     * const cdCS = await prisma.cdC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cdCWithIdOnly = await prisma.cdC.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CdCFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CdCFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CdCPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CdC.
     * @param {CdCCreateArgs} args - Arguments to create a CdC.
     * @example
     * // Create one CdC
     * const CdC = await prisma.cdC.create({
     *   data: {
     *     // ... data to create a CdC
     *   }
     * })
     * 
    **/
    create<T extends CdCCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CdCCreateArgs<ExtArgs>>
    ): Prisma__CdCClient<$Result.GetResult<Prisma.$CdCPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CdCS.
     *     @param {CdCCreateManyArgs} args - Arguments to create many CdCS.
     *     @example
     *     // Create many CdCS
     *     const cdC = await prisma.cdC.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CdCCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CdCCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CdC.
     * @param {CdCDeleteArgs} args - Arguments to delete one CdC.
     * @example
     * // Delete one CdC
     * const CdC = await prisma.cdC.delete({
     *   where: {
     *     // ... filter to delete one CdC
     *   }
     * })
     * 
    **/
    delete<T extends CdCDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CdCDeleteArgs<ExtArgs>>
    ): Prisma__CdCClient<$Result.GetResult<Prisma.$CdCPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CdC.
     * @param {CdCUpdateArgs} args - Arguments to update one CdC.
     * @example
     * // Update one CdC
     * const cdC = await prisma.cdC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CdCUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CdCUpdateArgs<ExtArgs>>
    ): Prisma__CdCClient<$Result.GetResult<Prisma.$CdCPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CdCS.
     * @param {CdCDeleteManyArgs} args - Arguments to filter CdCS to delete.
     * @example
     * // Delete a few CdCS
     * const { count } = await prisma.cdC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CdCDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CdCDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CdCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CdCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CdCS
     * const cdC = await prisma.cdC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CdCUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CdCUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CdC.
     * @param {CdCUpsertArgs} args - Arguments to update or create a CdC.
     * @example
     * // Update or create a CdC
     * const cdC = await prisma.cdC.upsert({
     *   create: {
     *     // ... data to create a CdC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CdC we want to update
     *   }
     * })
    **/
    upsert<T extends CdCUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CdCUpsertArgs<ExtArgs>>
    ): Prisma__CdCClient<$Result.GetResult<Prisma.$CdCPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CdCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CdCCountArgs} args - Arguments to filter CdCS to count.
     * @example
     * // Count the number of CdCS
     * const count = await prisma.cdC.count({
     *   where: {
     *     // ... the filter for the CdCS we want to count
     *   }
     * })
    **/
    count<T extends CdCCountArgs>(
      args?: Subset<T, CdCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CdCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CdC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CdCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CdCAggregateArgs>(args: Subset<T, CdCAggregateArgs>): Prisma.PrismaPromise<GetCdCAggregateType<T>>

    /**
     * Group by CdC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CdCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CdCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CdCGroupByArgs['orderBy'] }
        : { orderBy?: CdCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CdCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCdCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CdC model
   */
  readonly fields: CdCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CdC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CdCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CdC model
   */ 
  interface CdCFieldRefs {
    readonly id: FieldRef<"CdC", 'Int'>
    readonly file: FieldRef<"CdC", 'String'>
    readonly documentId: FieldRef<"CdC", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CdC findUnique
   */
  export type CdCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
    /**
     * Filter, which CdC to fetch.
     */
    where: CdCWhereUniqueInput
  }


  /**
   * CdC findUniqueOrThrow
   */
  export type CdCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
    /**
     * Filter, which CdC to fetch.
     */
    where: CdCWhereUniqueInput
  }


  /**
   * CdC findFirst
   */
  export type CdCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
    /**
     * Filter, which CdC to fetch.
     */
    where?: CdCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CdCS to fetch.
     */
    orderBy?: CdCOrderByWithRelationInput | CdCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CdCS.
     */
    cursor?: CdCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CdCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CdCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CdCS.
     */
    distinct?: CdCScalarFieldEnum | CdCScalarFieldEnum[]
  }


  /**
   * CdC findFirstOrThrow
   */
  export type CdCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
    /**
     * Filter, which CdC to fetch.
     */
    where?: CdCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CdCS to fetch.
     */
    orderBy?: CdCOrderByWithRelationInput | CdCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CdCS.
     */
    cursor?: CdCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CdCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CdCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CdCS.
     */
    distinct?: CdCScalarFieldEnum | CdCScalarFieldEnum[]
  }


  /**
   * CdC findMany
   */
  export type CdCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
    /**
     * Filter, which CdCS to fetch.
     */
    where?: CdCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CdCS to fetch.
     */
    orderBy?: CdCOrderByWithRelationInput | CdCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CdCS.
     */
    cursor?: CdCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CdCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CdCS.
     */
    skip?: number
    distinct?: CdCScalarFieldEnum | CdCScalarFieldEnum[]
  }


  /**
   * CdC create
   */
  export type CdCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
    /**
     * The data needed to create a CdC.
     */
    data: XOR<CdCCreateInput, CdCUncheckedCreateInput>
  }


  /**
   * CdC createMany
   */
  export type CdCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CdCS.
     */
    data: CdCCreateManyInput | CdCCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CdC update
   */
  export type CdCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
    /**
     * The data needed to update a CdC.
     */
    data: XOR<CdCUpdateInput, CdCUncheckedUpdateInput>
    /**
     * Choose, which CdC to update.
     */
    where: CdCWhereUniqueInput
  }


  /**
   * CdC updateMany
   */
  export type CdCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CdCS.
     */
    data: XOR<CdCUpdateManyMutationInput, CdCUncheckedUpdateManyInput>
    /**
     * Filter which CdCS to update
     */
    where?: CdCWhereInput
  }


  /**
   * CdC upsert
   */
  export type CdCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
    /**
     * The filter to search for the CdC to update in case it exists.
     */
    where: CdCWhereUniqueInput
    /**
     * In case the CdC found by the `where` argument doesn't exist, create a new CdC with this data.
     */
    create: XOR<CdCCreateInput, CdCUncheckedCreateInput>
    /**
     * In case the CdC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CdCUpdateInput, CdCUncheckedUpdateInput>
  }


  /**
   * CdC delete
   */
  export type CdCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
    /**
     * Filter which CdC to delete.
     */
    where: CdCWhereUniqueInput
  }


  /**
   * CdC deleteMany
   */
  export type CdCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CdCS to delete
     */
    where?: CdCWhereInput
  }


  /**
   * CdC without action
   */
  export type CdCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CdC
     */
    select?: CdCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CdCInclude<ExtArgs> | null
  }



  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    file: string | null
    documentId: string | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    file: string | null
    documentId: string | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    file: number
    documentId: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    file?: true
    documentId?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    file?: true
    documentId?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    file?: true
    documentId?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: number
    file: string
    documentId: string
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file?: boolean
    documentId?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    file?: boolean
    documentId?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }


  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      file: string
      documentId: string
    }, ExtArgs["result"]["report"]>
    composites: {}
  }


  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reports.
     *     @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'Int'>
    readonly file: FieldRef<"Report", 'String'>
    readonly documentId: FieldRef<"Report", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }


  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }


  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }


  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }


  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
  }



  /**
   * Model Evaluation
   */

  export type AggregateEvaluation = {
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  export type EvaluationAvgAggregateOutputType = {
    id: number | null
    factor: number | null
    internshipId: number | null
    studentId: number | null
  }

  export type EvaluationSumAggregateOutputType = {
    id: number | null
    factor: number | null
    internshipId: number | null
    studentId: number | null
  }

  export type EvaluationMinAggregateOutputType = {
    id: number | null
    evaluation: string | null
    submissionDate: Date | null
    factor: number | null
    internshipId: number | null
    studentId: number | null
  }

  export type EvaluationMaxAggregateOutputType = {
    id: number | null
    evaluation: string | null
    submissionDate: Date | null
    factor: number | null
    internshipId: number | null
    studentId: number | null
  }

  export type EvaluationCountAggregateOutputType = {
    id: number
    evaluation: number
    submissionDate: number
    factor: number
    internshipId: number
    studentId: number
    _all: number
  }


  export type EvaluationAvgAggregateInputType = {
    id?: true
    factor?: true
    internshipId?: true
    studentId?: true
  }

  export type EvaluationSumAggregateInputType = {
    id?: true
    factor?: true
    internshipId?: true
    studentId?: true
  }

  export type EvaluationMinAggregateInputType = {
    id?: true
    evaluation?: true
    submissionDate?: true
    factor?: true
    internshipId?: true
    studentId?: true
  }

  export type EvaluationMaxAggregateInputType = {
    id?: true
    evaluation?: true
    submissionDate?: true
    factor?: true
    internshipId?: true
    studentId?: true
  }

  export type EvaluationCountAggregateInputType = {
    id?: true
    evaluation?: true
    submissionDate?: true
    factor?: true
    internshipId?: true
    studentId?: true
    _all?: true
  }

  export type EvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluation to aggregate.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluations
    **/
    _count?: true | EvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationMaxAggregateInputType
  }

  export type GetEvaluationAggregateType<T extends EvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluation[P]>
      : GetScalarType<T[P], AggregateEvaluation[P]>
  }




  export type EvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithAggregationInput | EvaluationOrderByWithAggregationInput[]
    by: EvaluationScalarFieldEnum[] | EvaluationScalarFieldEnum
    having?: EvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationCountAggregateInputType | true
    _avg?: EvaluationAvgAggregateInputType
    _sum?: EvaluationSumAggregateInputType
    _min?: EvaluationMinAggregateInputType
    _max?: EvaluationMaxAggregateInputType
  }

  export type EvaluationGroupByOutputType = {
    id: number
    evaluation: string
    submissionDate: Date
    factor: number
    internshipId: number
    studentId: number | null
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  type GetEvaluationGroupByPayload<T extends EvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluation?: boolean
    submissionDate?: boolean
    factor?: boolean
    internshipId?: boolean
    studentId?: boolean
    ReportEvaluation?: boolean | Evaluation$ReportEvaluationArgs<ExtArgs>
    studentEvals?: boolean | Evaluation$studentEvalsArgs<ExtArgs>
    companyEvals?: boolean | Evaluation$companyEvalsArgs<ExtArgs>
    Student?: boolean | Evaluation$StudentArgs<ExtArgs>
    Internship?: boolean | InternshipDefaultArgs<ExtArgs>
    _count?: boolean | EvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectScalar = {
    id?: boolean
    evaluation?: boolean
    submissionDate?: boolean
    factor?: boolean
    internshipId?: boolean
    studentId?: boolean
  }

  export type EvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReportEvaluation?: boolean | Evaluation$ReportEvaluationArgs<ExtArgs>
    studentEvals?: boolean | Evaluation$studentEvalsArgs<ExtArgs>
    companyEvals?: boolean | Evaluation$companyEvalsArgs<ExtArgs>
    Student?: boolean | Evaluation$StudentArgs<ExtArgs>
    Internship?: boolean | InternshipDefaultArgs<ExtArgs>
    _count?: boolean | EvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evaluation"
    objects: {
      ReportEvaluation: Prisma.$ReportEvaluationPayload<ExtArgs>[]
      studentEvals: Prisma.$StudentEvaluationPayload<ExtArgs>[]
      companyEvals: Prisma.$CompanyEvaluationPayload<ExtArgs>[]
      Student: Prisma.$StudentPayload<ExtArgs> | null
      Internship: Prisma.$InternshipPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      evaluation: string
      submissionDate: Date
      factor: number
      internshipId: number
      studentId: number | null
    }, ExtArgs["result"]["evaluation"]>
    composites: {}
  }


  type EvaluationGetPayload<S extends boolean | null | undefined | EvaluationDefaultArgs> = $Result.GetResult<Prisma.$EvaluationPayload, S>

  type EvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationCountAggregateInputType | true
    }

  export interface EvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluation'], meta: { name: 'Evaluation' } }
    /**
     * Find zero or one Evaluation that matches the filter.
     * @param {EvaluationFindUniqueArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EvaluationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationFindUniqueArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Evaluation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EvaluationFindUniqueOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EvaluationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EvaluationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindFirstArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EvaluationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluations
     * const evaluations = await prisma.evaluation.findMany()
     * 
     * // Get first 10 Evaluations
     * const evaluations = await prisma.evaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EvaluationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Evaluation.
     * @param {EvaluationCreateArgs} args - Arguments to create a Evaluation.
     * @example
     * // Create one Evaluation
     * const Evaluation = await prisma.evaluation.create({
     *   data: {
     *     // ... data to create a Evaluation
     *   }
     * })
     * 
    **/
    create<T extends EvaluationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationCreateArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Evaluations.
     *     @param {EvaluationCreateManyArgs} args - Arguments to create many Evaluations.
     *     @example
     *     // Create many Evaluations
     *     const evaluation = await prisma.evaluation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EvaluationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evaluation.
     * @param {EvaluationDeleteArgs} args - Arguments to delete one Evaluation.
     * @example
     * // Delete one Evaluation
     * const Evaluation = await prisma.evaluation.delete({
     *   where: {
     *     // ... filter to delete one Evaluation
     *   }
     * })
     * 
    **/
    delete<T extends EvaluationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationDeleteArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Evaluation.
     * @param {EvaluationUpdateArgs} args - Arguments to update one Evaluation.
     * @example
     * // Update one Evaluation
     * const evaluation = await prisma.evaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EvaluationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpdateArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Evaluations.
     * @param {EvaluationDeleteManyArgs} args - Arguments to filter Evaluations to delete.
     * @example
     * // Delete a few Evaluations
     * const { count } = await prisma.evaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EvaluationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EvaluationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evaluation.
     * @param {EvaluationUpsertArgs} args - Arguments to update or create a Evaluation.
     * @example
     * // Update or create a Evaluation
     * const evaluation = await prisma.evaluation.upsert({
     *   create: {
     *     // ... data to create a Evaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluation we want to update
     *   }
     * })
    **/
    upsert<T extends EvaluationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpsertArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationCountArgs} args - Arguments to filter Evaluations to count.
     * @example
     * // Count the number of Evaluations
     * const count = await prisma.evaluation.count({
     *   where: {
     *     // ... the filter for the Evaluations we want to count
     *   }
     * })
    **/
    count<T extends EvaluationCountArgs>(
      args?: Subset<T, EvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationAggregateArgs>(args: Subset<T, EvaluationAggregateArgs>): Prisma.PrismaPromise<GetEvaluationAggregateType<T>>

    /**
     * Group by Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evaluation model
   */
  readonly fields: EvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ReportEvaluation<T extends Evaluation$ReportEvaluationArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$ReportEvaluationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportEvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    studentEvals<T extends Evaluation$studentEvalsArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$studentEvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    companyEvals<T extends Evaluation$companyEvalsArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$companyEvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyEvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    Student<T extends Evaluation$StudentArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$StudentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Internship<T extends InternshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InternshipDefaultArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Evaluation model
   */ 
  interface EvaluationFieldRefs {
    readonly id: FieldRef<"Evaluation", 'Int'>
    readonly evaluation: FieldRef<"Evaluation", 'String'>
    readonly submissionDate: FieldRef<"Evaluation", 'DateTime'>
    readonly factor: FieldRef<"Evaluation", 'Int'>
    readonly internshipId: FieldRef<"Evaluation", 'Int'>
    readonly studentId: FieldRef<"Evaluation", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Evaluation findUnique
   */
  export type EvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation findUniqueOrThrow
   */
  export type EvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation findFirst
   */
  export type EvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Evaluation findFirstOrThrow
   */
  export type EvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Evaluation findMany
   */
  export type EvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluations to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Evaluation create
   */
  export type EvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluation.
     */
    data: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
  }


  /**
   * Evaluation createMany
   */
  export type EvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Evaluation update
   */
  export type EvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluation.
     */
    data: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
    /**
     * Choose, which Evaluation to update.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation updateMany
   */
  export type EvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
  }


  /**
   * Evaluation upsert
   */
  export type EvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluation to update in case it exists.
     */
    where: EvaluationWhereUniqueInput
    /**
     * In case the Evaluation found by the `where` argument doesn't exist, create a new Evaluation with this data.
     */
    create: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
    /**
     * In case the Evaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
  }


  /**
   * Evaluation delete
   */
  export type EvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter which Evaluation to delete.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation deleteMany
   */
  export type EvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluations to delete
     */
    where?: EvaluationWhereInput
  }


  /**
   * Evaluation.ReportEvaluation
   */
  export type Evaluation$ReportEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
    where?: ReportEvaluationWhereInput
    orderBy?: ReportEvaluationOrderByWithRelationInput | ReportEvaluationOrderByWithRelationInput[]
    cursor?: ReportEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportEvaluationScalarFieldEnum | ReportEvaluationScalarFieldEnum[]
  }


  /**
   * Evaluation.studentEvals
   */
  export type Evaluation$studentEvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
    where?: StudentEvaluationWhereInput
    orderBy?: StudentEvaluationOrderByWithRelationInput | StudentEvaluationOrderByWithRelationInput[]
    cursor?: StudentEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEvaluationScalarFieldEnum | StudentEvaluationScalarFieldEnum[]
  }


  /**
   * Evaluation.companyEvals
   */
  export type Evaluation$companyEvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
    where?: CompanyEvaluationWhereInput
    orderBy?: CompanyEvaluationOrderByWithRelationInput | CompanyEvaluationOrderByWithRelationInput[]
    cursor?: CompanyEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyEvaluationScalarFieldEnum | CompanyEvaluationScalarFieldEnum[]
  }


  /**
   * Evaluation.Student
   */
  export type Evaluation$StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }


  /**
   * Evaluation without action
   */
  export type EvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
  }



  /**
   * Model StudentEvaluation
   */

  export type AggregateStudentEvaluation = {
    _count: StudentEvaluationCountAggregateOutputType | null
    _avg: StudentEvaluationAvgAggregateOutputType | null
    _sum: StudentEvaluationSumAggregateOutputType | null
    _min: StudentEvaluationMinAggregateOutputType | null
    _max: StudentEvaluationMaxAggregateOutputType | null
  }

  export type StudentEvaluationAvgAggregateOutputType = {
    id: number | null
    evaluationId: number | null
  }

  export type StudentEvaluationSumAggregateOutputType = {
    id: number | null
    evaluationId: number | null
  }

  export type StudentEvaluationMinAggregateOutputType = {
    id: number | null
    evaluationId: number | null
  }

  export type StudentEvaluationMaxAggregateOutputType = {
    id: number | null
    evaluationId: number | null
  }

  export type StudentEvaluationCountAggregateOutputType = {
    id: number
    evaluationId: number
    _all: number
  }


  export type StudentEvaluationAvgAggregateInputType = {
    id?: true
    evaluationId?: true
  }

  export type StudentEvaluationSumAggregateInputType = {
    id?: true
    evaluationId?: true
  }

  export type StudentEvaluationMinAggregateInputType = {
    id?: true
    evaluationId?: true
  }

  export type StudentEvaluationMaxAggregateInputType = {
    id?: true
    evaluationId?: true
  }

  export type StudentEvaluationCountAggregateInputType = {
    id?: true
    evaluationId?: true
    _all?: true
  }

  export type StudentEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEvaluation to aggregate.
     */
    where?: StudentEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEvaluations to fetch.
     */
    orderBy?: StudentEvaluationOrderByWithRelationInput | StudentEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentEvaluations
    **/
    _count?: true | StudentEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentEvaluationMaxAggregateInputType
  }

  export type GetStudentEvaluationAggregateType<T extends StudentEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentEvaluation[P]>
      : GetScalarType<T[P], AggregateStudentEvaluation[P]>
  }




  export type StudentEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEvaluationWhereInput
    orderBy?: StudentEvaluationOrderByWithAggregationInput | StudentEvaluationOrderByWithAggregationInput[]
    by: StudentEvaluationScalarFieldEnum[] | StudentEvaluationScalarFieldEnum
    having?: StudentEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentEvaluationCountAggregateInputType | true
    _avg?: StudentEvaluationAvgAggregateInputType
    _sum?: StudentEvaluationSumAggregateInputType
    _min?: StudentEvaluationMinAggregateInputType
    _max?: StudentEvaluationMaxAggregateInputType
  }

  export type StudentEvaluationGroupByOutputType = {
    id: number
    evaluationId: number
    _count: StudentEvaluationCountAggregateOutputType | null
    _avg: StudentEvaluationAvgAggregateOutputType | null
    _sum: StudentEvaluationSumAggregateOutputType | null
    _min: StudentEvaluationMinAggregateOutputType | null
    _max: StudentEvaluationMaxAggregateOutputType | null
  }

  type GetStudentEvaluationGroupByPayload<T extends StudentEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], StudentEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type StudentEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationId?: boolean
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEvaluation"]>

  export type StudentEvaluationSelectScalar = {
    id?: boolean
    evaluationId?: boolean
  }

  export type StudentEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
  }


  export type $StudentEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentEvaluation"
    objects: {
      evaluation: Prisma.$EvaluationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      evaluationId: number
    }, ExtArgs["result"]["studentEvaluation"]>
    composites: {}
  }


  type StudentEvaluationGetPayload<S extends boolean | null | undefined | StudentEvaluationDefaultArgs> = $Result.GetResult<Prisma.$StudentEvaluationPayload, S>

  type StudentEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentEvaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentEvaluationCountAggregateInputType | true
    }

  export interface StudentEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentEvaluation'], meta: { name: 'StudentEvaluation' } }
    /**
     * Find zero or one StudentEvaluation that matches the filter.
     * @param {StudentEvaluationFindUniqueArgs} args - Arguments to find a StudentEvaluation
     * @example
     * // Get one StudentEvaluation
     * const studentEvaluation = await prisma.studentEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentEvaluationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEvaluationFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentEvaluationClient<$Result.GetResult<Prisma.$StudentEvaluationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentEvaluation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentEvaluationFindUniqueOrThrowArgs} args - Arguments to find a StudentEvaluation
     * @example
     * // Get one StudentEvaluation
     * const studentEvaluation = await prisma.studentEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentEvaluationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEvaluationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentEvaluationClient<$Result.GetResult<Prisma.$StudentEvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEvaluationFindFirstArgs} args - Arguments to find a StudentEvaluation
     * @example
     * // Get one StudentEvaluation
     * const studentEvaluation = await prisma.studentEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentEvaluationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEvaluationFindFirstArgs<ExtArgs>>
    ): Prisma__StudentEvaluationClient<$Result.GetResult<Prisma.$StudentEvaluationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEvaluationFindFirstOrThrowArgs} args - Arguments to find a StudentEvaluation
     * @example
     * // Get one StudentEvaluation
     * const studentEvaluation = await prisma.studentEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentEvaluationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEvaluationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentEvaluationClient<$Result.GetResult<Prisma.$StudentEvaluationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEvaluationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentEvaluations
     * const studentEvaluations = await prisma.studentEvaluation.findMany()
     * 
     * // Get first 10 StudentEvaluations
     * const studentEvaluations = await prisma.studentEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentEvaluationWithIdOnly = await prisma.studentEvaluation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentEvaluationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEvaluationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEvaluationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentEvaluation.
     * @param {StudentEvaluationCreateArgs} args - Arguments to create a StudentEvaluation.
     * @example
     * // Create one StudentEvaluation
     * const StudentEvaluation = await prisma.studentEvaluation.create({
     *   data: {
     *     // ... data to create a StudentEvaluation
     *   }
     * })
     * 
    **/
    create<T extends StudentEvaluationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEvaluationCreateArgs<ExtArgs>>
    ): Prisma__StudentEvaluationClient<$Result.GetResult<Prisma.$StudentEvaluationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentEvaluations.
     *     @param {StudentEvaluationCreateManyArgs} args - Arguments to create many StudentEvaluations.
     *     @example
     *     // Create many StudentEvaluations
     *     const studentEvaluation = await prisma.studentEvaluation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentEvaluationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEvaluationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentEvaluation.
     * @param {StudentEvaluationDeleteArgs} args - Arguments to delete one StudentEvaluation.
     * @example
     * // Delete one StudentEvaluation
     * const StudentEvaluation = await prisma.studentEvaluation.delete({
     *   where: {
     *     // ... filter to delete one StudentEvaluation
     *   }
     * })
     * 
    **/
    delete<T extends StudentEvaluationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEvaluationDeleteArgs<ExtArgs>>
    ): Prisma__StudentEvaluationClient<$Result.GetResult<Prisma.$StudentEvaluationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentEvaluation.
     * @param {StudentEvaluationUpdateArgs} args - Arguments to update one StudentEvaluation.
     * @example
     * // Update one StudentEvaluation
     * const studentEvaluation = await prisma.studentEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentEvaluationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEvaluationUpdateArgs<ExtArgs>>
    ): Prisma__StudentEvaluationClient<$Result.GetResult<Prisma.$StudentEvaluationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentEvaluations.
     * @param {StudentEvaluationDeleteManyArgs} args - Arguments to filter StudentEvaluations to delete.
     * @example
     * // Delete a few StudentEvaluations
     * const { count } = await prisma.studentEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentEvaluationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEvaluationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentEvaluations
     * const studentEvaluation = await prisma.studentEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentEvaluationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEvaluationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentEvaluation.
     * @param {StudentEvaluationUpsertArgs} args - Arguments to update or create a StudentEvaluation.
     * @example
     * // Update or create a StudentEvaluation
     * const studentEvaluation = await prisma.studentEvaluation.upsert({
     *   create: {
     *     // ... data to create a StudentEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentEvaluation we want to update
     *   }
     * })
    **/
    upsert<T extends StudentEvaluationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEvaluationUpsertArgs<ExtArgs>>
    ): Prisma__StudentEvaluationClient<$Result.GetResult<Prisma.$StudentEvaluationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEvaluationCountArgs} args - Arguments to filter StudentEvaluations to count.
     * @example
     * // Count the number of StudentEvaluations
     * const count = await prisma.studentEvaluation.count({
     *   where: {
     *     // ... the filter for the StudentEvaluations we want to count
     *   }
     * })
    **/
    count<T extends StudentEvaluationCountArgs>(
      args?: Subset<T, StudentEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentEvaluationAggregateArgs>(args: Subset<T, StudentEvaluationAggregateArgs>): Prisma.PrismaPromise<GetStudentEvaluationAggregateType<T>>

    /**
     * Group by StudentEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: StudentEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentEvaluation model
   */
  readonly fields: StudentEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluation<T extends EvaluationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationDefaultArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentEvaluation model
   */ 
  interface StudentEvaluationFieldRefs {
    readonly id: FieldRef<"StudentEvaluation", 'Int'>
    readonly evaluationId: FieldRef<"StudentEvaluation", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * StudentEvaluation findUnique
   */
  export type StudentEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which StudentEvaluation to fetch.
     */
    where: StudentEvaluationWhereUniqueInput
  }


  /**
   * StudentEvaluation findUniqueOrThrow
   */
  export type StudentEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which StudentEvaluation to fetch.
     */
    where: StudentEvaluationWhereUniqueInput
  }


  /**
   * StudentEvaluation findFirst
   */
  export type StudentEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which StudentEvaluation to fetch.
     */
    where?: StudentEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEvaluations to fetch.
     */
    orderBy?: StudentEvaluationOrderByWithRelationInput | StudentEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEvaluations.
     */
    cursor?: StudentEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEvaluations.
     */
    distinct?: StudentEvaluationScalarFieldEnum | StudentEvaluationScalarFieldEnum[]
  }


  /**
   * StudentEvaluation findFirstOrThrow
   */
  export type StudentEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which StudentEvaluation to fetch.
     */
    where?: StudentEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEvaluations to fetch.
     */
    orderBy?: StudentEvaluationOrderByWithRelationInput | StudentEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEvaluations.
     */
    cursor?: StudentEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEvaluations.
     */
    distinct?: StudentEvaluationScalarFieldEnum | StudentEvaluationScalarFieldEnum[]
  }


  /**
   * StudentEvaluation findMany
   */
  export type StudentEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which StudentEvaluations to fetch.
     */
    where?: StudentEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEvaluations to fetch.
     */
    orderBy?: StudentEvaluationOrderByWithRelationInput | StudentEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentEvaluations.
     */
    cursor?: StudentEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEvaluations.
     */
    skip?: number
    distinct?: StudentEvaluationScalarFieldEnum | StudentEvaluationScalarFieldEnum[]
  }


  /**
   * StudentEvaluation create
   */
  export type StudentEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentEvaluation.
     */
    data: XOR<StudentEvaluationCreateInput, StudentEvaluationUncheckedCreateInput>
  }


  /**
   * StudentEvaluation createMany
   */
  export type StudentEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentEvaluations.
     */
    data: StudentEvaluationCreateManyInput | StudentEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentEvaluation update
   */
  export type StudentEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentEvaluation.
     */
    data: XOR<StudentEvaluationUpdateInput, StudentEvaluationUncheckedUpdateInput>
    /**
     * Choose, which StudentEvaluation to update.
     */
    where: StudentEvaluationWhereUniqueInput
  }


  /**
   * StudentEvaluation updateMany
   */
  export type StudentEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentEvaluations.
     */
    data: XOR<StudentEvaluationUpdateManyMutationInput, StudentEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which StudentEvaluations to update
     */
    where?: StudentEvaluationWhereInput
  }


  /**
   * StudentEvaluation upsert
   */
  export type StudentEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentEvaluation to update in case it exists.
     */
    where: StudentEvaluationWhereUniqueInput
    /**
     * In case the StudentEvaluation found by the `where` argument doesn't exist, create a new StudentEvaluation with this data.
     */
    create: XOR<StudentEvaluationCreateInput, StudentEvaluationUncheckedCreateInput>
    /**
     * In case the StudentEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentEvaluationUpdateInput, StudentEvaluationUncheckedUpdateInput>
  }


  /**
   * StudentEvaluation delete
   */
  export type StudentEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
    /**
     * Filter which StudentEvaluation to delete.
     */
    where: StudentEvaluationWhereUniqueInput
  }


  /**
   * StudentEvaluation deleteMany
   */
  export type StudentEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEvaluations to delete
     */
    where?: StudentEvaluationWhereInput
  }


  /**
   * StudentEvaluation without action
   */
  export type StudentEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEvaluation
     */
    select?: StudentEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEvaluationInclude<ExtArgs> | null
  }



  /**
   * Model CompanyEvaluation
   */

  export type AggregateCompanyEvaluation = {
    _count: CompanyEvaluationCountAggregateOutputType | null
    _avg: CompanyEvaluationAvgAggregateOutputType | null
    _sum: CompanyEvaluationSumAggregateOutputType | null
    _min: CompanyEvaluationMinAggregateOutputType | null
    _max: CompanyEvaluationMaxAggregateOutputType | null
  }

  export type CompanyEvaluationAvgAggregateOutputType = {
    id: number | null
    evaluationId: number | null
  }

  export type CompanyEvaluationSumAggregateOutputType = {
    id: number | null
    evaluationId: number | null
  }

  export type CompanyEvaluationMinAggregateOutputType = {
    id: number | null
    evaluationId: number | null
  }

  export type CompanyEvaluationMaxAggregateOutputType = {
    id: number | null
    evaluationId: number | null
  }

  export type CompanyEvaluationCountAggregateOutputType = {
    id: number
    evaluationId: number
    _all: number
  }


  export type CompanyEvaluationAvgAggregateInputType = {
    id?: true
    evaluationId?: true
  }

  export type CompanyEvaluationSumAggregateInputType = {
    id?: true
    evaluationId?: true
  }

  export type CompanyEvaluationMinAggregateInputType = {
    id?: true
    evaluationId?: true
  }

  export type CompanyEvaluationMaxAggregateInputType = {
    id?: true
    evaluationId?: true
  }

  export type CompanyEvaluationCountAggregateInputType = {
    id?: true
    evaluationId?: true
    _all?: true
  }

  export type CompanyEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyEvaluation to aggregate.
     */
    where?: CompanyEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEvaluations to fetch.
     */
    orderBy?: CompanyEvaluationOrderByWithRelationInput | CompanyEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyEvaluations
    **/
    _count?: true | CompanyEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyEvaluationMaxAggregateInputType
  }

  export type GetCompanyEvaluationAggregateType<T extends CompanyEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyEvaluation[P]>
      : GetScalarType<T[P], AggregateCompanyEvaluation[P]>
  }




  export type CompanyEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyEvaluationWhereInput
    orderBy?: CompanyEvaluationOrderByWithAggregationInput | CompanyEvaluationOrderByWithAggregationInput[]
    by: CompanyEvaluationScalarFieldEnum[] | CompanyEvaluationScalarFieldEnum
    having?: CompanyEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyEvaluationCountAggregateInputType | true
    _avg?: CompanyEvaluationAvgAggregateInputType
    _sum?: CompanyEvaluationSumAggregateInputType
    _min?: CompanyEvaluationMinAggregateInputType
    _max?: CompanyEvaluationMaxAggregateInputType
  }

  export type CompanyEvaluationGroupByOutputType = {
    id: number
    evaluationId: number
    _count: CompanyEvaluationCountAggregateOutputType | null
    _avg: CompanyEvaluationAvgAggregateOutputType | null
    _sum: CompanyEvaluationSumAggregateOutputType | null
    _min: CompanyEvaluationMinAggregateOutputType | null
    _max: CompanyEvaluationMaxAggregateOutputType | null
  }

  type GetCompanyEvaluationGroupByPayload<T extends CompanyEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type CompanyEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationId?: boolean
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyEvaluation"]>

  export type CompanyEvaluationSelectScalar = {
    id?: boolean
    evaluationId?: boolean
  }

  export type CompanyEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
  }


  export type $CompanyEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyEvaluation"
    objects: {
      evaluation: Prisma.$EvaluationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      evaluationId: number
    }, ExtArgs["result"]["companyEvaluation"]>
    composites: {}
  }


  type CompanyEvaluationGetPayload<S extends boolean | null | undefined | CompanyEvaluationDefaultArgs> = $Result.GetResult<Prisma.$CompanyEvaluationPayload, S>

  type CompanyEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyEvaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyEvaluationCountAggregateInputType | true
    }

  export interface CompanyEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyEvaluation'], meta: { name: 'CompanyEvaluation' } }
    /**
     * Find zero or one CompanyEvaluation that matches the filter.
     * @param {CompanyEvaluationFindUniqueArgs} args - Arguments to find a CompanyEvaluation
     * @example
     * // Get one CompanyEvaluation
     * const companyEvaluation = await prisma.companyEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyEvaluationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyEvaluationFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyEvaluationClient<$Result.GetResult<Prisma.$CompanyEvaluationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CompanyEvaluation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CompanyEvaluationFindUniqueOrThrowArgs} args - Arguments to find a CompanyEvaluation
     * @example
     * // Get one CompanyEvaluation
     * const companyEvaluation = await prisma.companyEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyEvaluationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyEvaluationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyEvaluationClient<$Result.GetResult<Prisma.$CompanyEvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CompanyEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEvaluationFindFirstArgs} args - Arguments to find a CompanyEvaluation
     * @example
     * // Get one CompanyEvaluation
     * const companyEvaluation = await prisma.companyEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyEvaluationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyEvaluationFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyEvaluationClient<$Result.GetResult<Prisma.$CompanyEvaluationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CompanyEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEvaluationFindFirstOrThrowArgs} args - Arguments to find a CompanyEvaluation
     * @example
     * // Get one CompanyEvaluation
     * const companyEvaluation = await prisma.companyEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyEvaluationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyEvaluationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyEvaluationClient<$Result.GetResult<Prisma.$CompanyEvaluationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CompanyEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEvaluationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyEvaluations
     * const companyEvaluations = await prisma.companyEvaluation.findMany()
     * 
     * // Get first 10 CompanyEvaluations
     * const companyEvaluations = await prisma.companyEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyEvaluationWithIdOnly = await prisma.companyEvaluation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CompanyEvaluationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyEvaluationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyEvaluationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CompanyEvaluation.
     * @param {CompanyEvaluationCreateArgs} args - Arguments to create a CompanyEvaluation.
     * @example
     * // Create one CompanyEvaluation
     * const CompanyEvaluation = await prisma.companyEvaluation.create({
     *   data: {
     *     // ... data to create a CompanyEvaluation
     *   }
     * })
     * 
    **/
    create<T extends CompanyEvaluationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyEvaluationCreateArgs<ExtArgs>>
    ): Prisma__CompanyEvaluationClient<$Result.GetResult<Prisma.$CompanyEvaluationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CompanyEvaluations.
     *     @param {CompanyEvaluationCreateManyArgs} args - Arguments to create many CompanyEvaluations.
     *     @example
     *     // Create many CompanyEvaluations
     *     const companyEvaluation = await prisma.companyEvaluation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CompanyEvaluationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyEvaluationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyEvaluation.
     * @param {CompanyEvaluationDeleteArgs} args - Arguments to delete one CompanyEvaluation.
     * @example
     * // Delete one CompanyEvaluation
     * const CompanyEvaluation = await prisma.companyEvaluation.delete({
     *   where: {
     *     // ... filter to delete one CompanyEvaluation
     *   }
     * })
     * 
    **/
    delete<T extends CompanyEvaluationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyEvaluationDeleteArgs<ExtArgs>>
    ): Prisma__CompanyEvaluationClient<$Result.GetResult<Prisma.$CompanyEvaluationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CompanyEvaluation.
     * @param {CompanyEvaluationUpdateArgs} args - Arguments to update one CompanyEvaluation.
     * @example
     * // Update one CompanyEvaluation
     * const companyEvaluation = await prisma.companyEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyEvaluationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyEvaluationUpdateArgs<ExtArgs>>
    ): Prisma__CompanyEvaluationClient<$Result.GetResult<Prisma.$CompanyEvaluationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CompanyEvaluations.
     * @param {CompanyEvaluationDeleteManyArgs} args - Arguments to filter CompanyEvaluations to delete.
     * @example
     * // Delete a few CompanyEvaluations
     * const { count } = await prisma.companyEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyEvaluationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyEvaluationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyEvaluations
     * const companyEvaluation = await prisma.companyEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyEvaluationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyEvaluationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyEvaluation.
     * @param {CompanyEvaluationUpsertArgs} args - Arguments to update or create a CompanyEvaluation.
     * @example
     * // Update or create a CompanyEvaluation
     * const companyEvaluation = await prisma.companyEvaluation.upsert({
     *   create: {
     *     // ... data to create a CompanyEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyEvaluation we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyEvaluationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyEvaluationUpsertArgs<ExtArgs>>
    ): Prisma__CompanyEvaluationClient<$Result.GetResult<Prisma.$CompanyEvaluationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CompanyEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEvaluationCountArgs} args - Arguments to filter CompanyEvaluations to count.
     * @example
     * // Count the number of CompanyEvaluations
     * const count = await prisma.companyEvaluation.count({
     *   where: {
     *     // ... the filter for the CompanyEvaluations we want to count
     *   }
     * })
    **/
    count<T extends CompanyEvaluationCountArgs>(
      args?: Subset<T, CompanyEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyEvaluationAggregateArgs>(args: Subset<T, CompanyEvaluationAggregateArgs>): Prisma.PrismaPromise<GetCompanyEvaluationAggregateType<T>>

    /**
     * Group by CompanyEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: CompanyEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyEvaluation model
   */
  readonly fields: CompanyEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluation<T extends EvaluationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationDefaultArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CompanyEvaluation model
   */ 
  interface CompanyEvaluationFieldRefs {
    readonly id: FieldRef<"CompanyEvaluation", 'Int'>
    readonly evaluationId: FieldRef<"CompanyEvaluation", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CompanyEvaluation findUnique
   */
  export type CompanyEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEvaluation to fetch.
     */
    where: CompanyEvaluationWhereUniqueInput
  }


  /**
   * CompanyEvaluation findUniqueOrThrow
   */
  export type CompanyEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEvaluation to fetch.
     */
    where: CompanyEvaluationWhereUniqueInput
  }


  /**
   * CompanyEvaluation findFirst
   */
  export type CompanyEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEvaluation to fetch.
     */
    where?: CompanyEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEvaluations to fetch.
     */
    orderBy?: CompanyEvaluationOrderByWithRelationInput | CompanyEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyEvaluations.
     */
    cursor?: CompanyEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyEvaluations.
     */
    distinct?: CompanyEvaluationScalarFieldEnum | CompanyEvaluationScalarFieldEnum[]
  }


  /**
   * CompanyEvaluation findFirstOrThrow
   */
  export type CompanyEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEvaluation to fetch.
     */
    where?: CompanyEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEvaluations to fetch.
     */
    orderBy?: CompanyEvaluationOrderByWithRelationInput | CompanyEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyEvaluations.
     */
    cursor?: CompanyEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyEvaluations.
     */
    distinct?: CompanyEvaluationScalarFieldEnum | CompanyEvaluationScalarFieldEnum[]
  }


  /**
   * CompanyEvaluation findMany
   */
  export type CompanyEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEvaluations to fetch.
     */
    where?: CompanyEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEvaluations to fetch.
     */
    orderBy?: CompanyEvaluationOrderByWithRelationInput | CompanyEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyEvaluations.
     */
    cursor?: CompanyEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEvaluations.
     */
    skip?: number
    distinct?: CompanyEvaluationScalarFieldEnum | CompanyEvaluationScalarFieldEnum[]
  }


  /**
   * CompanyEvaluation create
   */
  export type CompanyEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyEvaluation.
     */
    data: XOR<CompanyEvaluationCreateInput, CompanyEvaluationUncheckedCreateInput>
  }


  /**
   * CompanyEvaluation createMany
   */
  export type CompanyEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyEvaluations.
     */
    data: CompanyEvaluationCreateManyInput | CompanyEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CompanyEvaluation update
   */
  export type CompanyEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyEvaluation.
     */
    data: XOR<CompanyEvaluationUpdateInput, CompanyEvaluationUncheckedUpdateInput>
    /**
     * Choose, which CompanyEvaluation to update.
     */
    where: CompanyEvaluationWhereUniqueInput
  }


  /**
   * CompanyEvaluation updateMany
   */
  export type CompanyEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyEvaluations.
     */
    data: XOR<CompanyEvaluationUpdateManyMutationInput, CompanyEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which CompanyEvaluations to update
     */
    where?: CompanyEvaluationWhereInput
  }


  /**
   * CompanyEvaluation upsert
   */
  export type CompanyEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyEvaluation to update in case it exists.
     */
    where: CompanyEvaluationWhereUniqueInput
    /**
     * In case the CompanyEvaluation found by the `where` argument doesn't exist, create a new CompanyEvaluation with this data.
     */
    create: XOR<CompanyEvaluationCreateInput, CompanyEvaluationUncheckedCreateInput>
    /**
     * In case the CompanyEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyEvaluationUpdateInput, CompanyEvaluationUncheckedUpdateInput>
  }


  /**
   * CompanyEvaluation delete
   */
  export type CompanyEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
    /**
     * Filter which CompanyEvaluation to delete.
     */
    where: CompanyEvaluationWhereUniqueInput
  }


  /**
   * CompanyEvaluation deleteMany
   */
  export type CompanyEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyEvaluations to delete
     */
    where?: CompanyEvaluationWhereInput
  }


  /**
   * CompanyEvaluation without action
   */
  export type CompanyEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEvaluation
     */
    select?: CompanyEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyEvaluationInclude<ExtArgs> | null
  }



  /**
   * Model Soutenance
   */

  export type AggregateSoutenance = {
    _count: SoutenanceCountAggregateOutputType | null
    _avg: SoutenanceAvgAggregateOutputType | null
    _sum: SoutenanceSumAggregateOutputType | null
    _min: SoutenanceMinAggregateOutputType | null
    _max: SoutenanceMaxAggregateOutputType | null
  }

  export type SoutenanceAvgAggregateOutputType = {
    id: number | null
  }

  export type SoutenanceSumAggregateOutputType = {
    id: number | null
  }

  export type SoutenanceMinAggregateOutputType = {
    id: number | null
    date: Date | null
    status: string | null
  }

  export type SoutenanceMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    status: string | null
  }

  export type SoutenanceCountAggregateOutputType = {
    id: number
    date: number
    status: number
    _all: number
  }


  export type SoutenanceAvgAggregateInputType = {
    id?: true
  }

  export type SoutenanceSumAggregateInputType = {
    id?: true
  }

  export type SoutenanceMinAggregateInputType = {
    id?: true
    date?: true
    status?: true
  }

  export type SoutenanceMaxAggregateInputType = {
    id?: true
    date?: true
    status?: true
  }

  export type SoutenanceCountAggregateInputType = {
    id?: true
    date?: true
    status?: true
    _all?: true
  }

  export type SoutenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Soutenance to aggregate.
     */
    where?: SoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Soutenances to fetch.
     */
    orderBy?: SoutenanceOrderByWithRelationInput | SoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Soutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Soutenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Soutenances
    **/
    _count?: true | SoutenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoutenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoutenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoutenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoutenanceMaxAggregateInputType
  }

  export type GetSoutenanceAggregateType<T extends SoutenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateSoutenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoutenance[P]>
      : GetScalarType<T[P], AggregateSoutenance[P]>
  }




  export type SoutenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoutenanceWhereInput
    orderBy?: SoutenanceOrderByWithAggregationInput | SoutenanceOrderByWithAggregationInput[]
    by: SoutenanceScalarFieldEnum[] | SoutenanceScalarFieldEnum
    having?: SoutenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoutenanceCountAggregateInputType | true
    _avg?: SoutenanceAvgAggregateInputType
    _sum?: SoutenanceSumAggregateInputType
    _min?: SoutenanceMinAggregateInputType
    _max?: SoutenanceMaxAggregateInputType
  }

  export type SoutenanceGroupByOutputType = {
    id: number
    date: Date
    status: string
    _count: SoutenanceCountAggregateOutputType | null
    _avg: SoutenanceAvgAggregateOutputType | null
    _sum: SoutenanceSumAggregateOutputType | null
    _min: SoutenanceMinAggregateOutputType | null
    _max: SoutenanceMaxAggregateOutputType | null
  }

  type GetSoutenanceGroupByPayload<T extends SoutenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoutenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoutenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoutenanceGroupByOutputType[P]>
            : GetScalarType<T[P], SoutenanceGroupByOutputType[P]>
        }
      >
    >


  export type SoutenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    evaluations?: boolean | Soutenance$evaluationsArgs<ExtArgs>
    _count?: boolean | SoutenanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soutenance"]>

  export type SoutenanceSelectScalar = {
    id?: boolean
    date?: boolean
    status?: boolean
  }

  export type SoutenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | Soutenance$evaluationsArgs<ExtArgs>
    _count?: boolean | SoutenanceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SoutenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Soutenance"
    objects: {
      evaluations: Prisma.$SoutenanceEvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      status: string
    }, ExtArgs["result"]["soutenance"]>
    composites: {}
  }


  type SoutenanceGetPayload<S extends boolean | null | undefined | SoutenanceDefaultArgs> = $Result.GetResult<Prisma.$SoutenancePayload, S>

  type SoutenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SoutenanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SoutenanceCountAggregateInputType | true
    }

  export interface SoutenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Soutenance'], meta: { name: 'Soutenance' } }
    /**
     * Find zero or one Soutenance that matches the filter.
     * @param {SoutenanceFindUniqueArgs} args - Arguments to find a Soutenance
     * @example
     * // Get one Soutenance
     * const soutenance = await prisma.soutenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SoutenanceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceFindUniqueArgs<ExtArgs>>
    ): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Soutenance that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SoutenanceFindUniqueOrThrowArgs} args - Arguments to find a Soutenance
     * @example
     * // Get one Soutenance
     * const soutenance = await prisma.soutenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SoutenanceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Soutenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceFindFirstArgs} args - Arguments to find a Soutenance
     * @example
     * // Get one Soutenance
     * const soutenance = await prisma.soutenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SoutenanceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceFindFirstArgs<ExtArgs>>
    ): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Soutenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceFindFirstOrThrowArgs} args - Arguments to find a Soutenance
     * @example
     * // Get one Soutenance
     * const soutenance = await prisma.soutenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SoutenanceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Soutenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Soutenances
     * const soutenances = await prisma.soutenance.findMany()
     * 
     * // Get first 10 Soutenances
     * const soutenances = await prisma.soutenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const soutenanceWithIdOnly = await prisma.soutenance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SoutenanceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Soutenance.
     * @param {SoutenanceCreateArgs} args - Arguments to create a Soutenance.
     * @example
     * // Create one Soutenance
     * const Soutenance = await prisma.soutenance.create({
     *   data: {
     *     // ... data to create a Soutenance
     *   }
     * })
     * 
    **/
    create<T extends SoutenanceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceCreateArgs<ExtArgs>>
    ): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Soutenances.
     *     @param {SoutenanceCreateManyArgs} args - Arguments to create many Soutenances.
     *     @example
     *     // Create many Soutenances
     *     const soutenance = await prisma.soutenance.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SoutenanceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Soutenance.
     * @param {SoutenanceDeleteArgs} args - Arguments to delete one Soutenance.
     * @example
     * // Delete one Soutenance
     * const Soutenance = await prisma.soutenance.delete({
     *   where: {
     *     // ... filter to delete one Soutenance
     *   }
     * })
     * 
    **/
    delete<T extends SoutenanceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceDeleteArgs<ExtArgs>>
    ): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Soutenance.
     * @param {SoutenanceUpdateArgs} args - Arguments to update one Soutenance.
     * @example
     * // Update one Soutenance
     * const soutenance = await prisma.soutenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SoutenanceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceUpdateArgs<ExtArgs>>
    ): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Soutenances.
     * @param {SoutenanceDeleteManyArgs} args - Arguments to filter Soutenances to delete.
     * @example
     * // Delete a few Soutenances
     * const { count } = await prisma.soutenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SoutenanceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Soutenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Soutenances
     * const soutenance = await prisma.soutenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SoutenanceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Soutenance.
     * @param {SoutenanceUpsertArgs} args - Arguments to update or create a Soutenance.
     * @example
     * // Update or create a Soutenance
     * const soutenance = await prisma.soutenance.upsert({
     *   create: {
     *     // ... data to create a Soutenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Soutenance we want to update
     *   }
     * })
    **/
    upsert<T extends SoutenanceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceUpsertArgs<ExtArgs>>
    ): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Soutenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceCountArgs} args - Arguments to filter Soutenances to count.
     * @example
     * // Count the number of Soutenances
     * const count = await prisma.soutenance.count({
     *   where: {
     *     // ... the filter for the Soutenances we want to count
     *   }
     * })
    **/
    count<T extends SoutenanceCountArgs>(
      args?: Subset<T, SoutenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoutenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Soutenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoutenanceAggregateArgs>(args: Subset<T, SoutenanceAggregateArgs>): Prisma.PrismaPromise<GetSoutenanceAggregateType<T>>

    /**
     * Group by Soutenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoutenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoutenanceGroupByArgs['orderBy'] }
        : { orderBy?: SoutenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoutenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoutenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Soutenance model
   */
  readonly fields: SoutenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Soutenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoutenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluations<T extends Soutenance$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Soutenance$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoutenanceEvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Soutenance model
   */ 
  interface SoutenanceFieldRefs {
    readonly id: FieldRef<"Soutenance", 'Int'>
    readonly date: FieldRef<"Soutenance", 'DateTime'>
    readonly status: FieldRef<"Soutenance", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Soutenance findUnique
   */
  export type SoutenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which Soutenance to fetch.
     */
    where: SoutenanceWhereUniqueInput
  }


  /**
   * Soutenance findUniqueOrThrow
   */
  export type SoutenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which Soutenance to fetch.
     */
    where: SoutenanceWhereUniqueInput
  }


  /**
   * Soutenance findFirst
   */
  export type SoutenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which Soutenance to fetch.
     */
    where?: SoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Soutenances to fetch.
     */
    orderBy?: SoutenanceOrderByWithRelationInput | SoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Soutenances.
     */
    cursor?: SoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Soutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Soutenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Soutenances.
     */
    distinct?: SoutenanceScalarFieldEnum | SoutenanceScalarFieldEnum[]
  }


  /**
   * Soutenance findFirstOrThrow
   */
  export type SoutenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which Soutenance to fetch.
     */
    where?: SoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Soutenances to fetch.
     */
    orderBy?: SoutenanceOrderByWithRelationInput | SoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Soutenances.
     */
    cursor?: SoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Soutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Soutenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Soutenances.
     */
    distinct?: SoutenanceScalarFieldEnum | SoutenanceScalarFieldEnum[]
  }


  /**
   * Soutenance findMany
   */
  export type SoutenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which Soutenances to fetch.
     */
    where?: SoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Soutenances to fetch.
     */
    orderBy?: SoutenanceOrderByWithRelationInput | SoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Soutenances.
     */
    cursor?: SoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Soutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Soutenances.
     */
    skip?: number
    distinct?: SoutenanceScalarFieldEnum | SoutenanceScalarFieldEnum[]
  }


  /**
   * Soutenance create
   */
  export type SoutenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Soutenance.
     */
    data: XOR<SoutenanceCreateInput, SoutenanceUncheckedCreateInput>
  }


  /**
   * Soutenance createMany
   */
  export type SoutenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Soutenances.
     */
    data: SoutenanceCreateManyInput | SoutenanceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Soutenance update
   */
  export type SoutenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Soutenance.
     */
    data: XOR<SoutenanceUpdateInput, SoutenanceUncheckedUpdateInput>
    /**
     * Choose, which Soutenance to update.
     */
    where: SoutenanceWhereUniqueInput
  }


  /**
   * Soutenance updateMany
   */
  export type SoutenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Soutenances.
     */
    data: XOR<SoutenanceUpdateManyMutationInput, SoutenanceUncheckedUpdateManyInput>
    /**
     * Filter which Soutenances to update
     */
    where?: SoutenanceWhereInput
  }


  /**
   * Soutenance upsert
   */
  export type SoutenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Soutenance to update in case it exists.
     */
    where: SoutenanceWhereUniqueInput
    /**
     * In case the Soutenance found by the `where` argument doesn't exist, create a new Soutenance with this data.
     */
    create: XOR<SoutenanceCreateInput, SoutenanceUncheckedCreateInput>
    /**
     * In case the Soutenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoutenanceUpdateInput, SoutenanceUncheckedUpdateInput>
  }


  /**
   * Soutenance delete
   */
  export type SoutenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter which Soutenance to delete.
     */
    where: SoutenanceWhereUniqueInput
  }


  /**
   * Soutenance deleteMany
   */
  export type SoutenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Soutenances to delete
     */
    where?: SoutenanceWhereInput
  }


  /**
   * Soutenance.evaluations
   */
  export type Soutenance$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
    where?: SoutenanceEvaluationWhereInput
    orderBy?: SoutenanceEvaluationOrderByWithRelationInput | SoutenanceEvaluationOrderByWithRelationInput[]
    cursor?: SoutenanceEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoutenanceEvaluationScalarFieldEnum | SoutenanceEvaluationScalarFieldEnum[]
  }


  /**
   * Soutenance without action
   */
  export type SoutenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceInclude<ExtArgs> | null
  }



  /**
   * Model SoutenanceEvaluation
   */

  export type AggregateSoutenanceEvaluation = {
    _count: SoutenanceEvaluationCountAggregateOutputType | null
    _avg: SoutenanceEvaluationAvgAggregateOutputType | null
    _sum: SoutenanceEvaluationSumAggregateOutputType | null
    _min: SoutenanceEvaluationMinAggregateOutputType | null
    _max: SoutenanceEvaluationMaxAggregateOutputType | null
  }

  export type SoutenanceEvaluationAvgAggregateOutputType = {
    id: number | null
    soutenanceId: number | null
  }

  export type SoutenanceEvaluationSumAggregateOutputType = {
    id: number | null
    soutenanceId: number | null
  }

  export type SoutenanceEvaluationMinAggregateOutputType = {
    id: number | null
    soutenanceId: number | null
  }

  export type SoutenanceEvaluationMaxAggregateOutputType = {
    id: number | null
    soutenanceId: number | null
  }

  export type SoutenanceEvaluationCountAggregateOutputType = {
    id: number
    soutenanceId: number
    _all: number
  }


  export type SoutenanceEvaluationAvgAggregateInputType = {
    id?: true
    soutenanceId?: true
  }

  export type SoutenanceEvaluationSumAggregateInputType = {
    id?: true
    soutenanceId?: true
  }

  export type SoutenanceEvaluationMinAggregateInputType = {
    id?: true
    soutenanceId?: true
  }

  export type SoutenanceEvaluationMaxAggregateInputType = {
    id?: true
    soutenanceId?: true
  }

  export type SoutenanceEvaluationCountAggregateInputType = {
    id?: true
    soutenanceId?: true
    _all?: true
  }

  export type SoutenanceEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoutenanceEvaluation to aggregate.
     */
    where?: SoutenanceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoutenanceEvaluations to fetch.
     */
    orderBy?: SoutenanceEvaluationOrderByWithRelationInput | SoutenanceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoutenanceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoutenanceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoutenanceEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SoutenanceEvaluations
    **/
    _count?: true | SoutenanceEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoutenanceEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoutenanceEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoutenanceEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoutenanceEvaluationMaxAggregateInputType
  }

  export type GetSoutenanceEvaluationAggregateType<T extends SoutenanceEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateSoutenanceEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoutenanceEvaluation[P]>
      : GetScalarType<T[P], AggregateSoutenanceEvaluation[P]>
  }




  export type SoutenanceEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoutenanceEvaluationWhereInput
    orderBy?: SoutenanceEvaluationOrderByWithAggregationInput | SoutenanceEvaluationOrderByWithAggregationInput[]
    by: SoutenanceEvaluationScalarFieldEnum[] | SoutenanceEvaluationScalarFieldEnum
    having?: SoutenanceEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoutenanceEvaluationCountAggregateInputType | true
    _avg?: SoutenanceEvaluationAvgAggregateInputType
    _sum?: SoutenanceEvaluationSumAggregateInputType
    _min?: SoutenanceEvaluationMinAggregateInputType
    _max?: SoutenanceEvaluationMaxAggregateInputType
  }

  export type SoutenanceEvaluationGroupByOutputType = {
    id: number
    soutenanceId: number
    _count: SoutenanceEvaluationCountAggregateOutputType | null
    _avg: SoutenanceEvaluationAvgAggregateOutputType | null
    _sum: SoutenanceEvaluationSumAggregateOutputType | null
    _min: SoutenanceEvaluationMinAggregateOutputType | null
    _max: SoutenanceEvaluationMaxAggregateOutputType | null
  }

  type GetSoutenanceEvaluationGroupByPayload<T extends SoutenanceEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoutenanceEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoutenanceEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoutenanceEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], SoutenanceEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type SoutenanceEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    soutenanceId?: boolean
    soutenance?: boolean | SoutenanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soutenanceEvaluation"]>

  export type SoutenanceEvaluationSelectScalar = {
    id?: boolean
    soutenanceId?: boolean
  }

  export type SoutenanceEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soutenance?: boolean | SoutenanceDefaultArgs<ExtArgs>
  }


  export type $SoutenanceEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SoutenanceEvaluation"
    objects: {
      soutenance: Prisma.$SoutenancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      soutenanceId: number
    }, ExtArgs["result"]["soutenanceEvaluation"]>
    composites: {}
  }


  type SoutenanceEvaluationGetPayload<S extends boolean | null | undefined | SoutenanceEvaluationDefaultArgs> = $Result.GetResult<Prisma.$SoutenanceEvaluationPayload, S>

  type SoutenanceEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SoutenanceEvaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SoutenanceEvaluationCountAggregateInputType | true
    }

  export interface SoutenanceEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SoutenanceEvaluation'], meta: { name: 'SoutenanceEvaluation' } }
    /**
     * Find zero or one SoutenanceEvaluation that matches the filter.
     * @param {SoutenanceEvaluationFindUniqueArgs} args - Arguments to find a SoutenanceEvaluation
     * @example
     * // Get one SoutenanceEvaluation
     * const soutenanceEvaluation = await prisma.soutenanceEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SoutenanceEvaluationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceEvaluationFindUniqueArgs<ExtArgs>>
    ): Prisma__SoutenanceEvaluationClient<$Result.GetResult<Prisma.$SoutenanceEvaluationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SoutenanceEvaluation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SoutenanceEvaluationFindUniqueOrThrowArgs} args - Arguments to find a SoutenanceEvaluation
     * @example
     * // Get one SoutenanceEvaluation
     * const soutenanceEvaluation = await prisma.soutenanceEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SoutenanceEvaluationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceEvaluationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SoutenanceEvaluationClient<$Result.GetResult<Prisma.$SoutenanceEvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SoutenanceEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceEvaluationFindFirstArgs} args - Arguments to find a SoutenanceEvaluation
     * @example
     * // Get one SoutenanceEvaluation
     * const soutenanceEvaluation = await prisma.soutenanceEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SoutenanceEvaluationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceEvaluationFindFirstArgs<ExtArgs>>
    ): Prisma__SoutenanceEvaluationClient<$Result.GetResult<Prisma.$SoutenanceEvaluationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SoutenanceEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceEvaluationFindFirstOrThrowArgs} args - Arguments to find a SoutenanceEvaluation
     * @example
     * // Get one SoutenanceEvaluation
     * const soutenanceEvaluation = await prisma.soutenanceEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SoutenanceEvaluationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceEvaluationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SoutenanceEvaluationClient<$Result.GetResult<Prisma.$SoutenanceEvaluationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SoutenanceEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceEvaluationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SoutenanceEvaluations
     * const soutenanceEvaluations = await prisma.soutenanceEvaluation.findMany()
     * 
     * // Get first 10 SoutenanceEvaluations
     * const soutenanceEvaluations = await prisma.soutenanceEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const soutenanceEvaluationWithIdOnly = await prisma.soutenanceEvaluation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SoutenanceEvaluationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceEvaluationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoutenanceEvaluationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SoutenanceEvaluation.
     * @param {SoutenanceEvaluationCreateArgs} args - Arguments to create a SoutenanceEvaluation.
     * @example
     * // Create one SoutenanceEvaluation
     * const SoutenanceEvaluation = await prisma.soutenanceEvaluation.create({
     *   data: {
     *     // ... data to create a SoutenanceEvaluation
     *   }
     * })
     * 
    **/
    create<T extends SoutenanceEvaluationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceEvaluationCreateArgs<ExtArgs>>
    ): Prisma__SoutenanceEvaluationClient<$Result.GetResult<Prisma.$SoutenanceEvaluationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SoutenanceEvaluations.
     *     @param {SoutenanceEvaluationCreateManyArgs} args - Arguments to create many SoutenanceEvaluations.
     *     @example
     *     // Create many SoutenanceEvaluations
     *     const soutenanceEvaluation = await prisma.soutenanceEvaluation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SoutenanceEvaluationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceEvaluationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SoutenanceEvaluation.
     * @param {SoutenanceEvaluationDeleteArgs} args - Arguments to delete one SoutenanceEvaluation.
     * @example
     * // Delete one SoutenanceEvaluation
     * const SoutenanceEvaluation = await prisma.soutenanceEvaluation.delete({
     *   where: {
     *     // ... filter to delete one SoutenanceEvaluation
     *   }
     * })
     * 
    **/
    delete<T extends SoutenanceEvaluationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceEvaluationDeleteArgs<ExtArgs>>
    ): Prisma__SoutenanceEvaluationClient<$Result.GetResult<Prisma.$SoutenanceEvaluationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SoutenanceEvaluation.
     * @param {SoutenanceEvaluationUpdateArgs} args - Arguments to update one SoutenanceEvaluation.
     * @example
     * // Update one SoutenanceEvaluation
     * const soutenanceEvaluation = await prisma.soutenanceEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SoutenanceEvaluationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceEvaluationUpdateArgs<ExtArgs>>
    ): Prisma__SoutenanceEvaluationClient<$Result.GetResult<Prisma.$SoutenanceEvaluationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SoutenanceEvaluations.
     * @param {SoutenanceEvaluationDeleteManyArgs} args - Arguments to filter SoutenanceEvaluations to delete.
     * @example
     * // Delete a few SoutenanceEvaluations
     * const { count } = await prisma.soutenanceEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SoutenanceEvaluationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoutenanceEvaluationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SoutenanceEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SoutenanceEvaluations
     * const soutenanceEvaluation = await prisma.soutenanceEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SoutenanceEvaluationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceEvaluationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SoutenanceEvaluation.
     * @param {SoutenanceEvaluationUpsertArgs} args - Arguments to update or create a SoutenanceEvaluation.
     * @example
     * // Update or create a SoutenanceEvaluation
     * const soutenanceEvaluation = await prisma.soutenanceEvaluation.upsert({
     *   create: {
     *     // ... data to create a SoutenanceEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SoutenanceEvaluation we want to update
     *   }
     * })
    **/
    upsert<T extends SoutenanceEvaluationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SoutenanceEvaluationUpsertArgs<ExtArgs>>
    ): Prisma__SoutenanceEvaluationClient<$Result.GetResult<Prisma.$SoutenanceEvaluationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SoutenanceEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceEvaluationCountArgs} args - Arguments to filter SoutenanceEvaluations to count.
     * @example
     * // Count the number of SoutenanceEvaluations
     * const count = await prisma.soutenanceEvaluation.count({
     *   where: {
     *     // ... the filter for the SoutenanceEvaluations we want to count
     *   }
     * })
    **/
    count<T extends SoutenanceEvaluationCountArgs>(
      args?: Subset<T, SoutenanceEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoutenanceEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SoutenanceEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoutenanceEvaluationAggregateArgs>(args: Subset<T, SoutenanceEvaluationAggregateArgs>): Prisma.PrismaPromise<GetSoutenanceEvaluationAggregateType<T>>

    /**
     * Group by SoutenanceEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoutenanceEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoutenanceEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: SoutenanceEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoutenanceEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoutenanceEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SoutenanceEvaluation model
   */
  readonly fields: SoutenanceEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SoutenanceEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoutenanceEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    soutenance<T extends SoutenanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SoutenanceDefaultArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SoutenanceEvaluation model
   */ 
  interface SoutenanceEvaluationFieldRefs {
    readonly id: FieldRef<"SoutenanceEvaluation", 'Int'>
    readonly soutenanceId: FieldRef<"SoutenanceEvaluation", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SoutenanceEvaluation findUnique
   */
  export type SoutenanceEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which SoutenanceEvaluation to fetch.
     */
    where: SoutenanceEvaluationWhereUniqueInput
  }


  /**
   * SoutenanceEvaluation findUniqueOrThrow
   */
  export type SoutenanceEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which SoutenanceEvaluation to fetch.
     */
    where: SoutenanceEvaluationWhereUniqueInput
  }


  /**
   * SoutenanceEvaluation findFirst
   */
  export type SoutenanceEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which SoutenanceEvaluation to fetch.
     */
    where?: SoutenanceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoutenanceEvaluations to fetch.
     */
    orderBy?: SoutenanceEvaluationOrderByWithRelationInput | SoutenanceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoutenanceEvaluations.
     */
    cursor?: SoutenanceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoutenanceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoutenanceEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoutenanceEvaluations.
     */
    distinct?: SoutenanceEvaluationScalarFieldEnum | SoutenanceEvaluationScalarFieldEnum[]
  }


  /**
   * SoutenanceEvaluation findFirstOrThrow
   */
  export type SoutenanceEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which SoutenanceEvaluation to fetch.
     */
    where?: SoutenanceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoutenanceEvaluations to fetch.
     */
    orderBy?: SoutenanceEvaluationOrderByWithRelationInput | SoutenanceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoutenanceEvaluations.
     */
    cursor?: SoutenanceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoutenanceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoutenanceEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoutenanceEvaluations.
     */
    distinct?: SoutenanceEvaluationScalarFieldEnum | SoutenanceEvaluationScalarFieldEnum[]
  }


  /**
   * SoutenanceEvaluation findMany
   */
  export type SoutenanceEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which SoutenanceEvaluations to fetch.
     */
    where?: SoutenanceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoutenanceEvaluations to fetch.
     */
    orderBy?: SoutenanceEvaluationOrderByWithRelationInput | SoutenanceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SoutenanceEvaluations.
     */
    cursor?: SoutenanceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoutenanceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoutenanceEvaluations.
     */
    skip?: number
    distinct?: SoutenanceEvaluationScalarFieldEnum | SoutenanceEvaluationScalarFieldEnum[]
  }


  /**
   * SoutenanceEvaluation create
   */
  export type SoutenanceEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a SoutenanceEvaluation.
     */
    data: XOR<SoutenanceEvaluationCreateInput, SoutenanceEvaluationUncheckedCreateInput>
  }


  /**
   * SoutenanceEvaluation createMany
   */
  export type SoutenanceEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SoutenanceEvaluations.
     */
    data: SoutenanceEvaluationCreateManyInput | SoutenanceEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SoutenanceEvaluation update
   */
  export type SoutenanceEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a SoutenanceEvaluation.
     */
    data: XOR<SoutenanceEvaluationUpdateInput, SoutenanceEvaluationUncheckedUpdateInput>
    /**
     * Choose, which SoutenanceEvaluation to update.
     */
    where: SoutenanceEvaluationWhereUniqueInput
  }


  /**
   * SoutenanceEvaluation updateMany
   */
  export type SoutenanceEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SoutenanceEvaluations.
     */
    data: XOR<SoutenanceEvaluationUpdateManyMutationInput, SoutenanceEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which SoutenanceEvaluations to update
     */
    where?: SoutenanceEvaluationWhereInput
  }


  /**
   * SoutenanceEvaluation upsert
   */
  export type SoutenanceEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the SoutenanceEvaluation to update in case it exists.
     */
    where: SoutenanceEvaluationWhereUniqueInput
    /**
     * In case the SoutenanceEvaluation found by the `where` argument doesn't exist, create a new SoutenanceEvaluation with this data.
     */
    create: XOR<SoutenanceEvaluationCreateInput, SoutenanceEvaluationUncheckedCreateInput>
    /**
     * In case the SoutenanceEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoutenanceEvaluationUpdateInput, SoutenanceEvaluationUncheckedUpdateInput>
  }


  /**
   * SoutenanceEvaluation delete
   */
  export type SoutenanceEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter which SoutenanceEvaluation to delete.
     */
    where: SoutenanceEvaluationWhereUniqueInput
  }


  /**
   * SoutenanceEvaluation deleteMany
   */
  export type SoutenanceEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoutenanceEvaluations to delete
     */
    where?: SoutenanceEvaluationWhereInput
  }


  /**
   * SoutenanceEvaluation without action
   */
  export type SoutenanceEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceEvaluation
     */
    select?: SoutenanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoutenanceEvaluationInclude<ExtArgs> | null
  }



  /**
   * Model ReportEvaluation
   */

  export type AggregateReportEvaluation = {
    _count: ReportEvaluationCountAggregateOutputType | null
    _avg: ReportEvaluationAvgAggregateOutputType | null
    _sum: ReportEvaluationSumAggregateOutputType | null
    _min: ReportEvaluationMinAggregateOutputType | null
    _max: ReportEvaluationMaxAggregateOutputType | null
  }

  export type ReportEvaluationAvgAggregateOutputType = {
    id: number | null
    reportEvalId: number | null
    evaluationId: number | null
  }

  export type ReportEvaluationSumAggregateOutputType = {
    id: number | null
    reportEvalId: number | null
    evaluationId: number | null
  }

  export type ReportEvaluationMinAggregateOutputType = {
    id: number | null
    reportEvalId: number | null
    evaluationId: number | null
  }

  export type ReportEvaluationMaxAggregateOutputType = {
    id: number | null
    reportEvalId: number | null
    evaluationId: number | null
  }

  export type ReportEvaluationCountAggregateOutputType = {
    id: number
    reportEvalId: number
    evaluationId: number
    _all: number
  }


  export type ReportEvaluationAvgAggregateInputType = {
    id?: true
    reportEvalId?: true
    evaluationId?: true
  }

  export type ReportEvaluationSumAggregateInputType = {
    id?: true
    reportEvalId?: true
    evaluationId?: true
  }

  export type ReportEvaluationMinAggregateInputType = {
    id?: true
    reportEvalId?: true
    evaluationId?: true
  }

  export type ReportEvaluationMaxAggregateInputType = {
    id?: true
    reportEvalId?: true
    evaluationId?: true
  }

  export type ReportEvaluationCountAggregateInputType = {
    id?: true
    reportEvalId?: true
    evaluationId?: true
    _all?: true
  }

  export type ReportEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportEvaluation to aggregate.
     */
    where?: ReportEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportEvaluations to fetch.
     */
    orderBy?: ReportEvaluationOrderByWithRelationInput | ReportEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportEvaluations
    **/
    _count?: true | ReportEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportEvaluationMaxAggregateInputType
  }

  export type GetReportEvaluationAggregateType<T extends ReportEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateReportEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportEvaluation[P]>
      : GetScalarType<T[P], AggregateReportEvaluation[P]>
  }




  export type ReportEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportEvaluationWhereInput
    orderBy?: ReportEvaluationOrderByWithAggregationInput | ReportEvaluationOrderByWithAggregationInput[]
    by: ReportEvaluationScalarFieldEnum[] | ReportEvaluationScalarFieldEnum
    having?: ReportEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportEvaluationCountAggregateInputType | true
    _avg?: ReportEvaluationAvgAggregateInputType
    _sum?: ReportEvaluationSumAggregateInputType
    _min?: ReportEvaluationMinAggregateInputType
    _max?: ReportEvaluationMaxAggregateInputType
  }

  export type ReportEvaluationGroupByOutputType = {
    id: number
    reportEvalId: number
    evaluationId: number
    _count: ReportEvaluationCountAggregateOutputType | null
    _avg: ReportEvaluationAvgAggregateOutputType | null
    _sum: ReportEvaluationSumAggregateOutputType | null
    _min: ReportEvaluationMinAggregateOutputType | null
    _max: ReportEvaluationMaxAggregateOutputType | null
  }

  type GetReportEvaluationGroupByPayload<T extends ReportEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], ReportEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type ReportEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportEvalId?: boolean
    evaluationId?: boolean
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportEvaluation"]>

  export type ReportEvaluationSelectScalar = {
    id?: boolean
    reportEvalId?: boolean
    evaluationId?: boolean
  }

  export type ReportEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
  }


  export type $ReportEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportEvaluation"
    objects: {
      evaluation: Prisma.$EvaluationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reportEvalId: number
      evaluationId: number
    }, ExtArgs["result"]["reportEvaluation"]>
    composites: {}
  }


  type ReportEvaluationGetPayload<S extends boolean | null | undefined | ReportEvaluationDefaultArgs> = $Result.GetResult<Prisma.$ReportEvaluationPayload, S>

  type ReportEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportEvaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportEvaluationCountAggregateInputType | true
    }

  export interface ReportEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportEvaluation'], meta: { name: 'ReportEvaluation' } }
    /**
     * Find zero or one ReportEvaluation that matches the filter.
     * @param {ReportEvaluationFindUniqueArgs} args - Arguments to find a ReportEvaluation
     * @example
     * // Get one ReportEvaluation
     * const reportEvaluation = await prisma.reportEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportEvaluationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReportEvaluationFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportEvaluationClient<$Result.GetResult<Prisma.$ReportEvaluationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ReportEvaluation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportEvaluationFindUniqueOrThrowArgs} args - Arguments to find a ReportEvaluation
     * @example
     * // Get one ReportEvaluation
     * const reportEvaluation = await prisma.reportEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportEvaluationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportEvaluationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportEvaluationClient<$Result.GetResult<Prisma.$ReportEvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ReportEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportEvaluationFindFirstArgs} args - Arguments to find a ReportEvaluation
     * @example
     * // Get one ReportEvaluation
     * const reportEvaluation = await prisma.reportEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportEvaluationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportEvaluationFindFirstArgs<ExtArgs>>
    ): Prisma__ReportEvaluationClient<$Result.GetResult<Prisma.$ReportEvaluationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ReportEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportEvaluationFindFirstOrThrowArgs} args - Arguments to find a ReportEvaluation
     * @example
     * // Get one ReportEvaluation
     * const reportEvaluation = await prisma.reportEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportEvaluationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportEvaluationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportEvaluationClient<$Result.GetResult<Prisma.$ReportEvaluationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ReportEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportEvaluationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportEvaluations
     * const reportEvaluations = await prisma.reportEvaluation.findMany()
     * 
     * // Get first 10 ReportEvaluations
     * const reportEvaluations = await prisma.reportEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportEvaluationWithIdOnly = await prisma.reportEvaluation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportEvaluationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportEvaluationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportEvaluationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ReportEvaluation.
     * @param {ReportEvaluationCreateArgs} args - Arguments to create a ReportEvaluation.
     * @example
     * // Create one ReportEvaluation
     * const ReportEvaluation = await prisma.reportEvaluation.create({
     *   data: {
     *     // ... data to create a ReportEvaluation
     *   }
     * })
     * 
    **/
    create<T extends ReportEvaluationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportEvaluationCreateArgs<ExtArgs>>
    ): Prisma__ReportEvaluationClient<$Result.GetResult<Prisma.$ReportEvaluationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ReportEvaluations.
     *     @param {ReportEvaluationCreateManyArgs} args - Arguments to create many ReportEvaluations.
     *     @example
     *     // Create many ReportEvaluations
     *     const reportEvaluation = await prisma.reportEvaluation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportEvaluationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportEvaluationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReportEvaluation.
     * @param {ReportEvaluationDeleteArgs} args - Arguments to delete one ReportEvaluation.
     * @example
     * // Delete one ReportEvaluation
     * const ReportEvaluation = await prisma.reportEvaluation.delete({
     *   where: {
     *     // ... filter to delete one ReportEvaluation
     *   }
     * })
     * 
    **/
    delete<T extends ReportEvaluationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportEvaluationDeleteArgs<ExtArgs>>
    ): Prisma__ReportEvaluationClient<$Result.GetResult<Prisma.$ReportEvaluationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ReportEvaluation.
     * @param {ReportEvaluationUpdateArgs} args - Arguments to update one ReportEvaluation.
     * @example
     * // Update one ReportEvaluation
     * const reportEvaluation = await prisma.reportEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportEvaluationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportEvaluationUpdateArgs<ExtArgs>>
    ): Prisma__ReportEvaluationClient<$Result.GetResult<Prisma.$ReportEvaluationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ReportEvaluations.
     * @param {ReportEvaluationDeleteManyArgs} args - Arguments to filter ReportEvaluations to delete.
     * @example
     * // Delete a few ReportEvaluations
     * const { count } = await prisma.reportEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportEvaluationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportEvaluationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportEvaluations
     * const reportEvaluation = await prisma.reportEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportEvaluationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportEvaluationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportEvaluation.
     * @param {ReportEvaluationUpsertArgs} args - Arguments to update or create a ReportEvaluation.
     * @example
     * // Update or create a ReportEvaluation
     * const reportEvaluation = await prisma.reportEvaluation.upsert({
     *   create: {
     *     // ... data to create a ReportEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportEvaluation we want to update
     *   }
     * })
    **/
    upsert<T extends ReportEvaluationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportEvaluationUpsertArgs<ExtArgs>>
    ): Prisma__ReportEvaluationClient<$Result.GetResult<Prisma.$ReportEvaluationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ReportEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportEvaluationCountArgs} args - Arguments to filter ReportEvaluations to count.
     * @example
     * // Count the number of ReportEvaluations
     * const count = await prisma.reportEvaluation.count({
     *   where: {
     *     // ... the filter for the ReportEvaluations we want to count
     *   }
     * })
    **/
    count<T extends ReportEvaluationCountArgs>(
      args?: Subset<T, ReportEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportEvaluationAggregateArgs>(args: Subset<T, ReportEvaluationAggregateArgs>): Prisma.PrismaPromise<GetReportEvaluationAggregateType<T>>

    /**
     * Group by ReportEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: ReportEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportEvaluation model
   */
  readonly fields: ReportEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluation<T extends EvaluationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationDefaultArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ReportEvaluation model
   */ 
  interface ReportEvaluationFieldRefs {
    readonly id: FieldRef<"ReportEvaluation", 'Int'>
    readonly reportEvalId: FieldRef<"ReportEvaluation", 'Int'>
    readonly evaluationId: FieldRef<"ReportEvaluation", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ReportEvaluation findUnique
   */
  export type ReportEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ReportEvaluation to fetch.
     */
    where: ReportEvaluationWhereUniqueInput
  }


  /**
   * ReportEvaluation findUniqueOrThrow
   */
  export type ReportEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ReportEvaluation to fetch.
     */
    where: ReportEvaluationWhereUniqueInput
  }


  /**
   * ReportEvaluation findFirst
   */
  export type ReportEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ReportEvaluation to fetch.
     */
    where?: ReportEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportEvaluations to fetch.
     */
    orderBy?: ReportEvaluationOrderByWithRelationInput | ReportEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportEvaluations.
     */
    cursor?: ReportEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportEvaluations.
     */
    distinct?: ReportEvaluationScalarFieldEnum | ReportEvaluationScalarFieldEnum[]
  }


  /**
   * ReportEvaluation findFirstOrThrow
   */
  export type ReportEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ReportEvaluation to fetch.
     */
    where?: ReportEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportEvaluations to fetch.
     */
    orderBy?: ReportEvaluationOrderByWithRelationInput | ReportEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportEvaluations.
     */
    cursor?: ReportEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportEvaluations.
     */
    distinct?: ReportEvaluationScalarFieldEnum | ReportEvaluationScalarFieldEnum[]
  }


  /**
   * ReportEvaluation findMany
   */
  export type ReportEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ReportEvaluations to fetch.
     */
    where?: ReportEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportEvaluations to fetch.
     */
    orderBy?: ReportEvaluationOrderByWithRelationInput | ReportEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportEvaluations.
     */
    cursor?: ReportEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportEvaluations.
     */
    skip?: number
    distinct?: ReportEvaluationScalarFieldEnum | ReportEvaluationScalarFieldEnum[]
  }


  /**
   * ReportEvaluation create
   */
  export type ReportEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportEvaluation.
     */
    data: XOR<ReportEvaluationCreateInput, ReportEvaluationUncheckedCreateInput>
  }


  /**
   * ReportEvaluation createMany
   */
  export type ReportEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportEvaluations.
     */
    data: ReportEvaluationCreateManyInput | ReportEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ReportEvaluation update
   */
  export type ReportEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportEvaluation.
     */
    data: XOR<ReportEvaluationUpdateInput, ReportEvaluationUncheckedUpdateInput>
    /**
     * Choose, which ReportEvaluation to update.
     */
    where: ReportEvaluationWhereUniqueInput
  }


  /**
   * ReportEvaluation updateMany
   */
  export type ReportEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportEvaluations.
     */
    data: XOR<ReportEvaluationUpdateManyMutationInput, ReportEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which ReportEvaluations to update
     */
    where?: ReportEvaluationWhereInput
  }


  /**
   * ReportEvaluation upsert
   */
  export type ReportEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportEvaluation to update in case it exists.
     */
    where: ReportEvaluationWhereUniqueInput
    /**
     * In case the ReportEvaluation found by the `where` argument doesn't exist, create a new ReportEvaluation with this data.
     */
    create: XOR<ReportEvaluationCreateInput, ReportEvaluationUncheckedCreateInput>
    /**
     * In case the ReportEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportEvaluationUpdateInput, ReportEvaluationUncheckedUpdateInput>
  }


  /**
   * ReportEvaluation delete
   */
  export type ReportEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
    /**
     * Filter which ReportEvaluation to delete.
     */
    where: ReportEvaluationWhereUniqueInput
  }


  /**
   * ReportEvaluation deleteMany
   */
  export type ReportEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportEvaluations to delete
     */
    where?: ReportEvaluationWhereInput
  }


  /**
   * ReportEvaluation without action
   */
  export type ReportEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportEvaluation
     */
    select?: ReportEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportEvaluationInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    password: 'password',
    email: 'email',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    userId: 'userId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    promotion: 'promotion',
    userId: 'userId',
    internshipId: 'internshipId',
    academicTutorId: 'academicTutorId',
    enterpriseTutorId: 'enterpriseTutorId'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const TutorScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type TutorScalarFieldEnum = (typeof TutorScalarFieldEnum)[keyof typeof TutorScalarFieldEnum]


  export const AcademicTutorScalarFieldEnum: {
    id: 'id',
    tutorId: 'tutorId'
  };

  export type AcademicTutorScalarFieldEnum = (typeof AcademicTutorScalarFieldEnum)[keyof typeof AcademicTutorScalarFieldEnum]


  export const EnterpriseTutorScalarFieldEnum: {
    id: 'id',
    tutorId: 'tutorId'
  };

  export type EnterpriseTutorScalarFieldEnum = (typeof EnterpriseTutorScalarFieldEnum)[keyof typeof EnterpriseTutorScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const InternshipScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    salary: 'salary',
    companyId: 'companyId',
    tutorId: 'tutorId'
  };

  export type InternshipScalarFieldEnum = (typeof InternshipScalarFieldEnum)[keyof typeof InternshipScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    filePath: 'filePath',
    fileType: 'fileType',
    fileSize: 'fileSize',
    documentType: 'documentType',
    internshipId: 'internshipId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const CdCScalarFieldEnum: {
    id: 'id',
    file: 'file',
    documentId: 'documentId'
  };

  export type CdCScalarFieldEnum = (typeof CdCScalarFieldEnum)[keyof typeof CdCScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    file: 'file',
    documentId: 'documentId'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const EvaluationScalarFieldEnum: {
    id: 'id',
    evaluation: 'evaluation',
    submissionDate: 'submissionDate',
    factor: 'factor',
    internshipId: 'internshipId',
    studentId: 'studentId'
  };

  export type EvaluationScalarFieldEnum = (typeof EvaluationScalarFieldEnum)[keyof typeof EvaluationScalarFieldEnum]


  export const StudentEvaluationScalarFieldEnum: {
    id: 'id',
    evaluationId: 'evaluationId'
  };

  export type StudentEvaluationScalarFieldEnum = (typeof StudentEvaluationScalarFieldEnum)[keyof typeof StudentEvaluationScalarFieldEnum]


  export const CompanyEvaluationScalarFieldEnum: {
    id: 'id',
    evaluationId: 'evaluationId'
  };

  export type CompanyEvaluationScalarFieldEnum = (typeof CompanyEvaluationScalarFieldEnum)[keyof typeof CompanyEvaluationScalarFieldEnum]


  export const SoutenanceScalarFieldEnum: {
    id: 'id',
    date: 'date',
    status: 'status'
  };

  export type SoutenanceScalarFieldEnum = (typeof SoutenanceScalarFieldEnum)[keyof typeof SoutenanceScalarFieldEnum]


  export const SoutenanceEvaluationScalarFieldEnum: {
    id: 'id',
    soutenanceId: 'soutenanceId'
  };

  export type SoutenanceEvaluationScalarFieldEnum = (typeof SoutenanceEvaluationScalarFieldEnum)[keyof typeof SoutenanceEvaluationScalarFieldEnum]


  export const ReportEvaluationScalarFieldEnum: {
    id: 'id',
    reportEvalId: 'reportEvalId',
    evaluationId: 'evaluationId'
  };

  export type ReportEvaluationScalarFieldEnum = (typeof ReportEvaluationScalarFieldEnum)[keyof typeof ReportEvaluationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    tutor?: XOR<TutorNullableRelationFilter, TutorWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    admin?: AdminOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    tutor?: TutorOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    tutor?: XOR<TutorNullableRelationFilter, TutorWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    adminId?: StringFilter<"Admin"> | string
    userId?: IntFilter<"Admin"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    adminId?: string
    userId?: number
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "adminId" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    adminId?: StringWithAggregatesFilter<"Admin"> | string
    userId?: IntWithAggregatesFilter<"Admin"> | number
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: IntFilter<"Student"> | number
    promotion?: StringFilter<"Student"> | string
    userId?: IntFilter<"Student"> | number
    internshipId?: IntNullableFilter<"Student"> | number | null
    academicTutorId?: IntNullableFilter<"Student"> | number | null
    enterpriseTutorId?: IntNullableFilter<"Student"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    internship?: XOR<InternshipNullableRelationFilter, InternshipWhereInput> | null
    evaluations?: EvaluationListRelationFilter
    academicTutor?: XOR<AcademicTutorNullableRelationFilter, AcademicTutorWhereInput> | null
    enterpriseTutor?: XOR<EnterpriseTutorNullableRelationFilter, EnterpriseTutorWhereInput> | null
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    promotion?: SortOrder
    userId?: SortOrder
    internshipId?: SortOrderInput | SortOrder
    academicTutorId?: SortOrderInput | SortOrder
    enterpriseTutorId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    internship?: InternshipOrderByWithRelationInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    academicTutor?: AcademicTutorOrderByWithRelationInput
    enterpriseTutor?: EnterpriseTutorOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    internshipId?: number
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    promotion?: StringFilter<"Student"> | string
    academicTutorId?: IntNullableFilter<"Student"> | number | null
    enterpriseTutorId?: IntNullableFilter<"Student"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    internship?: XOR<InternshipNullableRelationFilter, InternshipWhereInput> | null
    evaluations?: EvaluationListRelationFilter
    academicTutor?: XOR<AcademicTutorNullableRelationFilter, AcademicTutorWhereInput> | null
    enterpriseTutor?: XOR<EnterpriseTutorNullableRelationFilter, EnterpriseTutorWhereInput> | null
  }, "id" | "userId" | "internshipId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    promotion?: SortOrder
    userId?: SortOrder
    internshipId?: SortOrderInput | SortOrder
    academicTutorId?: SortOrderInput | SortOrder
    enterpriseTutorId?: SortOrderInput | SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Student"> | number
    promotion?: StringWithAggregatesFilter<"Student"> | string
    userId?: IntWithAggregatesFilter<"Student"> | number
    internshipId?: IntNullableWithAggregatesFilter<"Student"> | number | null
    academicTutorId?: IntNullableWithAggregatesFilter<"Student"> | number | null
    enterpriseTutorId?: IntNullableWithAggregatesFilter<"Student"> | number | null
  }

  export type TutorWhereInput = {
    AND?: TutorWhereInput | TutorWhereInput[]
    OR?: TutorWhereInput[]
    NOT?: TutorWhereInput | TutorWhereInput[]
    id?: IntFilter<"Tutor"> | number
    userId?: IntFilter<"Tutor"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    academicTutors?: AcademicTutorListRelationFilter
    enterpriseTutors?: EnterpriseTutorListRelationFilter
  }

  export type TutorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    academicTutors?: AcademicTutorOrderByRelationAggregateInput
    enterpriseTutors?: EnterpriseTutorOrderByRelationAggregateInput
  }

  export type TutorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: TutorWhereInput | TutorWhereInput[]
    OR?: TutorWhereInput[]
    NOT?: TutorWhereInput | TutorWhereInput[]
    user?: XOR<UserRelationFilter, UserWhereInput>
    academicTutors?: AcademicTutorListRelationFilter
    enterpriseTutors?: EnterpriseTutorListRelationFilter
  }, "id" | "userId">

  export type TutorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: TutorCountOrderByAggregateInput
    _avg?: TutorAvgOrderByAggregateInput
    _max?: TutorMaxOrderByAggregateInput
    _min?: TutorMinOrderByAggregateInput
    _sum?: TutorSumOrderByAggregateInput
  }

  export type TutorScalarWhereWithAggregatesInput = {
    AND?: TutorScalarWhereWithAggregatesInput | TutorScalarWhereWithAggregatesInput[]
    OR?: TutorScalarWhereWithAggregatesInput[]
    NOT?: TutorScalarWhereWithAggregatesInput | TutorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tutor"> | number
    userId?: IntWithAggregatesFilter<"Tutor"> | number
  }

  export type AcademicTutorWhereInput = {
    AND?: AcademicTutorWhereInput | AcademicTutorWhereInput[]
    OR?: AcademicTutorWhereInput[]
    NOT?: AcademicTutorWhereInput | AcademicTutorWhereInput[]
    id?: IntFilter<"AcademicTutor"> | number
    tutorId?: IntFilter<"AcademicTutor"> | number
    tutor?: XOR<TutorRelationFilter, TutorWhereInput>
    students?: StudentListRelationFilter
  }

  export type AcademicTutorOrderByWithRelationInput = {
    id?: SortOrder
    tutorId?: SortOrder
    tutor?: TutorOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
  }

  export type AcademicTutorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AcademicTutorWhereInput | AcademicTutorWhereInput[]
    OR?: AcademicTutorWhereInput[]
    NOT?: AcademicTutorWhereInput | AcademicTutorWhereInput[]
    tutorId?: IntFilter<"AcademicTutor"> | number
    tutor?: XOR<TutorRelationFilter, TutorWhereInput>
    students?: StudentListRelationFilter
  }, "id">

  export type AcademicTutorOrderByWithAggregationInput = {
    id?: SortOrder
    tutorId?: SortOrder
    _count?: AcademicTutorCountOrderByAggregateInput
    _avg?: AcademicTutorAvgOrderByAggregateInput
    _max?: AcademicTutorMaxOrderByAggregateInput
    _min?: AcademicTutorMinOrderByAggregateInput
    _sum?: AcademicTutorSumOrderByAggregateInput
  }

  export type AcademicTutorScalarWhereWithAggregatesInput = {
    AND?: AcademicTutorScalarWhereWithAggregatesInput | AcademicTutorScalarWhereWithAggregatesInput[]
    OR?: AcademicTutorScalarWhereWithAggregatesInput[]
    NOT?: AcademicTutorScalarWhereWithAggregatesInput | AcademicTutorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AcademicTutor"> | number
    tutorId?: IntWithAggregatesFilter<"AcademicTutor"> | number
  }

  export type EnterpriseTutorWhereInput = {
    AND?: EnterpriseTutorWhereInput | EnterpriseTutorWhereInput[]
    OR?: EnterpriseTutorWhereInput[]
    NOT?: EnterpriseTutorWhereInput | EnterpriseTutorWhereInput[]
    id?: IntFilter<"EnterpriseTutor"> | number
    tutorId?: IntFilter<"EnterpriseTutor"> | number
    tutor?: XOR<TutorRelationFilter, TutorWhereInput>
    students?: StudentListRelationFilter
  }

  export type EnterpriseTutorOrderByWithRelationInput = {
    id?: SortOrder
    tutorId?: SortOrder
    tutor?: TutorOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
  }

  export type EnterpriseTutorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EnterpriseTutorWhereInput | EnterpriseTutorWhereInput[]
    OR?: EnterpriseTutorWhereInput[]
    NOT?: EnterpriseTutorWhereInput | EnterpriseTutorWhereInput[]
    tutorId?: IntFilter<"EnterpriseTutor"> | number
    tutor?: XOR<TutorRelationFilter, TutorWhereInput>
    students?: StudentListRelationFilter
  }, "id">

  export type EnterpriseTutorOrderByWithAggregationInput = {
    id?: SortOrder
    tutorId?: SortOrder
    _count?: EnterpriseTutorCountOrderByAggregateInput
    _avg?: EnterpriseTutorAvgOrderByAggregateInput
    _max?: EnterpriseTutorMaxOrderByAggregateInput
    _min?: EnterpriseTutorMinOrderByAggregateInput
    _sum?: EnterpriseTutorSumOrderByAggregateInput
  }

  export type EnterpriseTutorScalarWhereWithAggregatesInput = {
    AND?: EnterpriseTutorScalarWhereWithAggregatesInput | EnterpriseTutorScalarWhereWithAggregatesInput[]
    OR?: EnterpriseTutorScalarWhereWithAggregatesInput[]
    NOT?: EnterpriseTutorScalarWhereWithAggregatesInput | EnterpriseTutorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EnterpriseTutor"> | number
    tutorId?: IntWithAggregatesFilter<"EnterpriseTutor"> | number
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    name?: StringFilter<"Company"> | string
    internships?: InternshipListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    internships?: InternshipOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    internships?: InternshipListRelationFilter
  }, "id" | "name">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    name?: StringWithAggregatesFilter<"Company"> | string
  }

  export type InternshipWhereInput = {
    AND?: InternshipWhereInput | InternshipWhereInput[]
    OR?: InternshipWhereInput[]
    NOT?: InternshipWhereInput | InternshipWhereInput[]
    id?: IntFilter<"Internship"> | number
    title?: StringFilter<"Internship"> | string
    description?: StringFilter<"Internship"> | string
    startDate?: DateTimeFilter<"Internship"> | Date | string
    endDate?: DateTimeFilter<"Internship"> | Date | string
    salary?: IntFilter<"Internship"> | number
    companyId?: IntFilter<"Internship"> | number
    tutorId?: IntFilter<"Internship"> | number
    evaluations?: EvaluationListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    documents?: DocumentListRelationFilter
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }

  export type InternshipOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    companyId?: SortOrder
    tutorId?: SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    student?: StudentOrderByWithRelationInput
  }

  export type InternshipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InternshipWhereInput | InternshipWhereInput[]
    OR?: InternshipWhereInput[]
    NOT?: InternshipWhereInput | InternshipWhereInput[]
    title?: StringFilter<"Internship"> | string
    description?: StringFilter<"Internship"> | string
    startDate?: DateTimeFilter<"Internship"> | Date | string
    endDate?: DateTimeFilter<"Internship"> | Date | string
    salary?: IntFilter<"Internship"> | number
    companyId?: IntFilter<"Internship"> | number
    tutorId?: IntFilter<"Internship"> | number
    evaluations?: EvaluationListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    documents?: DocumentListRelationFilter
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }, "id">

  export type InternshipOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    companyId?: SortOrder
    tutorId?: SortOrder
    _count?: InternshipCountOrderByAggregateInput
    _avg?: InternshipAvgOrderByAggregateInput
    _max?: InternshipMaxOrderByAggregateInput
    _min?: InternshipMinOrderByAggregateInput
    _sum?: InternshipSumOrderByAggregateInput
  }

  export type InternshipScalarWhereWithAggregatesInput = {
    AND?: InternshipScalarWhereWithAggregatesInput | InternshipScalarWhereWithAggregatesInput[]
    OR?: InternshipScalarWhereWithAggregatesInput[]
    NOT?: InternshipScalarWhereWithAggregatesInput | InternshipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Internship"> | number
    title?: StringWithAggregatesFilter<"Internship"> | string
    description?: StringWithAggregatesFilter<"Internship"> | string
    startDate?: DateTimeWithAggregatesFilter<"Internship"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Internship"> | Date | string
    salary?: IntWithAggregatesFilter<"Internship"> | number
    companyId?: IntWithAggregatesFilter<"Internship"> | number
    tutorId?: IntWithAggregatesFilter<"Internship"> | number
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    documentType?: StringFilter<"Document"> | string
    internshipId?: IntNullableFilter<"Document"> | number | null
    CdC?: CdCListRelationFilter
    Report?: ReportListRelationFilter
    Internship?: XOR<InternshipNullableRelationFilter, InternshipWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    documentType?: SortOrder
    internshipId?: SortOrderInput | SortOrder
    CdC?: CdCOrderByRelationAggregateInput
    Report?: ReportOrderByRelationAggregateInput
    Internship?: InternshipOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    documentType?: StringFilter<"Document"> | string
    internshipId?: IntNullableFilter<"Document"> | number | null
    CdC?: CdCListRelationFilter
    Report?: ReportListRelationFilter
    Internship?: XOR<InternshipNullableRelationFilter, InternshipWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    documentType?: SortOrder
    internshipId?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    fileName?: StringWithAggregatesFilter<"Document"> | string
    filePath?: StringWithAggregatesFilter<"Document"> | string
    fileType?: StringWithAggregatesFilter<"Document"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Document"> | number | null
    documentType?: StringWithAggregatesFilter<"Document"> | string
    internshipId?: IntNullableWithAggregatesFilter<"Document"> | number | null
  }

  export type CdCWhereInput = {
    AND?: CdCWhereInput | CdCWhereInput[]
    OR?: CdCWhereInput[]
    NOT?: CdCWhereInput | CdCWhereInput[]
    id?: IntFilter<"CdC"> | number
    file?: StringFilter<"CdC"> | string
    documentId?: StringFilter<"CdC"> | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }

  export type CdCOrderByWithRelationInput = {
    id?: SortOrder
    file?: SortOrder
    documentId?: SortOrder
    document?: DocumentOrderByWithRelationInput
  }

  export type CdCWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CdCWhereInput | CdCWhereInput[]
    OR?: CdCWhereInput[]
    NOT?: CdCWhereInput | CdCWhereInput[]
    file?: StringFilter<"CdC"> | string
    documentId?: StringFilter<"CdC"> | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }, "id">

  export type CdCOrderByWithAggregationInput = {
    id?: SortOrder
    file?: SortOrder
    documentId?: SortOrder
    _count?: CdCCountOrderByAggregateInput
    _avg?: CdCAvgOrderByAggregateInput
    _max?: CdCMaxOrderByAggregateInput
    _min?: CdCMinOrderByAggregateInput
    _sum?: CdCSumOrderByAggregateInput
  }

  export type CdCScalarWhereWithAggregatesInput = {
    AND?: CdCScalarWhereWithAggregatesInput | CdCScalarWhereWithAggregatesInput[]
    OR?: CdCScalarWhereWithAggregatesInput[]
    NOT?: CdCScalarWhereWithAggregatesInput | CdCScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CdC"> | number
    file?: StringWithAggregatesFilter<"CdC"> | string
    documentId?: StringWithAggregatesFilter<"CdC"> | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: IntFilter<"Report"> | number
    file?: StringFilter<"Report"> | string
    documentId?: StringFilter<"Report"> | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    file?: SortOrder
    documentId?: SortOrder
    document?: DocumentOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    file?: StringFilter<"Report"> | string
    documentId?: StringFilter<"Report"> | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    file?: SortOrder
    documentId?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Report"> | number
    file?: StringWithAggregatesFilter<"Report"> | string
    documentId?: StringWithAggregatesFilter<"Report"> | string
  }

  export type EvaluationWhereInput = {
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    id?: IntFilter<"Evaluation"> | number
    evaluation?: StringFilter<"Evaluation"> | string
    submissionDate?: DateTimeFilter<"Evaluation"> | Date | string
    factor?: IntFilter<"Evaluation"> | number
    internshipId?: IntFilter<"Evaluation"> | number
    studentId?: IntNullableFilter<"Evaluation"> | number | null
    ReportEvaluation?: ReportEvaluationListRelationFilter
    studentEvals?: StudentEvaluationListRelationFilter
    companyEvals?: CompanyEvaluationListRelationFilter
    Student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    Internship?: XOR<InternshipRelationFilter, InternshipWhereInput>
  }

  export type EvaluationOrderByWithRelationInput = {
    id?: SortOrder
    evaluation?: SortOrder
    submissionDate?: SortOrder
    factor?: SortOrder
    internshipId?: SortOrder
    studentId?: SortOrderInput | SortOrder
    ReportEvaluation?: ReportEvaluationOrderByRelationAggregateInput
    studentEvals?: StudentEvaluationOrderByRelationAggregateInput
    companyEvals?: CompanyEvaluationOrderByRelationAggregateInput
    Student?: StudentOrderByWithRelationInput
    Internship?: InternshipOrderByWithRelationInput
  }

  export type EvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    evaluation?: StringFilter<"Evaluation"> | string
    submissionDate?: DateTimeFilter<"Evaluation"> | Date | string
    factor?: IntFilter<"Evaluation"> | number
    internshipId?: IntFilter<"Evaluation"> | number
    studentId?: IntNullableFilter<"Evaluation"> | number | null
    ReportEvaluation?: ReportEvaluationListRelationFilter
    studentEvals?: StudentEvaluationListRelationFilter
    companyEvals?: CompanyEvaluationListRelationFilter
    Student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    Internship?: XOR<InternshipRelationFilter, InternshipWhereInput>
  }, "id">

  export type EvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    evaluation?: SortOrder
    submissionDate?: SortOrder
    factor?: SortOrder
    internshipId?: SortOrder
    studentId?: SortOrderInput | SortOrder
    _count?: EvaluationCountOrderByAggregateInput
    _avg?: EvaluationAvgOrderByAggregateInput
    _max?: EvaluationMaxOrderByAggregateInput
    _min?: EvaluationMinOrderByAggregateInput
    _sum?: EvaluationSumOrderByAggregateInput
  }

  export type EvaluationScalarWhereWithAggregatesInput = {
    AND?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    OR?: EvaluationScalarWhereWithAggregatesInput[]
    NOT?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Evaluation"> | number
    evaluation?: StringWithAggregatesFilter<"Evaluation"> | string
    submissionDate?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
    factor?: IntWithAggregatesFilter<"Evaluation"> | number
    internshipId?: IntWithAggregatesFilter<"Evaluation"> | number
    studentId?: IntNullableWithAggregatesFilter<"Evaluation"> | number | null
  }

  export type StudentEvaluationWhereInput = {
    AND?: StudentEvaluationWhereInput | StudentEvaluationWhereInput[]
    OR?: StudentEvaluationWhereInput[]
    NOT?: StudentEvaluationWhereInput | StudentEvaluationWhereInput[]
    id?: IntFilter<"StudentEvaluation"> | number
    evaluationId?: IntFilter<"StudentEvaluation"> | number
    evaluation?: XOR<EvaluationRelationFilter, EvaluationWhereInput>
  }

  export type StudentEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    evaluationId?: SortOrder
    evaluation?: EvaluationOrderByWithRelationInput
  }

  export type StudentEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentEvaluationWhereInput | StudentEvaluationWhereInput[]
    OR?: StudentEvaluationWhereInput[]
    NOT?: StudentEvaluationWhereInput | StudentEvaluationWhereInput[]
    evaluationId?: IntFilter<"StudentEvaluation"> | number
    evaluation?: XOR<EvaluationRelationFilter, EvaluationWhereInput>
  }, "id">

  export type StudentEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    evaluationId?: SortOrder
    _count?: StudentEvaluationCountOrderByAggregateInput
    _avg?: StudentEvaluationAvgOrderByAggregateInput
    _max?: StudentEvaluationMaxOrderByAggregateInput
    _min?: StudentEvaluationMinOrderByAggregateInput
    _sum?: StudentEvaluationSumOrderByAggregateInput
  }

  export type StudentEvaluationScalarWhereWithAggregatesInput = {
    AND?: StudentEvaluationScalarWhereWithAggregatesInput | StudentEvaluationScalarWhereWithAggregatesInput[]
    OR?: StudentEvaluationScalarWhereWithAggregatesInput[]
    NOT?: StudentEvaluationScalarWhereWithAggregatesInput | StudentEvaluationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentEvaluation"> | number
    evaluationId?: IntWithAggregatesFilter<"StudentEvaluation"> | number
  }

  export type CompanyEvaluationWhereInput = {
    AND?: CompanyEvaluationWhereInput | CompanyEvaluationWhereInput[]
    OR?: CompanyEvaluationWhereInput[]
    NOT?: CompanyEvaluationWhereInput | CompanyEvaluationWhereInput[]
    id?: IntFilter<"CompanyEvaluation"> | number
    evaluationId?: IntFilter<"CompanyEvaluation"> | number
    evaluation?: XOR<EvaluationRelationFilter, EvaluationWhereInput>
  }

  export type CompanyEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    evaluationId?: SortOrder
    evaluation?: EvaluationOrderByWithRelationInput
  }

  export type CompanyEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyEvaluationWhereInput | CompanyEvaluationWhereInput[]
    OR?: CompanyEvaluationWhereInput[]
    NOT?: CompanyEvaluationWhereInput | CompanyEvaluationWhereInput[]
    evaluationId?: IntFilter<"CompanyEvaluation"> | number
    evaluation?: XOR<EvaluationRelationFilter, EvaluationWhereInput>
  }, "id">

  export type CompanyEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    evaluationId?: SortOrder
    _count?: CompanyEvaluationCountOrderByAggregateInput
    _avg?: CompanyEvaluationAvgOrderByAggregateInput
    _max?: CompanyEvaluationMaxOrderByAggregateInput
    _min?: CompanyEvaluationMinOrderByAggregateInput
    _sum?: CompanyEvaluationSumOrderByAggregateInput
  }

  export type CompanyEvaluationScalarWhereWithAggregatesInput = {
    AND?: CompanyEvaluationScalarWhereWithAggregatesInput | CompanyEvaluationScalarWhereWithAggregatesInput[]
    OR?: CompanyEvaluationScalarWhereWithAggregatesInput[]
    NOT?: CompanyEvaluationScalarWhereWithAggregatesInput | CompanyEvaluationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyEvaluation"> | number
    evaluationId?: IntWithAggregatesFilter<"CompanyEvaluation"> | number
  }

  export type SoutenanceWhereInput = {
    AND?: SoutenanceWhereInput | SoutenanceWhereInput[]
    OR?: SoutenanceWhereInput[]
    NOT?: SoutenanceWhereInput | SoutenanceWhereInput[]
    id?: IntFilter<"Soutenance"> | number
    date?: DateTimeFilter<"Soutenance"> | Date | string
    status?: StringFilter<"Soutenance"> | string
    evaluations?: SoutenanceEvaluationListRelationFilter
  }

  export type SoutenanceOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    evaluations?: SoutenanceEvaluationOrderByRelationAggregateInput
  }

  export type SoutenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SoutenanceWhereInput | SoutenanceWhereInput[]
    OR?: SoutenanceWhereInput[]
    NOT?: SoutenanceWhereInput | SoutenanceWhereInput[]
    date?: DateTimeFilter<"Soutenance"> | Date | string
    status?: StringFilter<"Soutenance"> | string
    evaluations?: SoutenanceEvaluationListRelationFilter
  }, "id">

  export type SoutenanceOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    _count?: SoutenanceCountOrderByAggregateInput
    _avg?: SoutenanceAvgOrderByAggregateInput
    _max?: SoutenanceMaxOrderByAggregateInput
    _min?: SoutenanceMinOrderByAggregateInput
    _sum?: SoutenanceSumOrderByAggregateInput
  }

  export type SoutenanceScalarWhereWithAggregatesInput = {
    AND?: SoutenanceScalarWhereWithAggregatesInput | SoutenanceScalarWhereWithAggregatesInput[]
    OR?: SoutenanceScalarWhereWithAggregatesInput[]
    NOT?: SoutenanceScalarWhereWithAggregatesInput | SoutenanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Soutenance"> | number
    date?: DateTimeWithAggregatesFilter<"Soutenance"> | Date | string
    status?: StringWithAggregatesFilter<"Soutenance"> | string
  }

  export type SoutenanceEvaluationWhereInput = {
    AND?: SoutenanceEvaluationWhereInput | SoutenanceEvaluationWhereInput[]
    OR?: SoutenanceEvaluationWhereInput[]
    NOT?: SoutenanceEvaluationWhereInput | SoutenanceEvaluationWhereInput[]
    id?: IntFilter<"SoutenanceEvaluation"> | number
    soutenanceId?: IntFilter<"SoutenanceEvaluation"> | number
    soutenance?: XOR<SoutenanceRelationFilter, SoutenanceWhereInput>
  }

  export type SoutenanceEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    soutenanceId?: SortOrder
    soutenance?: SoutenanceOrderByWithRelationInput
  }

  export type SoutenanceEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SoutenanceEvaluationWhereInput | SoutenanceEvaluationWhereInput[]
    OR?: SoutenanceEvaluationWhereInput[]
    NOT?: SoutenanceEvaluationWhereInput | SoutenanceEvaluationWhereInput[]
    soutenanceId?: IntFilter<"SoutenanceEvaluation"> | number
    soutenance?: XOR<SoutenanceRelationFilter, SoutenanceWhereInput>
  }, "id">

  export type SoutenanceEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    soutenanceId?: SortOrder
    _count?: SoutenanceEvaluationCountOrderByAggregateInput
    _avg?: SoutenanceEvaluationAvgOrderByAggregateInput
    _max?: SoutenanceEvaluationMaxOrderByAggregateInput
    _min?: SoutenanceEvaluationMinOrderByAggregateInput
    _sum?: SoutenanceEvaluationSumOrderByAggregateInput
  }

  export type SoutenanceEvaluationScalarWhereWithAggregatesInput = {
    AND?: SoutenanceEvaluationScalarWhereWithAggregatesInput | SoutenanceEvaluationScalarWhereWithAggregatesInput[]
    OR?: SoutenanceEvaluationScalarWhereWithAggregatesInput[]
    NOT?: SoutenanceEvaluationScalarWhereWithAggregatesInput | SoutenanceEvaluationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SoutenanceEvaluation"> | number
    soutenanceId?: IntWithAggregatesFilter<"SoutenanceEvaluation"> | number
  }

  export type ReportEvaluationWhereInput = {
    AND?: ReportEvaluationWhereInput | ReportEvaluationWhereInput[]
    OR?: ReportEvaluationWhereInput[]
    NOT?: ReportEvaluationWhereInput | ReportEvaluationWhereInput[]
    id?: IntFilter<"ReportEvaluation"> | number
    reportEvalId?: IntFilter<"ReportEvaluation"> | number
    evaluationId?: IntFilter<"ReportEvaluation"> | number
    evaluation?: XOR<EvaluationRelationFilter, EvaluationWhereInput>
  }

  export type ReportEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    reportEvalId?: SortOrder
    evaluationId?: SortOrder
    evaluation?: EvaluationOrderByWithRelationInput
  }

  export type ReportEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportEvaluationWhereInput | ReportEvaluationWhereInput[]
    OR?: ReportEvaluationWhereInput[]
    NOT?: ReportEvaluationWhereInput | ReportEvaluationWhereInput[]
    reportEvalId?: IntFilter<"ReportEvaluation"> | number
    evaluationId?: IntFilter<"ReportEvaluation"> | number
    evaluation?: XOR<EvaluationRelationFilter, EvaluationWhereInput>
  }, "id">

  export type ReportEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    reportEvalId?: SortOrder
    evaluationId?: SortOrder
    _count?: ReportEvaluationCountOrderByAggregateInput
    _avg?: ReportEvaluationAvgOrderByAggregateInput
    _max?: ReportEvaluationMaxOrderByAggregateInput
    _min?: ReportEvaluationMinOrderByAggregateInput
    _sum?: ReportEvaluationSumOrderByAggregateInput
  }

  export type ReportEvaluationScalarWhereWithAggregatesInput = {
    AND?: ReportEvaluationScalarWhereWithAggregatesInput | ReportEvaluationScalarWhereWithAggregatesInput[]
    OR?: ReportEvaluationScalarWhereWithAggregatesInput[]
    NOT?: ReportEvaluationScalarWhereWithAggregatesInput | ReportEvaluationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReportEvaluation"> | number
    reportEvalId?: IntWithAggregatesFilter<"ReportEvaluation"> | number
    evaluationId?: IntWithAggregatesFilter<"ReportEvaluation"> | number
  }

  export type UserCreateInput = {
    firstName: string
    lastName: string
    password: string
    email: string
    role: string
    admin?: AdminCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    tutor?: TutorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    password: string
    email: string
    role: string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    tutor?: TutorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    tutor?: TutorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    tutor?: TutorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    password: string
    email: string
    role: string
  }

  export type UserUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateInput = {
    adminId: string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    adminId: string
    userId: number
  }

  export type AdminUpdateInput = {
    adminId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AdminCreateManyInput = {
    id?: number
    adminId: string
    userId: number
  }

  export type AdminUpdateManyMutationInput = {
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentCreateInput = {
    promotion: string
    user: UserCreateNestedOneWithoutStudentInput
    internship?: InternshipCreateNestedOneWithoutStudentInput
    evaluations?: EvaluationCreateNestedManyWithoutStudentInput
    academicTutor?: AcademicTutorCreateNestedOneWithoutStudentsInput
    enterpriseTutor?: EnterpriseTutorCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateInput = {
    id?: number
    promotion: string
    userId: number
    internshipId?: number | null
    academicTutorId?: number | null
    enterpriseTutorId?: number | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    promotion?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    internship?: InternshipUpdateOneWithoutStudentNestedInput
    evaluations?: EvaluationUpdateManyWithoutStudentNestedInput
    academicTutor?: AcademicTutorUpdateOneWithoutStudentsNestedInput
    enterpriseTutor?: EnterpriseTutorUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotion?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    academicTutorId?: NullableIntFieldUpdateOperationsInput | number | null
    enterpriseTutorId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: number
    promotion: string
    userId: number
    internshipId?: number | null
    academicTutorId?: number | null
    enterpriseTutorId?: number | null
  }

  export type StudentUpdateManyMutationInput = {
    promotion?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotion?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    academicTutorId?: NullableIntFieldUpdateOperationsInput | number | null
    enterpriseTutorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TutorCreateInput = {
    user: UserCreateNestedOneWithoutTutorInput
    academicTutors?: AcademicTutorCreateNestedManyWithoutTutorInput
    enterpriseTutors?: EnterpriseTutorCreateNestedManyWithoutTutorInput
  }

  export type TutorUncheckedCreateInput = {
    id?: number
    userId: number
    academicTutors?: AcademicTutorUncheckedCreateNestedManyWithoutTutorInput
    enterpriseTutors?: EnterpriseTutorUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutorUpdateInput = {
    user?: UserUpdateOneRequiredWithoutTutorNestedInput
    academicTutors?: AcademicTutorUpdateManyWithoutTutorNestedInput
    enterpriseTutors?: EnterpriseTutorUpdateManyWithoutTutorNestedInput
  }

  export type TutorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    academicTutors?: AcademicTutorUncheckedUpdateManyWithoutTutorNestedInput
    enterpriseTutors?: EnterpriseTutorUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type TutorCreateManyInput = {
    id?: number
    userId: number
  }

  export type TutorUpdateManyMutationInput = {

  }

  export type TutorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AcademicTutorCreateInput = {
    tutor: TutorCreateNestedOneWithoutAcademicTutorsInput
    students?: StudentCreateNestedManyWithoutAcademicTutorInput
  }

  export type AcademicTutorUncheckedCreateInput = {
    id?: number
    tutorId: number
    students?: StudentUncheckedCreateNestedManyWithoutAcademicTutorInput
  }

  export type AcademicTutorUpdateInput = {
    tutor?: TutorUpdateOneRequiredWithoutAcademicTutorsNestedInput
    students?: StudentUpdateManyWithoutAcademicTutorNestedInput
  }

  export type AcademicTutorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    students?: StudentUncheckedUpdateManyWithoutAcademicTutorNestedInput
  }

  export type AcademicTutorCreateManyInput = {
    id?: number
    tutorId: number
  }

  export type AcademicTutorUpdateManyMutationInput = {

  }

  export type AcademicTutorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
  }

  export type EnterpriseTutorCreateInput = {
    tutor: TutorCreateNestedOneWithoutEnterpriseTutorsInput
    students?: StudentCreateNestedManyWithoutEnterpriseTutorInput
  }

  export type EnterpriseTutorUncheckedCreateInput = {
    id?: number
    tutorId: number
    students?: StudentUncheckedCreateNestedManyWithoutEnterpriseTutorInput
  }

  export type EnterpriseTutorUpdateInput = {
    tutor?: TutorUpdateOneRequiredWithoutEnterpriseTutorsNestedInput
    students?: StudentUpdateManyWithoutEnterpriseTutorNestedInput
  }

  export type EnterpriseTutorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    students?: StudentUncheckedUpdateManyWithoutEnterpriseTutorNestedInput
  }

  export type EnterpriseTutorCreateManyInput = {
    id?: number
    tutorId: number
  }

  export type EnterpriseTutorUpdateManyMutationInput = {

  }

  export type EnterpriseTutorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyCreateInput = {
    name: string
    internships?: InternshipCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    name: string
    internships?: InternshipUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    internships?: InternshipUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    internships?: InternshipUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    name: string
  }

  export type CompanyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InternshipCreateInput = {
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    tutorId: number
    evaluations?: EvaluationCreateNestedManyWithoutInternshipInput
    company: CompanyCreateNestedOneWithoutInternshipsInput
    documents?: DocumentCreateNestedManyWithoutInternshipInput
    student?: StudentCreateNestedOneWithoutInternshipInput
  }

  export type InternshipUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    companyId: number
    tutorId: number
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutInternshipInput
    documents?: DocumentUncheckedCreateNestedManyWithoutInternshipInput
    student?: StudentUncheckedCreateNestedOneWithoutInternshipInput
  }

  export type InternshipUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    evaluations?: EvaluationUpdateManyWithoutInternshipNestedInput
    company?: CompanyUpdateOneRequiredWithoutInternshipsNestedInput
    documents?: DocumentUpdateManyWithoutInternshipNestedInput
    student?: StudentUpdateOneWithoutInternshipNestedInput
  }

  export type InternshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    evaluations?: EvaluationUncheckedUpdateManyWithoutInternshipNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutInternshipNestedInput
    student?: StudentUncheckedUpdateOneWithoutInternshipNestedInput
  }

  export type InternshipCreateManyInput = {
    id?: number
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    companyId: number
    tutorId: number
  }

  export type InternshipUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
  }

  export type InternshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
  }

  export type DocumentCreateInput = {
    id?: string
    fileName?: string
    filePath?: string
    fileType?: string
    fileSize?: number | null
    documentType?: string
    CdC?: CdCCreateNestedManyWithoutDocumentInput
    Report?: ReportCreateNestedManyWithoutDocumentInput
    Internship?: InternshipCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    fileName?: string
    filePath?: string
    fileType?: string
    fileSize?: number | null
    documentType?: string
    internshipId?: number | null
    CdC?: CdCUncheckedCreateNestedManyWithoutDocumentInput
    Report?: ReportUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
    CdC?: CdCUpdateManyWithoutDocumentNestedInput
    Report?: ReportUpdateManyWithoutDocumentNestedInput
    Internship?: InternshipUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    CdC?: CdCUncheckedUpdateManyWithoutDocumentNestedInput
    Report?: ReportUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    fileName?: string
    filePath?: string
    fileType?: string
    fileSize?: number | null
    documentType?: string
    internshipId?: number | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CdCCreateInput = {
    file: string
    document: DocumentCreateNestedOneWithoutCdCInput
  }

  export type CdCUncheckedCreateInput = {
    id?: number
    file: string
    documentId: string
  }

  export type CdCUpdateInput = {
    file?: StringFieldUpdateOperationsInput | string
    document?: DocumentUpdateOneRequiredWithoutCdCNestedInput
  }

  export type CdCUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
  }

  export type CdCCreateManyInput = {
    id?: number
    file: string
    documentId: string
  }

  export type CdCUpdateManyMutationInput = {
    file?: StringFieldUpdateOperationsInput | string
  }

  export type CdCUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateInput = {
    file: string
    document: DocumentCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    file: string
    documentId: string
  }

  export type ReportUpdateInput = {
    file?: StringFieldUpdateOperationsInput | string
    document?: DocumentUpdateOneRequiredWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateManyInput = {
    id?: number
    file: string
    documentId: string
  }

  export type ReportUpdateManyMutationInput = {
    file?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
  }

  export type EvaluationCreateInput = {
    evaluation: string
    submissionDate: Date | string
    factor: number
    ReportEvaluation?: ReportEvaluationCreateNestedManyWithoutEvaluationInput
    studentEvals?: StudentEvaluationCreateNestedManyWithoutEvaluationInput
    companyEvals?: CompanyEvaluationCreateNestedManyWithoutEvaluationInput
    Student?: StudentCreateNestedOneWithoutEvaluationsInput
    Internship: InternshipCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateInput = {
    id?: number
    evaluation: string
    submissionDate: Date | string
    factor: number
    internshipId: number
    studentId?: number | null
    ReportEvaluation?: ReportEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
    studentEvals?: StudentEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
    companyEvals?: CompanyEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUpdateInput = {
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    ReportEvaluation?: ReportEvaluationUpdateManyWithoutEvaluationNestedInput
    studentEvals?: StudentEvaluationUpdateManyWithoutEvaluationNestedInput
    companyEvals?: CompanyEvaluationUpdateManyWithoutEvaluationNestedInput
    Student?: StudentUpdateOneWithoutEvaluationsNestedInput
    Internship?: InternshipUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    internshipId?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    ReportEvaluation?: ReportEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
    studentEvals?: StudentEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
    companyEvals?: CompanyEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationCreateManyInput = {
    id?: number
    evaluation: string
    submissionDate: Date | string
    factor: number
    internshipId: number
    studentId?: number | null
  }

  export type EvaluationUpdateManyMutationInput = {
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    internshipId?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentEvaluationCreateInput = {
    evaluation: EvaluationCreateNestedOneWithoutStudentEvalsInput
  }

  export type StudentEvaluationUncheckedCreateInput = {
    id?: number
    evaluationId: number
  }

  export type StudentEvaluationUpdateInput = {
    evaluation?: EvaluationUpdateOneRequiredWithoutStudentEvalsNestedInput
  }

  export type StudentEvaluationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluationId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentEvaluationCreateManyInput = {
    id?: number
    evaluationId: number
  }

  export type StudentEvaluationUpdateManyMutationInput = {

  }

  export type StudentEvaluationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluationId?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyEvaluationCreateInput = {
    evaluation: EvaluationCreateNestedOneWithoutCompanyEvalsInput
  }

  export type CompanyEvaluationUncheckedCreateInput = {
    id?: number
    evaluationId: number
  }

  export type CompanyEvaluationUpdateInput = {
    evaluation?: EvaluationUpdateOneRequiredWithoutCompanyEvalsNestedInput
  }

  export type CompanyEvaluationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluationId?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyEvaluationCreateManyInput = {
    id?: number
    evaluationId: number
  }

  export type CompanyEvaluationUpdateManyMutationInput = {

  }

  export type CompanyEvaluationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluationId?: IntFieldUpdateOperationsInput | number
  }

  export type SoutenanceCreateInput = {
    date: Date | string
    status: string
    evaluations?: SoutenanceEvaluationCreateNestedManyWithoutSoutenanceInput
  }

  export type SoutenanceUncheckedCreateInput = {
    id?: number
    date: Date | string
    status: string
    evaluations?: SoutenanceEvaluationUncheckedCreateNestedManyWithoutSoutenanceInput
  }

  export type SoutenanceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    evaluations?: SoutenanceEvaluationUpdateManyWithoutSoutenanceNestedInput
  }

  export type SoutenanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    evaluations?: SoutenanceEvaluationUncheckedUpdateManyWithoutSoutenanceNestedInput
  }

  export type SoutenanceCreateManyInput = {
    id?: number
    date: Date | string
    status: string
  }

  export type SoutenanceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SoutenanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SoutenanceEvaluationCreateInput = {
    soutenance: SoutenanceCreateNestedOneWithoutEvaluationsInput
  }

  export type SoutenanceEvaluationUncheckedCreateInput = {
    id?: number
    soutenanceId: number
  }

  export type SoutenanceEvaluationUpdateInput = {
    soutenance?: SoutenanceUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type SoutenanceEvaluationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    soutenanceId?: IntFieldUpdateOperationsInput | number
  }

  export type SoutenanceEvaluationCreateManyInput = {
    id?: number
    soutenanceId: number
  }

  export type SoutenanceEvaluationUpdateManyMutationInput = {

  }

  export type SoutenanceEvaluationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    soutenanceId?: IntFieldUpdateOperationsInput | number
  }

  export type ReportEvaluationCreateInput = {
    reportEvalId: number
    evaluation: EvaluationCreateNestedOneWithoutReportEvaluationInput
  }

  export type ReportEvaluationUncheckedCreateInput = {
    id?: number
    reportEvalId: number
    evaluationId: number
  }

  export type ReportEvaluationUpdateInput = {
    reportEvalId?: IntFieldUpdateOperationsInput | number
    evaluation?: EvaluationUpdateOneRequiredWithoutReportEvaluationNestedInput
  }

  export type ReportEvaluationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportEvalId?: IntFieldUpdateOperationsInput | number
    evaluationId?: IntFieldUpdateOperationsInput | number
  }

  export type ReportEvaluationCreateManyInput = {
    id?: number
    reportEvalId: number
    evaluationId: number
  }

  export type ReportEvaluationUpdateManyMutationInput = {
    reportEvalId?: IntFieldUpdateOperationsInput | number
  }

  export type ReportEvaluationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportEvalId?: IntFieldUpdateOperationsInput | number
    evaluationId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AdminNullableRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type StudentNullableRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type TutorNullableRelationFilter = {
    is?: TutorWhereInput | null
    isNot?: TutorWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type InternshipNullableRelationFilter = {
    is?: InternshipWhereInput | null
    isNot?: InternshipWhereInput | null
  }

  export type EvaluationListRelationFilter = {
    every?: EvaluationWhereInput
    some?: EvaluationWhereInput
    none?: EvaluationWhereInput
  }

  export type AcademicTutorNullableRelationFilter = {
    is?: AcademicTutorWhereInput | null
    isNot?: AcademicTutorWhereInput | null
  }

  export type EnterpriseTutorNullableRelationFilter = {
    is?: EnterpriseTutorWhereInput | null
    isNot?: EnterpriseTutorWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    promotion?: SortOrder
    userId?: SortOrder
    internshipId?: SortOrder
    academicTutorId?: SortOrder
    enterpriseTutorId?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    internshipId?: SortOrder
    academicTutorId?: SortOrder
    enterpriseTutorId?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    promotion?: SortOrder
    userId?: SortOrder
    internshipId?: SortOrder
    academicTutorId?: SortOrder
    enterpriseTutorId?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    promotion?: SortOrder
    userId?: SortOrder
    internshipId?: SortOrder
    academicTutorId?: SortOrder
    enterpriseTutorId?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    internshipId?: SortOrder
    academicTutorId?: SortOrder
    enterpriseTutorId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AcademicTutorListRelationFilter = {
    every?: AcademicTutorWhereInput
    some?: AcademicTutorWhereInput
    none?: AcademicTutorWhereInput
  }

  export type EnterpriseTutorListRelationFilter = {
    every?: EnterpriseTutorWhereInput
    some?: EnterpriseTutorWhereInput
    none?: EnterpriseTutorWhereInput
  }

  export type AcademicTutorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnterpriseTutorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TutorAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TutorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TutorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TutorSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TutorRelationFilter = {
    is?: TutorWhereInput
    isNot?: TutorWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicTutorCountOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
  }

  export type AcademicTutorAvgOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
  }

  export type AcademicTutorMaxOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
  }

  export type AcademicTutorMinOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
  }

  export type AcademicTutorSumOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
  }

  export type EnterpriseTutorCountOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
  }

  export type EnterpriseTutorAvgOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
  }

  export type EnterpriseTutorMaxOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
  }

  export type EnterpriseTutorMinOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
  }

  export type EnterpriseTutorSumOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
  }

  export type InternshipListRelationFilter = {
    every?: InternshipWhereInput
    some?: InternshipWhereInput
    none?: InternshipWhereInput
  }

  export type InternshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InternshipCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    companyId?: SortOrder
    tutorId?: SortOrder
  }

  export type InternshipAvgOrderByAggregateInput = {
    id?: SortOrder
    salary?: SortOrder
    companyId?: SortOrder
    tutorId?: SortOrder
  }

  export type InternshipMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    companyId?: SortOrder
    tutorId?: SortOrder
  }

  export type InternshipMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    companyId?: SortOrder
    tutorId?: SortOrder
  }

  export type InternshipSumOrderByAggregateInput = {
    id?: SortOrder
    salary?: SortOrder
    companyId?: SortOrder
    tutorId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CdCListRelationFilter = {
    every?: CdCWhereInput
    some?: CdCWhereInput
    none?: CdCWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type CdCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    documentType?: SortOrder
    internshipId?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    internshipId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    documentType?: SortOrder
    internshipId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    documentType?: SortOrder
    internshipId?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
    internshipId?: SortOrder
  }

  export type DocumentRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type CdCCountOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    documentId?: SortOrder
  }

  export type CdCAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CdCMaxOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    documentId?: SortOrder
  }

  export type CdCMinOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    documentId?: SortOrder
  }

  export type CdCSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    documentId?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    documentId?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    documentId?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReportEvaluationListRelationFilter = {
    every?: ReportEvaluationWhereInput
    some?: ReportEvaluationWhereInput
    none?: ReportEvaluationWhereInput
  }

  export type StudentEvaluationListRelationFilter = {
    every?: StudentEvaluationWhereInput
    some?: StudentEvaluationWhereInput
    none?: StudentEvaluationWhereInput
  }

  export type CompanyEvaluationListRelationFilter = {
    every?: CompanyEvaluationWhereInput
    some?: CompanyEvaluationWhereInput
    none?: CompanyEvaluationWhereInput
  }

  export type InternshipRelationFilter = {
    is?: InternshipWhereInput
    isNot?: InternshipWhereInput
  }

  export type ReportEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    evaluation?: SortOrder
    submissionDate?: SortOrder
    factor?: SortOrder
    internshipId?: SortOrder
    studentId?: SortOrder
  }

  export type EvaluationAvgOrderByAggregateInput = {
    id?: SortOrder
    factor?: SortOrder
    internshipId?: SortOrder
    studentId?: SortOrder
  }

  export type EvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    evaluation?: SortOrder
    submissionDate?: SortOrder
    factor?: SortOrder
    internshipId?: SortOrder
    studentId?: SortOrder
  }

  export type EvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    evaluation?: SortOrder
    submissionDate?: SortOrder
    factor?: SortOrder
    internshipId?: SortOrder
    studentId?: SortOrder
  }

  export type EvaluationSumOrderByAggregateInput = {
    id?: SortOrder
    factor?: SortOrder
    internshipId?: SortOrder
    studentId?: SortOrder
  }

  export type EvaluationRelationFilter = {
    is?: EvaluationWhereInput
    isNot?: EvaluationWhereInput
  }

  export type StudentEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
  }

  export type StudentEvaluationAvgOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
  }

  export type StudentEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
  }

  export type StudentEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
  }

  export type StudentEvaluationSumOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
  }

  export type CompanyEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
  }

  export type CompanyEvaluationAvgOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
  }

  export type CompanyEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
  }

  export type CompanyEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
  }

  export type CompanyEvaluationSumOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
  }

  export type SoutenanceEvaluationListRelationFilter = {
    every?: SoutenanceEvaluationWhereInput
    some?: SoutenanceEvaluationWhereInput
    none?: SoutenanceEvaluationWhereInput
  }

  export type SoutenanceEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SoutenanceCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type SoutenanceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SoutenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type SoutenanceMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type SoutenanceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SoutenanceRelationFilter = {
    is?: SoutenanceWhereInput
    isNot?: SoutenanceWhereInput
  }

  export type SoutenanceEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    soutenanceId?: SortOrder
  }

  export type SoutenanceEvaluationAvgOrderByAggregateInput = {
    id?: SortOrder
    soutenanceId?: SortOrder
  }

  export type SoutenanceEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    soutenanceId?: SortOrder
  }

  export type SoutenanceEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    soutenanceId?: SortOrder
  }

  export type SoutenanceEvaluationSumOrderByAggregateInput = {
    id?: SortOrder
    soutenanceId?: SortOrder
  }

  export type ReportEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    reportEvalId?: SortOrder
    evaluationId?: SortOrder
  }

  export type ReportEvaluationAvgOrderByAggregateInput = {
    id?: SortOrder
    reportEvalId?: SortOrder
    evaluationId?: SortOrder
  }

  export type ReportEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    reportEvalId?: SortOrder
    evaluationId?: SortOrder
  }

  export type ReportEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    reportEvalId?: SortOrder
    evaluationId?: SortOrder
  }

  export type ReportEvaluationSumOrderByAggregateInput = {
    id?: SortOrder
    reportEvalId?: SortOrder
    evaluationId?: SortOrder
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TutorCreateNestedOneWithoutUserInput = {
    create?: XOR<TutorCreateWithoutUserInput, TutorUncheckedCreateWithoutUserInput>
    connectOrCreate?: TutorCreateOrConnectWithoutUserInput
    connect?: TutorWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TutorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TutorCreateWithoutUserInput, TutorUncheckedCreateWithoutUserInput>
    connectOrCreate?: TutorCreateOrConnectWithoutUserInput
    connect?: TutorWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TutorUpdateOneWithoutUserNestedInput = {
    create?: XOR<TutorCreateWithoutUserInput, TutorUncheckedCreateWithoutUserInput>
    connectOrCreate?: TutorCreateOrConnectWithoutUserInput
    upsert?: TutorUpsertWithoutUserInput
    disconnect?: TutorWhereInput | boolean
    delete?: TutorWhereInput | boolean
    connect?: TutorWhereUniqueInput
    update?: XOR<XOR<TutorUpdateToOneWithWhereWithoutUserInput, TutorUpdateWithoutUserInput>, TutorUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TutorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TutorCreateWithoutUserInput, TutorUncheckedCreateWithoutUserInput>
    connectOrCreate?: TutorCreateOrConnectWithoutUserInput
    upsert?: TutorUpsertWithoutUserInput
    disconnect?: TutorWhereInput | boolean
    delete?: TutorWhereInput | boolean
    connect?: TutorWhereUniqueInput
    update?: XOR<XOR<TutorUpdateToOneWithWhereWithoutUserInput, TutorUpdateWithoutUserInput>, TutorUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type InternshipCreateNestedOneWithoutStudentInput = {
    create?: XOR<InternshipCreateWithoutStudentInput, InternshipUncheckedCreateWithoutStudentInput>
    connectOrCreate?: InternshipCreateOrConnectWithoutStudentInput
    connect?: InternshipWhereUniqueInput
  }

  export type EvaluationCreateNestedManyWithoutStudentInput = {
    create?: XOR<EvaluationCreateWithoutStudentInput, EvaluationUncheckedCreateWithoutStudentInput> | EvaluationCreateWithoutStudentInput[] | EvaluationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStudentInput | EvaluationCreateOrConnectWithoutStudentInput[]
    createMany?: EvaluationCreateManyStudentInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type AcademicTutorCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcademicTutorCreateWithoutStudentsInput, AcademicTutorUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicTutorCreateOrConnectWithoutStudentsInput
    connect?: AcademicTutorWhereUniqueInput
  }

  export type EnterpriseTutorCreateNestedOneWithoutStudentsInput = {
    create?: XOR<EnterpriseTutorCreateWithoutStudentsInput, EnterpriseTutorUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: EnterpriseTutorCreateOrConnectWithoutStudentsInput
    connect?: EnterpriseTutorWhereUniqueInput
  }

  export type EvaluationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<EvaluationCreateWithoutStudentInput, EvaluationUncheckedCreateWithoutStudentInput> | EvaluationCreateWithoutStudentInput[] | EvaluationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStudentInput | EvaluationCreateOrConnectWithoutStudentInput[]
    createMany?: EvaluationCreateManyStudentInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type InternshipUpdateOneWithoutStudentNestedInput = {
    create?: XOR<InternshipCreateWithoutStudentInput, InternshipUncheckedCreateWithoutStudentInput>
    connectOrCreate?: InternshipCreateOrConnectWithoutStudentInput
    upsert?: InternshipUpsertWithoutStudentInput
    disconnect?: InternshipWhereInput | boolean
    delete?: InternshipWhereInput | boolean
    connect?: InternshipWhereUniqueInput
    update?: XOR<XOR<InternshipUpdateToOneWithWhereWithoutStudentInput, InternshipUpdateWithoutStudentInput>, InternshipUncheckedUpdateWithoutStudentInput>
  }

  export type EvaluationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<EvaluationCreateWithoutStudentInput, EvaluationUncheckedCreateWithoutStudentInput> | EvaluationCreateWithoutStudentInput[] | EvaluationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStudentInput | EvaluationCreateOrConnectWithoutStudentInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutStudentInput | EvaluationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: EvaluationCreateManyStudentInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutStudentInput | EvaluationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutStudentInput | EvaluationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type AcademicTutorUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<AcademicTutorCreateWithoutStudentsInput, AcademicTutorUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicTutorCreateOrConnectWithoutStudentsInput
    upsert?: AcademicTutorUpsertWithoutStudentsInput
    disconnect?: AcademicTutorWhereInput | boolean
    delete?: AcademicTutorWhereInput | boolean
    connect?: AcademicTutorWhereUniqueInput
    update?: XOR<XOR<AcademicTutorUpdateToOneWithWhereWithoutStudentsInput, AcademicTutorUpdateWithoutStudentsInput>, AcademicTutorUncheckedUpdateWithoutStudentsInput>
  }

  export type EnterpriseTutorUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<EnterpriseTutorCreateWithoutStudentsInput, EnterpriseTutorUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: EnterpriseTutorCreateOrConnectWithoutStudentsInput
    upsert?: EnterpriseTutorUpsertWithoutStudentsInput
    disconnect?: EnterpriseTutorWhereInput | boolean
    delete?: EnterpriseTutorWhereInput | boolean
    connect?: EnterpriseTutorWhereUniqueInput
    update?: XOR<XOR<EnterpriseTutorUpdateToOneWithWhereWithoutStudentsInput, EnterpriseTutorUpdateWithoutStudentsInput>, EnterpriseTutorUncheckedUpdateWithoutStudentsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EvaluationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<EvaluationCreateWithoutStudentInput, EvaluationUncheckedCreateWithoutStudentInput> | EvaluationCreateWithoutStudentInput[] | EvaluationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStudentInput | EvaluationCreateOrConnectWithoutStudentInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutStudentInput | EvaluationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: EvaluationCreateManyStudentInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutStudentInput | EvaluationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutStudentInput | EvaluationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTutorInput = {
    create?: XOR<UserCreateWithoutTutorInput, UserUncheckedCreateWithoutTutorInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutorInput
    connect?: UserWhereUniqueInput
  }

  export type AcademicTutorCreateNestedManyWithoutTutorInput = {
    create?: XOR<AcademicTutorCreateWithoutTutorInput, AcademicTutorUncheckedCreateWithoutTutorInput> | AcademicTutorCreateWithoutTutorInput[] | AcademicTutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: AcademicTutorCreateOrConnectWithoutTutorInput | AcademicTutorCreateOrConnectWithoutTutorInput[]
    createMany?: AcademicTutorCreateManyTutorInputEnvelope
    connect?: AcademicTutorWhereUniqueInput | AcademicTutorWhereUniqueInput[]
  }

  export type EnterpriseTutorCreateNestedManyWithoutTutorInput = {
    create?: XOR<EnterpriseTutorCreateWithoutTutorInput, EnterpriseTutorUncheckedCreateWithoutTutorInput> | EnterpriseTutorCreateWithoutTutorInput[] | EnterpriseTutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: EnterpriseTutorCreateOrConnectWithoutTutorInput | EnterpriseTutorCreateOrConnectWithoutTutorInput[]
    createMany?: EnterpriseTutorCreateManyTutorInputEnvelope
    connect?: EnterpriseTutorWhereUniqueInput | EnterpriseTutorWhereUniqueInput[]
  }

  export type AcademicTutorUncheckedCreateNestedManyWithoutTutorInput = {
    create?: XOR<AcademicTutorCreateWithoutTutorInput, AcademicTutorUncheckedCreateWithoutTutorInput> | AcademicTutorCreateWithoutTutorInput[] | AcademicTutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: AcademicTutorCreateOrConnectWithoutTutorInput | AcademicTutorCreateOrConnectWithoutTutorInput[]
    createMany?: AcademicTutorCreateManyTutorInputEnvelope
    connect?: AcademicTutorWhereUniqueInput | AcademicTutorWhereUniqueInput[]
  }

  export type EnterpriseTutorUncheckedCreateNestedManyWithoutTutorInput = {
    create?: XOR<EnterpriseTutorCreateWithoutTutorInput, EnterpriseTutorUncheckedCreateWithoutTutorInput> | EnterpriseTutorCreateWithoutTutorInput[] | EnterpriseTutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: EnterpriseTutorCreateOrConnectWithoutTutorInput | EnterpriseTutorCreateOrConnectWithoutTutorInput[]
    createMany?: EnterpriseTutorCreateManyTutorInputEnvelope
    connect?: EnterpriseTutorWhereUniqueInput | EnterpriseTutorWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTutorNestedInput = {
    create?: XOR<UserCreateWithoutTutorInput, UserUncheckedCreateWithoutTutorInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutorInput
    upsert?: UserUpsertWithoutTutorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTutorInput, UserUpdateWithoutTutorInput>, UserUncheckedUpdateWithoutTutorInput>
  }

  export type AcademicTutorUpdateManyWithoutTutorNestedInput = {
    create?: XOR<AcademicTutorCreateWithoutTutorInput, AcademicTutorUncheckedCreateWithoutTutorInput> | AcademicTutorCreateWithoutTutorInput[] | AcademicTutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: AcademicTutorCreateOrConnectWithoutTutorInput | AcademicTutorCreateOrConnectWithoutTutorInput[]
    upsert?: AcademicTutorUpsertWithWhereUniqueWithoutTutorInput | AcademicTutorUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: AcademicTutorCreateManyTutorInputEnvelope
    set?: AcademicTutorWhereUniqueInput | AcademicTutorWhereUniqueInput[]
    disconnect?: AcademicTutorWhereUniqueInput | AcademicTutorWhereUniqueInput[]
    delete?: AcademicTutorWhereUniqueInput | AcademicTutorWhereUniqueInput[]
    connect?: AcademicTutorWhereUniqueInput | AcademicTutorWhereUniqueInput[]
    update?: AcademicTutorUpdateWithWhereUniqueWithoutTutorInput | AcademicTutorUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: AcademicTutorUpdateManyWithWhereWithoutTutorInput | AcademicTutorUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: AcademicTutorScalarWhereInput | AcademicTutorScalarWhereInput[]
  }

  export type EnterpriseTutorUpdateManyWithoutTutorNestedInput = {
    create?: XOR<EnterpriseTutorCreateWithoutTutorInput, EnterpriseTutorUncheckedCreateWithoutTutorInput> | EnterpriseTutorCreateWithoutTutorInput[] | EnterpriseTutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: EnterpriseTutorCreateOrConnectWithoutTutorInput | EnterpriseTutorCreateOrConnectWithoutTutorInput[]
    upsert?: EnterpriseTutorUpsertWithWhereUniqueWithoutTutorInput | EnterpriseTutorUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: EnterpriseTutorCreateManyTutorInputEnvelope
    set?: EnterpriseTutorWhereUniqueInput | EnterpriseTutorWhereUniqueInput[]
    disconnect?: EnterpriseTutorWhereUniqueInput | EnterpriseTutorWhereUniqueInput[]
    delete?: EnterpriseTutorWhereUniqueInput | EnterpriseTutorWhereUniqueInput[]
    connect?: EnterpriseTutorWhereUniqueInput | EnterpriseTutorWhereUniqueInput[]
    update?: EnterpriseTutorUpdateWithWhereUniqueWithoutTutorInput | EnterpriseTutorUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: EnterpriseTutorUpdateManyWithWhereWithoutTutorInput | EnterpriseTutorUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: EnterpriseTutorScalarWhereInput | EnterpriseTutorScalarWhereInput[]
  }

  export type AcademicTutorUncheckedUpdateManyWithoutTutorNestedInput = {
    create?: XOR<AcademicTutorCreateWithoutTutorInput, AcademicTutorUncheckedCreateWithoutTutorInput> | AcademicTutorCreateWithoutTutorInput[] | AcademicTutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: AcademicTutorCreateOrConnectWithoutTutorInput | AcademicTutorCreateOrConnectWithoutTutorInput[]
    upsert?: AcademicTutorUpsertWithWhereUniqueWithoutTutorInput | AcademicTutorUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: AcademicTutorCreateManyTutorInputEnvelope
    set?: AcademicTutorWhereUniqueInput | AcademicTutorWhereUniqueInput[]
    disconnect?: AcademicTutorWhereUniqueInput | AcademicTutorWhereUniqueInput[]
    delete?: AcademicTutorWhereUniqueInput | AcademicTutorWhereUniqueInput[]
    connect?: AcademicTutorWhereUniqueInput | AcademicTutorWhereUniqueInput[]
    update?: AcademicTutorUpdateWithWhereUniqueWithoutTutorInput | AcademicTutorUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: AcademicTutorUpdateManyWithWhereWithoutTutorInput | AcademicTutorUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: AcademicTutorScalarWhereInput | AcademicTutorScalarWhereInput[]
  }

  export type EnterpriseTutorUncheckedUpdateManyWithoutTutorNestedInput = {
    create?: XOR<EnterpriseTutorCreateWithoutTutorInput, EnterpriseTutorUncheckedCreateWithoutTutorInput> | EnterpriseTutorCreateWithoutTutorInput[] | EnterpriseTutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: EnterpriseTutorCreateOrConnectWithoutTutorInput | EnterpriseTutorCreateOrConnectWithoutTutorInput[]
    upsert?: EnterpriseTutorUpsertWithWhereUniqueWithoutTutorInput | EnterpriseTutorUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: EnterpriseTutorCreateManyTutorInputEnvelope
    set?: EnterpriseTutorWhereUniqueInput | EnterpriseTutorWhereUniqueInput[]
    disconnect?: EnterpriseTutorWhereUniqueInput | EnterpriseTutorWhereUniqueInput[]
    delete?: EnterpriseTutorWhereUniqueInput | EnterpriseTutorWhereUniqueInput[]
    connect?: EnterpriseTutorWhereUniqueInput | EnterpriseTutorWhereUniqueInput[]
    update?: EnterpriseTutorUpdateWithWhereUniqueWithoutTutorInput | EnterpriseTutorUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: EnterpriseTutorUpdateManyWithWhereWithoutTutorInput | EnterpriseTutorUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: EnterpriseTutorScalarWhereInput | EnterpriseTutorScalarWhereInput[]
  }

  export type TutorCreateNestedOneWithoutAcademicTutorsInput = {
    create?: XOR<TutorCreateWithoutAcademicTutorsInput, TutorUncheckedCreateWithoutAcademicTutorsInput>
    connectOrCreate?: TutorCreateOrConnectWithoutAcademicTutorsInput
    connect?: TutorWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutAcademicTutorInput = {
    create?: XOR<StudentCreateWithoutAcademicTutorInput, StudentUncheckedCreateWithoutAcademicTutorInput> | StudentCreateWithoutAcademicTutorInput[] | StudentUncheckedCreateWithoutAcademicTutorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicTutorInput | StudentCreateOrConnectWithoutAcademicTutorInput[]
    createMany?: StudentCreateManyAcademicTutorInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutAcademicTutorInput = {
    create?: XOR<StudentCreateWithoutAcademicTutorInput, StudentUncheckedCreateWithoutAcademicTutorInput> | StudentCreateWithoutAcademicTutorInput[] | StudentUncheckedCreateWithoutAcademicTutorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicTutorInput | StudentCreateOrConnectWithoutAcademicTutorInput[]
    createMany?: StudentCreateManyAcademicTutorInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TutorUpdateOneRequiredWithoutAcademicTutorsNestedInput = {
    create?: XOR<TutorCreateWithoutAcademicTutorsInput, TutorUncheckedCreateWithoutAcademicTutorsInput>
    connectOrCreate?: TutorCreateOrConnectWithoutAcademicTutorsInput
    upsert?: TutorUpsertWithoutAcademicTutorsInput
    connect?: TutorWhereUniqueInput
    update?: XOR<XOR<TutorUpdateToOneWithWhereWithoutAcademicTutorsInput, TutorUpdateWithoutAcademicTutorsInput>, TutorUncheckedUpdateWithoutAcademicTutorsInput>
  }

  export type StudentUpdateManyWithoutAcademicTutorNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicTutorInput, StudentUncheckedCreateWithoutAcademicTutorInput> | StudentCreateWithoutAcademicTutorInput[] | StudentUncheckedCreateWithoutAcademicTutorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicTutorInput | StudentCreateOrConnectWithoutAcademicTutorInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicTutorInput | StudentUpsertWithWhereUniqueWithoutAcademicTutorInput[]
    createMany?: StudentCreateManyAcademicTutorInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicTutorInput | StudentUpdateWithWhereUniqueWithoutAcademicTutorInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicTutorInput | StudentUpdateManyWithWhereWithoutAcademicTutorInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutAcademicTutorNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicTutorInput, StudentUncheckedCreateWithoutAcademicTutorInput> | StudentCreateWithoutAcademicTutorInput[] | StudentUncheckedCreateWithoutAcademicTutorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicTutorInput | StudentCreateOrConnectWithoutAcademicTutorInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicTutorInput | StudentUpsertWithWhereUniqueWithoutAcademicTutorInput[]
    createMany?: StudentCreateManyAcademicTutorInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicTutorInput | StudentUpdateWithWhereUniqueWithoutAcademicTutorInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicTutorInput | StudentUpdateManyWithWhereWithoutAcademicTutorInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TutorCreateNestedOneWithoutEnterpriseTutorsInput = {
    create?: XOR<TutorCreateWithoutEnterpriseTutorsInput, TutorUncheckedCreateWithoutEnterpriseTutorsInput>
    connectOrCreate?: TutorCreateOrConnectWithoutEnterpriseTutorsInput
    connect?: TutorWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutEnterpriseTutorInput = {
    create?: XOR<StudentCreateWithoutEnterpriseTutorInput, StudentUncheckedCreateWithoutEnterpriseTutorInput> | StudentCreateWithoutEnterpriseTutorInput[] | StudentUncheckedCreateWithoutEnterpriseTutorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEnterpriseTutorInput | StudentCreateOrConnectWithoutEnterpriseTutorInput[]
    createMany?: StudentCreateManyEnterpriseTutorInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutEnterpriseTutorInput = {
    create?: XOR<StudentCreateWithoutEnterpriseTutorInput, StudentUncheckedCreateWithoutEnterpriseTutorInput> | StudentCreateWithoutEnterpriseTutorInput[] | StudentUncheckedCreateWithoutEnterpriseTutorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEnterpriseTutorInput | StudentCreateOrConnectWithoutEnterpriseTutorInput[]
    createMany?: StudentCreateManyEnterpriseTutorInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TutorUpdateOneRequiredWithoutEnterpriseTutorsNestedInput = {
    create?: XOR<TutorCreateWithoutEnterpriseTutorsInput, TutorUncheckedCreateWithoutEnterpriseTutorsInput>
    connectOrCreate?: TutorCreateOrConnectWithoutEnterpriseTutorsInput
    upsert?: TutorUpsertWithoutEnterpriseTutorsInput
    connect?: TutorWhereUniqueInput
    update?: XOR<XOR<TutorUpdateToOneWithWhereWithoutEnterpriseTutorsInput, TutorUpdateWithoutEnterpriseTutorsInput>, TutorUncheckedUpdateWithoutEnterpriseTutorsInput>
  }

  export type StudentUpdateManyWithoutEnterpriseTutorNestedInput = {
    create?: XOR<StudentCreateWithoutEnterpriseTutorInput, StudentUncheckedCreateWithoutEnterpriseTutorInput> | StudentCreateWithoutEnterpriseTutorInput[] | StudentUncheckedCreateWithoutEnterpriseTutorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEnterpriseTutorInput | StudentCreateOrConnectWithoutEnterpriseTutorInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutEnterpriseTutorInput | StudentUpsertWithWhereUniqueWithoutEnterpriseTutorInput[]
    createMany?: StudentCreateManyEnterpriseTutorInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutEnterpriseTutorInput | StudentUpdateWithWhereUniqueWithoutEnterpriseTutorInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutEnterpriseTutorInput | StudentUpdateManyWithWhereWithoutEnterpriseTutorInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutEnterpriseTutorNestedInput = {
    create?: XOR<StudentCreateWithoutEnterpriseTutorInput, StudentUncheckedCreateWithoutEnterpriseTutorInput> | StudentCreateWithoutEnterpriseTutorInput[] | StudentUncheckedCreateWithoutEnterpriseTutorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEnterpriseTutorInput | StudentCreateOrConnectWithoutEnterpriseTutorInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutEnterpriseTutorInput | StudentUpsertWithWhereUniqueWithoutEnterpriseTutorInput[]
    createMany?: StudentCreateManyEnterpriseTutorInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutEnterpriseTutorInput | StudentUpdateWithWhereUniqueWithoutEnterpriseTutorInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutEnterpriseTutorInput | StudentUpdateManyWithWhereWithoutEnterpriseTutorInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type InternshipCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InternshipCreateWithoutCompanyInput, InternshipUncheckedCreateWithoutCompanyInput> | InternshipCreateWithoutCompanyInput[] | InternshipUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InternshipCreateOrConnectWithoutCompanyInput | InternshipCreateOrConnectWithoutCompanyInput[]
    createMany?: InternshipCreateManyCompanyInputEnvelope
    connect?: InternshipWhereUniqueInput | InternshipWhereUniqueInput[]
  }

  export type InternshipUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InternshipCreateWithoutCompanyInput, InternshipUncheckedCreateWithoutCompanyInput> | InternshipCreateWithoutCompanyInput[] | InternshipUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InternshipCreateOrConnectWithoutCompanyInput | InternshipCreateOrConnectWithoutCompanyInput[]
    createMany?: InternshipCreateManyCompanyInputEnvelope
    connect?: InternshipWhereUniqueInput | InternshipWhereUniqueInput[]
  }

  export type InternshipUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InternshipCreateWithoutCompanyInput, InternshipUncheckedCreateWithoutCompanyInput> | InternshipCreateWithoutCompanyInput[] | InternshipUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InternshipCreateOrConnectWithoutCompanyInput | InternshipCreateOrConnectWithoutCompanyInput[]
    upsert?: InternshipUpsertWithWhereUniqueWithoutCompanyInput | InternshipUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InternshipCreateManyCompanyInputEnvelope
    set?: InternshipWhereUniqueInput | InternshipWhereUniqueInput[]
    disconnect?: InternshipWhereUniqueInput | InternshipWhereUniqueInput[]
    delete?: InternshipWhereUniqueInput | InternshipWhereUniqueInput[]
    connect?: InternshipWhereUniqueInput | InternshipWhereUniqueInput[]
    update?: InternshipUpdateWithWhereUniqueWithoutCompanyInput | InternshipUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InternshipUpdateManyWithWhereWithoutCompanyInput | InternshipUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InternshipScalarWhereInput | InternshipScalarWhereInput[]
  }

  export type InternshipUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InternshipCreateWithoutCompanyInput, InternshipUncheckedCreateWithoutCompanyInput> | InternshipCreateWithoutCompanyInput[] | InternshipUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InternshipCreateOrConnectWithoutCompanyInput | InternshipCreateOrConnectWithoutCompanyInput[]
    upsert?: InternshipUpsertWithWhereUniqueWithoutCompanyInput | InternshipUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InternshipCreateManyCompanyInputEnvelope
    set?: InternshipWhereUniqueInput | InternshipWhereUniqueInput[]
    disconnect?: InternshipWhereUniqueInput | InternshipWhereUniqueInput[]
    delete?: InternshipWhereUniqueInput | InternshipWhereUniqueInput[]
    connect?: InternshipWhereUniqueInput | InternshipWhereUniqueInput[]
    update?: InternshipUpdateWithWhereUniqueWithoutCompanyInput | InternshipUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InternshipUpdateManyWithWhereWithoutCompanyInput | InternshipUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InternshipScalarWhereInput | InternshipScalarWhereInput[]
  }

  export type EvaluationCreateNestedManyWithoutInternshipInput = {
    create?: XOR<EvaluationCreateWithoutInternshipInput, EvaluationUncheckedCreateWithoutInternshipInput> | EvaluationCreateWithoutInternshipInput[] | EvaluationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutInternshipInput | EvaluationCreateOrConnectWithoutInternshipInput[]
    createMany?: EvaluationCreateManyInternshipInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutInternshipsInput = {
    create?: XOR<CompanyCreateWithoutInternshipsInput, CompanyUncheckedCreateWithoutInternshipsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInternshipsInput
    connect?: CompanyWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutInternshipInput = {
    create?: XOR<DocumentCreateWithoutInternshipInput, DocumentUncheckedCreateWithoutInternshipInput> | DocumentCreateWithoutInternshipInput[] | DocumentUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutInternshipInput | DocumentCreateOrConnectWithoutInternshipInput[]
    createMany?: DocumentCreateManyInternshipInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutInternshipInput = {
    create?: XOR<StudentCreateWithoutInternshipInput, StudentUncheckedCreateWithoutInternshipInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInternshipInput
    connect?: StudentWhereUniqueInput
  }

  export type EvaluationUncheckedCreateNestedManyWithoutInternshipInput = {
    create?: XOR<EvaluationCreateWithoutInternshipInput, EvaluationUncheckedCreateWithoutInternshipInput> | EvaluationCreateWithoutInternshipInput[] | EvaluationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutInternshipInput | EvaluationCreateOrConnectWithoutInternshipInput[]
    createMany?: EvaluationCreateManyInternshipInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutInternshipInput = {
    create?: XOR<DocumentCreateWithoutInternshipInput, DocumentUncheckedCreateWithoutInternshipInput> | DocumentCreateWithoutInternshipInput[] | DocumentUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutInternshipInput | DocumentCreateOrConnectWithoutInternshipInput[]
    createMany?: DocumentCreateManyInternshipInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutInternshipInput = {
    create?: XOR<StudentCreateWithoutInternshipInput, StudentUncheckedCreateWithoutInternshipInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInternshipInput
    connect?: StudentWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EvaluationUpdateManyWithoutInternshipNestedInput = {
    create?: XOR<EvaluationCreateWithoutInternshipInput, EvaluationUncheckedCreateWithoutInternshipInput> | EvaluationCreateWithoutInternshipInput[] | EvaluationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutInternshipInput | EvaluationCreateOrConnectWithoutInternshipInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutInternshipInput | EvaluationUpsertWithWhereUniqueWithoutInternshipInput[]
    createMany?: EvaluationCreateManyInternshipInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutInternshipInput | EvaluationUpdateWithWhereUniqueWithoutInternshipInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutInternshipInput | EvaluationUpdateManyWithWhereWithoutInternshipInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutInternshipsNestedInput = {
    create?: XOR<CompanyCreateWithoutInternshipsInput, CompanyUncheckedCreateWithoutInternshipsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInternshipsInput
    upsert?: CompanyUpsertWithoutInternshipsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInternshipsInput, CompanyUpdateWithoutInternshipsInput>, CompanyUncheckedUpdateWithoutInternshipsInput>
  }

  export type DocumentUpdateManyWithoutInternshipNestedInput = {
    create?: XOR<DocumentCreateWithoutInternshipInput, DocumentUncheckedCreateWithoutInternshipInput> | DocumentCreateWithoutInternshipInput[] | DocumentUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutInternshipInput | DocumentCreateOrConnectWithoutInternshipInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutInternshipInput | DocumentUpsertWithWhereUniqueWithoutInternshipInput[]
    createMany?: DocumentCreateManyInternshipInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutInternshipInput | DocumentUpdateWithWhereUniqueWithoutInternshipInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutInternshipInput | DocumentUpdateManyWithWhereWithoutInternshipInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type StudentUpdateOneWithoutInternshipNestedInput = {
    create?: XOR<StudentCreateWithoutInternshipInput, StudentUncheckedCreateWithoutInternshipInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInternshipInput
    upsert?: StudentUpsertWithoutInternshipInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutInternshipInput, StudentUpdateWithoutInternshipInput>, StudentUncheckedUpdateWithoutInternshipInput>
  }

  export type EvaluationUncheckedUpdateManyWithoutInternshipNestedInput = {
    create?: XOR<EvaluationCreateWithoutInternshipInput, EvaluationUncheckedCreateWithoutInternshipInput> | EvaluationCreateWithoutInternshipInput[] | EvaluationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutInternshipInput | EvaluationCreateOrConnectWithoutInternshipInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutInternshipInput | EvaluationUpsertWithWhereUniqueWithoutInternshipInput[]
    createMany?: EvaluationCreateManyInternshipInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutInternshipInput | EvaluationUpdateWithWhereUniqueWithoutInternshipInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutInternshipInput | EvaluationUpdateManyWithWhereWithoutInternshipInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutInternshipNestedInput = {
    create?: XOR<DocumentCreateWithoutInternshipInput, DocumentUncheckedCreateWithoutInternshipInput> | DocumentCreateWithoutInternshipInput[] | DocumentUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutInternshipInput | DocumentCreateOrConnectWithoutInternshipInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutInternshipInput | DocumentUpsertWithWhereUniqueWithoutInternshipInput[]
    createMany?: DocumentCreateManyInternshipInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutInternshipInput | DocumentUpdateWithWhereUniqueWithoutInternshipInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutInternshipInput | DocumentUpdateManyWithWhereWithoutInternshipInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutInternshipNestedInput = {
    create?: XOR<StudentCreateWithoutInternshipInput, StudentUncheckedCreateWithoutInternshipInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInternshipInput
    upsert?: StudentUpsertWithoutInternshipInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutInternshipInput, StudentUpdateWithoutInternshipInput>, StudentUncheckedUpdateWithoutInternshipInput>
  }

  export type CdCCreateNestedManyWithoutDocumentInput = {
    create?: XOR<CdCCreateWithoutDocumentInput, CdCUncheckedCreateWithoutDocumentInput> | CdCCreateWithoutDocumentInput[] | CdCUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: CdCCreateOrConnectWithoutDocumentInput | CdCCreateOrConnectWithoutDocumentInput[]
    createMany?: CdCCreateManyDocumentInputEnvelope
    connect?: CdCWhereUniqueInput | CdCWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutDocumentInput = {
    create?: XOR<ReportCreateWithoutDocumentInput, ReportUncheckedCreateWithoutDocumentInput> | ReportCreateWithoutDocumentInput[] | ReportUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutDocumentInput | ReportCreateOrConnectWithoutDocumentInput[]
    createMany?: ReportCreateManyDocumentInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type InternshipCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<InternshipCreateWithoutDocumentsInput, InternshipUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: InternshipCreateOrConnectWithoutDocumentsInput
    connect?: InternshipWhereUniqueInput
  }

  export type CdCUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<CdCCreateWithoutDocumentInput, CdCUncheckedCreateWithoutDocumentInput> | CdCCreateWithoutDocumentInput[] | CdCUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: CdCCreateOrConnectWithoutDocumentInput | CdCCreateOrConnectWithoutDocumentInput[]
    createMany?: CdCCreateManyDocumentInputEnvelope
    connect?: CdCWhereUniqueInput | CdCWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<ReportCreateWithoutDocumentInput, ReportUncheckedCreateWithoutDocumentInput> | ReportCreateWithoutDocumentInput[] | ReportUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutDocumentInput | ReportCreateOrConnectWithoutDocumentInput[]
    createMany?: ReportCreateManyDocumentInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type CdCUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<CdCCreateWithoutDocumentInput, CdCUncheckedCreateWithoutDocumentInput> | CdCCreateWithoutDocumentInput[] | CdCUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: CdCCreateOrConnectWithoutDocumentInput | CdCCreateOrConnectWithoutDocumentInput[]
    upsert?: CdCUpsertWithWhereUniqueWithoutDocumentInput | CdCUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: CdCCreateManyDocumentInputEnvelope
    set?: CdCWhereUniqueInput | CdCWhereUniqueInput[]
    disconnect?: CdCWhereUniqueInput | CdCWhereUniqueInput[]
    delete?: CdCWhereUniqueInput | CdCWhereUniqueInput[]
    connect?: CdCWhereUniqueInput | CdCWhereUniqueInput[]
    update?: CdCUpdateWithWhereUniqueWithoutDocumentInput | CdCUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: CdCUpdateManyWithWhereWithoutDocumentInput | CdCUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: CdCScalarWhereInput | CdCScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<ReportCreateWithoutDocumentInput, ReportUncheckedCreateWithoutDocumentInput> | ReportCreateWithoutDocumentInput[] | ReportUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutDocumentInput | ReportCreateOrConnectWithoutDocumentInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutDocumentInput | ReportUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: ReportCreateManyDocumentInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutDocumentInput | ReportUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutDocumentInput | ReportUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type InternshipUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<InternshipCreateWithoutDocumentsInput, InternshipUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: InternshipCreateOrConnectWithoutDocumentsInput
    upsert?: InternshipUpsertWithoutDocumentsInput
    disconnect?: InternshipWhereInput | boolean
    delete?: InternshipWhereInput | boolean
    connect?: InternshipWhereUniqueInput
    update?: XOR<XOR<InternshipUpdateToOneWithWhereWithoutDocumentsInput, InternshipUpdateWithoutDocumentsInput>, InternshipUncheckedUpdateWithoutDocumentsInput>
  }

  export type CdCUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<CdCCreateWithoutDocumentInput, CdCUncheckedCreateWithoutDocumentInput> | CdCCreateWithoutDocumentInput[] | CdCUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: CdCCreateOrConnectWithoutDocumentInput | CdCCreateOrConnectWithoutDocumentInput[]
    upsert?: CdCUpsertWithWhereUniqueWithoutDocumentInput | CdCUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: CdCCreateManyDocumentInputEnvelope
    set?: CdCWhereUniqueInput | CdCWhereUniqueInput[]
    disconnect?: CdCWhereUniqueInput | CdCWhereUniqueInput[]
    delete?: CdCWhereUniqueInput | CdCWhereUniqueInput[]
    connect?: CdCWhereUniqueInput | CdCWhereUniqueInput[]
    update?: CdCUpdateWithWhereUniqueWithoutDocumentInput | CdCUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: CdCUpdateManyWithWhereWithoutDocumentInput | CdCUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: CdCScalarWhereInput | CdCScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<ReportCreateWithoutDocumentInput, ReportUncheckedCreateWithoutDocumentInput> | ReportCreateWithoutDocumentInput[] | ReportUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutDocumentInput | ReportCreateOrConnectWithoutDocumentInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutDocumentInput | ReportUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: ReportCreateManyDocumentInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutDocumentInput | ReportUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutDocumentInput | ReportUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutCdCInput = {
    create?: XOR<DocumentCreateWithoutCdCInput, DocumentUncheckedCreateWithoutCdCInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCdCInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutCdCNestedInput = {
    create?: XOR<DocumentCreateWithoutCdCInput, DocumentUncheckedCreateWithoutCdCInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCdCInput
    upsert?: DocumentUpsertWithoutCdCInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutCdCInput, DocumentUpdateWithoutCdCInput>, DocumentUncheckedUpdateWithoutCdCInput>
  }

  export type DocumentCreateNestedOneWithoutReportInput = {
    create?: XOR<DocumentCreateWithoutReportInput, DocumentUncheckedCreateWithoutReportInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutReportInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutReportNestedInput = {
    create?: XOR<DocumentCreateWithoutReportInput, DocumentUncheckedCreateWithoutReportInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutReportInput
    upsert?: DocumentUpsertWithoutReportInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutReportInput, DocumentUpdateWithoutReportInput>, DocumentUncheckedUpdateWithoutReportInput>
  }

  export type ReportEvaluationCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<ReportEvaluationCreateWithoutEvaluationInput, ReportEvaluationUncheckedCreateWithoutEvaluationInput> | ReportEvaluationCreateWithoutEvaluationInput[] | ReportEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: ReportEvaluationCreateOrConnectWithoutEvaluationInput | ReportEvaluationCreateOrConnectWithoutEvaluationInput[]
    createMany?: ReportEvaluationCreateManyEvaluationInputEnvelope
    connect?: ReportEvaluationWhereUniqueInput | ReportEvaluationWhereUniqueInput[]
  }

  export type StudentEvaluationCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<StudentEvaluationCreateWithoutEvaluationInput, StudentEvaluationUncheckedCreateWithoutEvaluationInput> | StudentEvaluationCreateWithoutEvaluationInput[] | StudentEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: StudentEvaluationCreateOrConnectWithoutEvaluationInput | StudentEvaluationCreateOrConnectWithoutEvaluationInput[]
    createMany?: StudentEvaluationCreateManyEvaluationInputEnvelope
    connect?: StudentEvaluationWhereUniqueInput | StudentEvaluationWhereUniqueInput[]
  }

  export type CompanyEvaluationCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<CompanyEvaluationCreateWithoutEvaluationInput, CompanyEvaluationUncheckedCreateWithoutEvaluationInput> | CompanyEvaluationCreateWithoutEvaluationInput[] | CompanyEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: CompanyEvaluationCreateOrConnectWithoutEvaluationInput | CompanyEvaluationCreateOrConnectWithoutEvaluationInput[]
    createMany?: CompanyEvaluationCreateManyEvaluationInputEnvelope
    connect?: CompanyEvaluationWhereUniqueInput | CompanyEvaluationWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<StudentCreateWithoutEvaluationsInput, StudentUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEvaluationsInput
    connect?: StudentWhereUniqueInput
  }

  export type InternshipCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<InternshipCreateWithoutEvaluationsInput, InternshipUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: InternshipCreateOrConnectWithoutEvaluationsInput
    connect?: InternshipWhereUniqueInput
  }

  export type ReportEvaluationUncheckedCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<ReportEvaluationCreateWithoutEvaluationInput, ReportEvaluationUncheckedCreateWithoutEvaluationInput> | ReportEvaluationCreateWithoutEvaluationInput[] | ReportEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: ReportEvaluationCreateOrConnectWithoutEvaluationInput | ReportEvaluationCreateOrConnectWithoutEvaluationInput[]
    createMany?: ReportEvaluationCreateManyEvaluationInputEnvelope
    connect?: ReportEvaluationWhereUniqueInput | ReportEvaluationWhereUniqueInput[]
  }

  export type StudentEvaluationUncheckedCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<StudentEvaluationCreateWithoutEvaluationInput, StudentEvaluationUncheckedCreateWithoutEvaluationInput> | StudentEvaluationCreateWithoutEvaluationInput[] | StudentEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: StudentEvaluationCreateOrConnectWithoutEvaluationInput | StudentEvaluationCreateOrConnectWithoutEvaluationInput[]
    createMany?: StudentEvaluationCreateManyEvaluationInputEnvelope
    connect?: StudentEvaluationWhereUniqueInput | StudentEvaluationWhereUniqueInput[]
  }

  export type CompanyEvaluationUncheckedCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<CompanyEvaluationCreateWithoutEvaluationInput, CompanyEvaluationUncheckedCreateWithoutEvaluationInput> | CompanyEvaluationCreateWithoutEvaluationInput[] | CompanyEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: CompanyEvaluationCreateOrConnectWithoutEvaluationInput | CompanyEvaluationCreateOrConnectWithoutEvaluationInput[]
    createMany?: CompanyEvaluationCreateManyEvaluationInputEnvelope
    connect?: CompanyEvaluationWhereUniqueInput | CompanyEvaluationWhereUniqueInput[]
  }

  export type ReportEvaluationUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<ReportEvaluationCreateWithoutEvaluationInput, ReportEvaluationUncheckedCreateWithoutEvaluationInput> | ReportEvaluationCreateWithoutEvaluationInput[] | ReportEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: ReportEvaluationCreateOrConnectWithoutEvaluationInput | ReportEvaluationCreateOrConnectWithoutEvaluationInput[]
    upsert?: ReportEvaluationUpsertWithWhereUniqueWithoutEvaluationInput | ReportEvaluationUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: ReportEvaluationCreateManyEvaluationInputEnvelope
    set?: ReportEvaluationWhereUniqueInput | ReportEvaluationWhereUniqueInput[]
    disconnect?: ReportEvaluationWhereUniqueInput | ReportEvaluationWhereUniqueInput[]
    delete?: ReportEvaluationWhereUniqueInput | ReportEvaluationWhereUniqueInput[]
    connect?: ReportEvaluationWhereUniqueInput | ReportEvaluationWhereUniqueInput[]
    update?: ReportEvaluationUpdateWithWhereUniqueWithoutEvaluationInput | ReportEvaluationUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: ReportEvaluationUpdateManyWithWhereWithoutEvaluationInput | ReportEvaluationUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: ReportEvaluationScalarWhereInput | ReportEvaluationScalarWhereInput[]
  }

  export type StudentEvaluationUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<StudentEvaluationCreateWithoutEvaluationInput, StudentEvaluationUncheckedCreateWithoutEvaluationInput> | StudentEvaluationCreateWithoutEvaluationInput[] | StudentEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: StudentEvaluationCreateOrConnectWithoutEvaluationInput | StudentEvaluationCreateOrConnectWithoutEvaluationInput[]
    upsert?: StudentEvaluationUpsertWithWhereUniqueWithoutEvaluationInput | StudentEvaluationUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: StudentEvaluationCreateManyEvaluationInputEnvelope
    set?: StudentEvaluationWhereUniqueInput | StudentEvaluationWhereUniqueInput[]
    disconnect?: StudentEvaluationWhereUniqueInput | StudentEvaluationWhereUniqueInput[]
    delete?: StudentEvaluationWhereUniqueInput | StudentEvaluationWhereUniqueInput[]
    connect?: StudentEvaluationWhereUniqueInput | StudentEvaluationWhereUniqueInput[]
    update?: StudentEvaluationUpdateWithWhereUniqueWithoutEvaluationInput | StudentEvaluationUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: StudentEvaluationUpdateManyWithWhereWithoutEvaluationInput | StudentEvaluationUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: StudentEvaluationScalarWhereInput | StudentEvaluationScalarWhereInput[]
  }

  export type CompanyEvaluationUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<CompanyEvaluationCreateWithoutEvaluationInput, CompanyEvaluationUncheckedCreateWithoutEvaluationInput> | CompanyEvaluationCreateWithoutEvaluationInput[] | CompanyEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: CompanyEvaluationCreateOrConnectWithoutEvaluationInput | CompanyEvaluationCreateOrConnectWithoutEvaluationInput[]
    upsert?: CompanyEvaluationUpsertWithWhereUniqueWithoutEvaluationInput | CompanyEvaluationUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: CompanyEvaluationCreateManyEvaluationInputEnvelope
    set?: CompanyEvaluationWhereUniqueInput | CompanyEvaluationWhereUniqueInput[]
    disconnect?: CompanyEvaluationWhereUniqueInput | CompanyEvaluationWhereUniqueInput[]
    delete?: CompanyEvaluationWhereUniqueInput | CompanyEvaluationWhereUniqueInput[]
    connect?: CompanyEvaluationWhereUniqueInput | CompanyEvaluationWhereUniqueInput[]
    update?: CompanyEvaluationUpdateWithWhereUniqueWithoutEvaluationInput | CompanyEvaluationUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: CompanyEvaluationUpdateManyWithWhereWithoutEvaluationInput | CompanyEvaluationUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: CompanyEvaluationScalarWhereInput | CompanyEvaluationScalarWhereInput[]
  }

  export type StudentUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<StudentCreateWithoutEvaluationsInput, StudentUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEvaluationsInput
    upsert?: StudentUpsertWithoutEvaluationsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutEvaluationsInput, StudentUpdateWithoutEvaluationsInput>, StudentUncheckedUpdateWithoutEvaluationsInput>
  }

  export type InternshipUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<InternshipCreateWithoutEvaluationsInput, InternshipUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: InternshipCreateOrConnectWithoutEvaluationsInput
    upsert?: InternshipUpsertWithoutEvaluationsInput
    connect?: InternshipWhereUniqueInput
    update?: XOR<XOR<InternshipUpdateToOneWithWhereWithoutEvaluationsInput, InternshipUpdateWithoutEvaluationsInput>, InternshipUncheckedUpdateWithoutEvaluationsInput>
  }

  export type ReportEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<ReportEvaluationCreateWithoutEvaluationInput, ReportEvaluationUncheckedCreateWithoutEvaluationInput> | ReportEvaluationCreateWithoutEvaluationInput[] | ReportEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: ReportEvaluationCreateOrConnectWithoutEvaluationInput | ReportEvaluationCreateOrConnectWithoutEvaluationInput[]
    upsert?: ReportEvaluationUpsertWithWhereUniqueWithoutEvaluationInput | ReportEvaluationUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: ReportEvaluationCreateManyEvaluationInputEnvelope
    set?: ReportEvaluationWhereUniqueInput | ReportEvaluationWhereUniqueInput[]
    disconnect?: ReportEvaluationWhereUniqueInput | ReportEvaluationWhereUniqueInput[]
    delete?: ReportEvaluationWhereUniqueInput | ReportEvaluationWhereUniqueInput[]
    connect?: ReportEvaluationWhereUniqueInput | ReportEvaluationWhereUniqueInput[]
    update?: ReportEvaluationUpdateWithWhereUniqueWithoutEvaluationInput | ReportEvaluationUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: ReportEvaluationUpdateManyWithWhereWithoutEvaluationInput | ReportEvaluationUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: ReportEvaluationScalarWhereInput | ReportEvaluationScalarWhereInput[]
  }

  export type StudentEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<StudentEvaluationCreateWithoutEvaluationInput, StudentEvaluationUncheckedCreateWithoutEvaluationInput> | StudentEvaluationCreateWithoutEvaluationInput[] | StudentEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: StudentEvaluationCreateOrConnectWithoutEvaluationInput | StudentEvaluationCreateOrConnectWithoutEvaluationInput[]
    upsert?: StudentEvaluationUpsertWithWhereUniqueWithoutEvaluationInput | StudentEvaluationUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: StudentEvaluationCreateManyEvaluationInputEnvelope
    set?: StudentEvaluationWhereUniqueInput | StudentEvaluationWhereUniqueInput[]
    disconnect?: StudentEvaluationWhereUniqueInput | StudentEvaluationWhereUniqueInput[]
    delete?: StudentEvaluationWhereUniqueInput | StudentEvaluationWhereUniqueInput[]
    connect?: StudentEvaluationWhereUniqueInput | StudentEvaluationWhereUniqueInput[]
    update?: StudentEvaluationUpdateWithWhereUniqueWithoutEvaluationInput | StudentEvaluationUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: StudentEvaluationUpdateManyWithWhereWithoutEvaluationInput | StudentEvaluationUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: StudentEvaluationScalarWhereInput | StudentEvaluationScalarWhereInput[]
  }

  export type CompanyEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<CompanyEvaluationCreateWithoutEvaluationInput, CompanyEvaluationUncheckedCreateWithoutEvaluationInput> | CompanyEvaluationCreateWithoutEvaluationInput[] | CompanyEvaluationUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: CompanyEvaluationCreateOrConnectWithoutEvaluationInput | CompanyEvaluationCreateOrConnectWithoutEvaluationInput[]
    upsert?: CompanyEvaluationUpsertWithWhereUniqueWithoutEvaluationInput | CompanyEvaluationUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: CompanyEvaluationCreateManyEvaluationInputEnvelope
    set?: CompanyEvaluationWhereUniqueInput | CompanyEvaluationWhereUniqueInput[]
    disconnect?: CompanyEvaluationWhereUniqueInput | CompanyEvaluationWhereUniqueInput[]
    delete?: CompanyEvaluationWhereUniqueInput | CompanyEvaluationWhereUniqueInput[]
    connect?: CompanyEvaluationWhereUniqueInput | CompanyEvaluationWhereUniqueInput[]
    update?: CompanyEvaluationUpdateWithWhereUniqueWithoutEvaluationInput | CompanyEvaluationUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: CompanyEvaluationUpdateManyWithWhereWithoutEvaluationInput | CompanyEvaluationUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: CompanyEvaluationScalarWhereInput | CompanyEvaluationScalarWhereInput[]
  }

  export type EvaluationCreateNestedOneWithoutStudentEvalsInput = {
    create?: XOR<EvaluationCreateWithoutStudentEvalsInput, EvaluationUncheckedCreateWithoutStudentEvalsInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutStudentEvalsInput
    connect?: EvaluationWhereUniqueInput
  }

  export type EvaluationUpdateOneRequiredWithoutStudentEvalsNestedInput = {
    create?: XOR<EvaluationCreateWithoutStudentEvalsInput, EvaluationUncheckedCreateWithoutStudentEvalsInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutStudentEvalsInput
    upsert?: EvaluationUpsertWithoutStudentEvalsInput
    connect?: EvaluationWhereUniqueInput
    update?: XOR<XOR<EvaluationUpdateToOneWithWhereWithoutStudentEvalsInput, EvaluationUpdateWithoutStudentEvalsInput>, EvaluationUncheckedUpdateWithoutStudentEvalsInput>
  }

  export type EvaluationCreateNestedOneWithoutCompanyEvalsInput = {
    create?: XOR<EvaluationCreateWithoutCompanyEvalsInput, EvaluationUncheckedCreateWithoutCompanyEvalsInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutCompanyEvalsInput
    connect?: EvaluationWhereUniqueInput
  }

  export type EvaluationUpdateOneRequiredWithoutCompanyEvalsNestedInput = {
    create?: XOR<EvaluationCreateWithoutCompanyEvalsInput, EvaluationUncheckedCreateWithoutCompanyEvalsInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutCompanyEvalsInput
    upsert?: EvaluationUpsertWithoutCompanyEvalsInput
    connect?: EvaluationWhereUniqueInput
    update?: XOR<XOR<EvaluationUpdateToOneWithWhereWithoutCompanyEvalsInput, EvaluationUpdateWithoutCompanyEvalsInput>, EvaluationUncheckedUpdateWithoutCompanyEvalsInput>
  }

  export type SoutenanceEvaluationCreateNestedManyWithoutSoutenanceInput = {
    create?: XOR<SoutenanceEvaluationCreateWithoutSoutenanceInput, SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput> | SoutenanceEvaluationCreateWithoutSoutenanceInput[] | SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: SoutenanceEvaluationCreateOrConnectWithoutSoutenanceInput | SoutenanceEvaluationCreateOrConnectWithoutSoutenanceInput[]
    createMany?: SoutenanceEvaluationCreateManySoutenanceInputEnvelope
    connect?: SoutenanceEvaluationWhereUniqueInput | SoutenanceEvaluationWhereUniqueInput[]
  }

  export type SoutenanceEvaluationUncheckedCreateNestedManyWithoutSoutenanceInput = {
    create?: XOR<SoutenanceEvaluationCreateWithoutSoutenanceInput, SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput> | SoutenanceEvaluationCreateWithoutSoutenanceInput[] | SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: SoutenanceEvaluationCreateOrConnectWithoutSoutenanceInput | SoutenanceEvaluationCreateOrConnectWithoutSoutenanceInput[]
    createMany?: SoutenanceEvaluationCreateManySoutenanceInputEnvelope
    connect?: SoutenanceEvaluationWhereUniqueInput | SoutenanceEvaluationWhereUniqueInput[]
  }

  export type SoutenanceEvaluationUpdateManyWithoutSoutenanceNestedInput = {
    create?: XOR<SoutenanceEvaluationCreateWithoutSoutenanceInput, SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput> | SoutenanceEvaluationCreateWithoutSoutenanceInput[] | SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: SoutenanceEvaluationCreateOrConnectWithoutSoutenanceInput | SoutenanceEvaluationCreateOrConnectWithoutSoutenanceInput[]
    upsert?: SoutenanceEvaluationUpsertWithWhereUniqueWithoutSoutenanceInput | SoutenanceEvaluationUpsertWithWhereUniqueWithoutSoutenanceInput[]
    createMany?: SoutenanceEvaluationCreateManySoutenanceInputEnvelope
    set?: SoutenanceEvaluationWhereUniqueInput | SoutenanceEvaluationWhereUniqueInput[]
    disconnect?: SoutenanceEvaluationWhereUniqueInput | SoutenanceEvaluationWhereUniqueInput[]
    delete?: SoutenanceEvaluationWhereUniqueInput | SoutenanceEvaluationWhereUniqueInput[]
    connect?: SoutenanceEvaluationWhereUniqueInput | SoutenanceEvaluationWhereUniqueInput[]
    update?: SoutenanceEvaluationUpdateWithWhereUniqueWithoutSoutenanceInput | SoutenanceEvaluationUpdateWithWhereUniqueWithoutSoutenanceInput[]
    updateMany?: SoutenanceEvaluationUpdateManyWithWhereWithoutSoutenanceInput | SoutenanceEvaluationUpdateManyWithWhereWithoutSoutenanceInput[]
    deleteMany?: SoutenanceEvaluationScalarWhereInput | SoutenanceEvaluationScalarWhereInput[]
  }

  export type SoutenanceEvaluationUncheckedUpdateManyWithoutSoutenanceNestedInput = {
    create?: XOR<SoutenanceEvaluationCreateWithoutSoutenanceInput, SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput> | SoutenanceEvaluationCreateWithoutSoutenanceInput[] | SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: SoutenanceEvaluationCreateOrConnectWithoutSoutenanceInput | SoutenanceEvaluationCreateOrConnectWithoutSoutenanceInput[]
    upsert?: SoutenanceEvaluationUpsertWithWhereUniqueWithoutSoutenanceInput | SoutenanceEvaluationUpsertWithWhereUniqueWithoutSoutenanceInput[]
    createMany?: SoutenanceEvaluationCreateManySoutenanceInputEnvelope
    set?: SoutenanceEvaluationWhereUniqueInput | SoutenanceEvaluationWhereUniqueInput[]
    disconnect?: SoutenanceEvaluationWhereUniqueInput | SoutenanceEvaluationWhereUniqueInput[]
    delete?: SoutenanceEvaluationWhereUniqueInput | SoutenanceEvaluationWhereUniqueInput[]
    connect?: SoutenanceEvaluationWhereUniqueInput | SoutenanceEvaluationWhereUniqueInput[]
    update?: SoutenanceEvaluationUpdateWithWhereUniqueWithoutSoutenanceInput | SoutenanceEvaluationUpdateWithWhereUniqueWithoutSoutenanceInput[]
    updateMany?: SoutenanceEvaluationUpdateManyWithWhereWithoutSoutenanceInput | SoutenanceEvaluationUpdateManyWithWhereWithoutSoutenanceInput[]
    deleteMany?: SoutenanceEvaluationScalarWhereInput | SoutenanceEvaluationScalarWhereInput[]
  }

  export type SoutenanceCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<SoutenanceCreateWithoutEvaluationsInput, SoutenanceUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: SoutenanceCreateOrConnectWithoutEvaluationsInput
    connect?: SoutenanceWhereUniqueInput
  }

  export type SoutenanceUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<SoutenanceCreateWithoutEvaluationsInput, SoutenanceUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: SoutenanceCreateOrConnectWithoutEvaluationsInput
    upsert?: SoutenanceUpsertWithoutEvaluationsInput
    connect?: SoutenanceWhereUniqueInput
    update?: XOR<XOR<SoutenanceUpdateToOneWithWhereWithoutEvaluationsInput, SoutenanceUpdateWithoutEvaluationsInput>, SoutenanceUncheckedUpdateWithoutEvaluationsInput>
  }

  export type EvaluationCreateNestedOneWithoutReportEvaluationInput = {
    create?: XOR<EvaluationCreateWithoutReportEvaluationInput, EvaluationUncheckedCreateWithoutReportEvaluationInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutReportEvaluationInput
    connect?: EvaluationWhereUniqueInput
  }

  export type EvaluationUpdateOneRequiredWithoutReportEvaluationNestedInput = {
    create?: XOR<EvaluationCreateWithoutReportEvaluationInput, EvaluationUncheckedCreateWithoutReportEvaluationInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutReportEvaluationInput
    upsert?: EvaluationUpsertWithoutReportEvaluationInput
    connect?: EvaluationWhereUniqueInput
    update?: XOR<XOR<EvaluationUpdateToOneWithWhereWithoutReportEvaluationInput, EvaluationUpdateWithoutReportEvaluationInput>, EvaluationUncheckedUpdateWithoutReportEvaluationInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AdminCreateWithoutUserInput = {
    adminId: string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: number
    adminId: string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type StudentCreateWithoutUserInput = {
    promotion: string
    internship?: InternshipCreateNestedOneWithoutStudentInput
    evaluations?: EvaluationCreateNestedManyWithoutStudentInput
    academicTutor?: AcademicTutorCreateNestedOneWithoutStudentsInput
    enterpriseTutor?: EnterpriseTutorCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: number
    promotion: string
    internshipId?: number | null
    academicTutorId?: number | null
    enterpriseTutorId?: number | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type TutorCreateWithoutUserInput = {
    academicTutors?: AcademicTutorCreateNestedManyWithoutTutorInput
    enterpriseTutors?: EnterpriseTutorCreateNestedManyWithoutTutorInput
  }

  export type TutorUncheckedCreateWithoutUserInput = {
    id?: number
    academicTutors?: AcademicTutorUncheckedCreateNestedManyWithoutTutorInput
    enterpriseTutors?: EnterpriseTutorUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutorCreateOrConnectWithoutUserInput = {
    where: TutorWhereUniqueInput
    create: XOR<TutorCreateWithoutUserInput, TutorUncheckedCreateWithoutUserInput>
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    promotion?: StringFieldUpdateOperationsInput | string
    internship?: InternshipUpdateOneWithoutStudentNestedInput
    evaluations?: EvaluationUpdateManyWithoutStudentNestedInput
    academicTutor?: AcademicTutorUpdateOneWithoutStudentsNestedInput
    enterpriseTutor?: EnterpriseTutorUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotion?: StringFieldUpdateOperationsInput | string
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    academicTutorId?: NullableIntFieldUpdateOperationsInput | number | null
    enterpriseTutorId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TutorUpsertWithoutUserInput = {
    update: XOR<TutorUpdateWithoutUserInput, TutorUncheckedUpdateWithoutUserInput>
    create: XOR<TutorCreateWithoutUserInput, TutorUncheckedCreateWithoutUserInput>
    where?: TutorWhereInput
  }

  export type TutorUpdateToOneWithWhereWithoutUserInput = {
    where?: TutorWhereInput
    data: XOR<TutorUpdateWithoutUserInput, TutorUncheckedUpdateWithoutUserInput>
  }

  export type TutorUpdateWithoutUserInput = {
    academicTutors?: AcademicTutorUpdateManyWithoutTutorNestedInput
    enterpriseTutors?: EnterpriseTutorUpdateManyWithoutTutorNestedInput
  }

  export type TutorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    academicTutors?: AcademicTutorUncheckedUpdateManyWithoutTutorNestedInput
    enterpriseTutors?: EnterpriseTutorUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type UserCreateWithoutAdminInput = {
    firstName: string
    lastName: string
    password: string
    email: string
    role: string
    student?: StudentCreateNestedOneWithoutUserInput
    tutor?: TutorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: number
    firstName: string
    lastName: string
    password: string
    email: string
    role: string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    tutor?: TutorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneWithoutUserNestedInput
    tutor?: TutorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    tutor?: TutorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutStudentInput = {
    firstName: string
    lastName: string
    password: string
    email: string
    role: string
    admin?: AdminCreateNestedOneWithoutUserInput
    tutor?: TutorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: number
    firstName: string
    lastName: string
    password: string
    email: string
    role: string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    tutor?: TutorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type InternshipCreateWithoutStudentInput = {
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    tutorId: number
    evaluations?: EvaluationCreateNestedManyWithoutInternshipInput
    company: CompanyCreateNestedOneWithoutInternshipsInput
    documents?: DocumentCreateNestedManyWithoutInternshipInput
  }

  export type InternshipUncheckedCreateWithoutStudentInput = {
    id?: number
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    companyId: number
    tutorId: number
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutInternshipInput
    documents?: DocumentUncheckedCreateNestedManyWithoutInternshipInput
  }

  export type InternshipCreateOrConnectWithoutStudentInput = {
    where: InternshipWhereUniqueInput
    create: XOR<InternshipCreateWithoutStudentInput, InternshipUncheckedCreateWithoutStudentInput>
  }

  export type EvaluationCreateWithoutStudentInput = {
    evaluation: string
    submissionDate: Date | string
    factor: number
    ReportEvaluation?: ReportEvaluationCreateNestedManyWithoutEvaluationInput
    studentEvals?: StudentEvaluationCreateNestedManyWithoutEvaluationInput
    companyEvals?: CompanyEvaluationCreateNestedManyWithoutEvaluationInput
    Internship: InternshipCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutStudentInput = {
    id?: number
    evaluation: string
    submissionDate: Date | string
    factor: number
    internshipId: number
    ReportEvaluation?: ReportEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
    studentEvals?: StudentEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
    companyEvals?: CompanyEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutStudentInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutStudentInput, EvaluationUncheckedCreateWithoutStudentInput>
  }

  export type EvaluationCreateManyStudentInputEnvelope = {
    data: EvaluationCreateManyStudentInput | EvaluationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AcademicTutorCreateWithoutStudentsInput = {
    tutor: TutorCreateNestedOneWithoutAcademicTutorsInput
  }

  export type AcademicTutorUncheckedCreateWithoutStudentsInput = {
    id?: number
    tutorId: number
  }

  export type AcademicTutorCreateOrConnectWithoutStudentsInput = {
    where: AcademicTutorWhereUniqueInput
    create: XOR<AcademicTutorCreateWithoutStudentsInput, AcademicTutorUncheckedCreateWithoutStudentsInput>
  }

  export type EnterpriseTutorCreateWithoutStudentsInput = {
    tutor: TutorCreateNestedOneWithoutEnterpriseTutorsInput
  }

  export type EnterpriseTutorUncheckedCreateWithoutStudentsInput = {
    id?: number
    tutorId: number
  }

  export type EnterpriseTutorCreateOrConnectWithoutStudentsInput = {
    where: EnterpriseTutorWhereUniqueInput
    create: XOR<EnterpriseTutorCreateWithoutStudentsInput, EnterpriseTutorUncheckedCreateWithoutStudentsInput>
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    tutor?: TutorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    tutor?: TutorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type InternshipUpsertWithoutStudentInput = {
    update: XOR<InternshipUpdateWithoutStudentInput, InternshipUncheckedUpdateWithoutStudentInput>
    create: XOR<InternshipCreateWithoutStudentInput, InternshipUncheckedCreateWithoutStudentInput>
    where?: InternshipWhereInput
  }

  export type InternshipUpdateToOneWithWhereWithoutStudentInput = {
    where?: InternshipWhereInput
    data: XOR<InternshipUpdateWithoutStudentInput, InternshipUncheckedUpdateWithoutStudentInput>
  }

  export type InternshipUpdateWithoutStudentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    evaluations?: EvaluationUpdateManyWithoutInternshipNestedInput
    company?: CompanyUpdateOneRequiredWithoutInternshipsNestedInput
    documents?: DocumentUpdateManyWithoutInternshipNestedInput
  }

  export type InternshipUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    evaluations?: EvaluationUncheckedUpdateManyWithoutInternshipNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutInternshipNestedInput
  }

  export type EvaluationUpsertWithWhereUniqueWithoutStudentInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutStudentInput, EvaluationUncheckedUpdateWithoutStudentInput>
    create: XOR<EvaluationCreateWithoutStudentInput, EvaluationUncheckedCreateWithoutStudentInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutStudentInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutStudentInput, EvaluationUncheckedUpdateWithoutStudentInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutStudentInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutStudentInput>
  }

  export type EvaluationScalarWhereInput = {
    AND?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    OR?: EvaluationScalarWhereInput[]
    NOT?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    id?: IntFilter<"Evaluation"> | number
    evaluation?: StringFilter<"Evaluation"> | string
    submissionDate?: DateTimeFilter<"Evaluation"> | Date | string
    factor?: IntFilter<"Evaluation"> | number
    internshipId?: IntFilter<"Evaluation"> | number
    studentId?: IntNullableFilter<"Evaluation"> | number | null
  }

  export type AcademicTutorUpsertWithoutStudentsInput = {
    update: XOR<AcademicTutorUpdateWithoutStudentsInput, AcademicTutorUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcademicTutorCreateWithoutStudentsInput, AcademicTutorUncheckedCreateWithoutStudentsInput>
    where?: AcademicTutorWhereInput
  }

  export type AcademicTutorUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AcademicTutorWhereInput
    data: XOR<AcademicTutorUpdateWithoutStudentsInput, AcademicTutorUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicTutorUpdateWithoutStudentsInput = {
    tutor?: TutorUpdateOneRequiredWithoutAcademicTutorsNestedInput
  }

  export type AcademicTutorUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
  }

  export type EnterpriseTutorUpsertWithoutStudentsInput = {
    update: XOR<EnterpriseTutorUpdateWithoutStudentsInput, EnterpriseTutorUncheckedUpdateWithoutStudentsInput>
    create: XOR<EnterpriseTutorCreateWithoutStudentsInput, EnterpriseTutorUncheckedCreateWithoutStudentsInput>
    where?: EnterpriseTutorWhereInput
  }

  export type EnterpriseTutorUpdateToOneWithWhereWithoutStudentsInput = {
    where?: EnterpriseTutorWhereInput
    data: XOR<EnterpriseTutorUpdateWithoutStudentsInput, EnterpriseTutorUncheckedUpdateWithoutStudentsInput>
  }

  export type EnterpriseTutorUpdateWithoutStudentsInput = {
    tutor?: TutorUpdateOneRequiredWithoutEnterpriseTutorsNestedInput
  }

  export type EnterpriseTutorUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutTutorInput = {
    firstName: string
    lastName: string
    password: string
    email: string
    role: string
    admin?: AdminCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTutorInput = {
    id?: number
    firstName: string
    lastName: string
    password: string
    email: string
    role: string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTutorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTutorInput, UserUncheckedCreateWithoutTutorInput>
  }

  export type AcademicTutorCreateWithoutTutorInput = {
    students?: StudentCreateNestedManyWithoutAcademicTutorInput
  }

  export type AcademicTutorUncheckedCreateWithoutTutorInput = {
    id?: number
    students?: StudentUncheckedCreateNestedManyWithoutAcademicTutorInput
  }

  export type AcademicTutorCreateOrConnectWithoutTutorInput = {
    where: AcademicTutorWhereUniqueInput
    create: XOR<AcademicTutorCreateWithoutTutorInput, AcademicTutorUncheckedCreateWithoutTutorInput>
  }

  export type AcademicTutorCreateManyTutorInputEnvelope = {
    data: AcademicTutorCreateManyTutorInput | AcademicTutorCreateManyTutorInput[]
    skipDuplicates?: boolean
  }

  export type EnterpriseTutorCreateWithoutTutorInput = {
    students?: StudentCreateNestedManyWithoutEnterpriseTutorInput
  }

  export type EnterpriseTutorUncheckedCreateWithoutTutorInput = {
    id?: number
    students?: StudentUncheckedCreateNestedManyWithoutEnterpriseTutorInput
  }

  export type EnterpriseTutorCreateOrConnectWithoutTutorInput = {
    where: EnterpriseTutorWhereUniqueInput
    create: XOR<EnterpriseTutorCreateWithoutTutorInput, EnterpriseTutorUncheckedCreateWithoutTutorInput>
  }

  export type EnterpriseTutorCreateManyTutorInputEnvelope = {
    data: EnterpriseTutorCreateManyTutorInput | EnterpriseTutorCreateManyTutorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTutorInput = {
    update: XOR<UserUpdateWithoutTutorInput, UserUncheckedUpdateWithoutTutorInput>
    create: XOR<UserCreateWithoutTutorInput, UserUncheckedCreateWithoutTutorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTutorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTutorInput, UserUncheckedUpdateWithoutTutorInput>
  }

  export type UserUpdateWithoutTutorInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AcademicTutorUpsertWithWhereUniqueWithoutTutorInput = {
    where: AcademicTutorWhereUniqueInput
    update: XOR<AcademicTutorUpdateWithoutTutorInput, AcademicTutorUncheckedUpdateWithoutTutorInput>
    create: XOR<AcademicTutorCreateWithoutTutorInput, AcademicTutorUncheckedCreateWithoutTutorInput>
  }

  export type AcademicTutorUpdateWithWhereUniqueWithoutTutorInput = {
    where: AcademicTutorWhereUniqueInput
    data: XOR<AcademicTutorUpdateWithoutTutorInput, AcademicTutorUncheckedUpdateWithoutTutorInput>
  }

  export type AcademicTutorUpdateManyWithWhereWithoutTutorInput = {
    where: AcademicTutorScalarWhereInput
    data: XOR<AcademicTutorUpdateManyMutationInput, AcademicTutorUncheckedUpdateManyWithoutTutorInput>
  }

  export type AcademicTutorScalarWhereInput = {
    AND?: AcademicTutorScalarWhereInput | AcademicTutorScalarWhereInput[]
    OR?: AcademicTutorScalarWhereInput[]
    NOT?: AcademicTutorScalarWhereInput | AcademicTutorScalarWhereInput[]
    id?: IntFilter<"AcademicTutor"> | number
    tutorId?: IntFilter<"AcademicTutor"> | number
  }

  export type EnterpriseTutorUpsertWithWhereUniqueWithoutTutorInput = {
    where: EnterpriseTutorWhereUniqueInput
    update: XOR<EnterpriseTutorUpdateWithoutTutorInput, EnterpriseTutorUncheckedUpdateWithoutTutorInput>
    create: XOR<EnterpriseTutorCreateWithoutTutorInput, EnterpriseTutorUncheckedCreateWithoutTutorInput>
  }

  export type EnterpriseTutorUpdateWithWhereUniqueWithoutTutorInput = {
    where: EnterpriseTutorWhereUniqueInput
    data: XOR<EnterpriseTutorUpdateWithoutTutorInput, EnterpriseTutorUncheckedUpdateWithoutTutorInput>
  }

  export type EnterpriseTutorUpdateManyWithWhereWithoutTutorInput = {
    where: EnterpriseTutorScalarWhereInput
    data: XOR<EnterpriseTutorUpdateManyMutationInput, EnterpriseTutorUncheckedUpdateManyWithoutTutorInput>
  }

  export type EnterpriseTutorScalarWhereInput = {
    AND?: EnterpriseTutorScalarWhereInput | EnterpriseTutorScalarWhereInput[]
    OR?: EnterpriseTutorScalarWhereInput[]
    NOT?: EnterpriseTutorScalarWhereInput | EnterpriseTutorScalarWhereInput[]
    id?: IntFilter<"EnterpriseTutor"> | number
    tutorId?: IntFilter<"EnterpriseTutor"> | number
  }

  export type TutorCreateWithoutAcademicTutorsInput = {
    user: UserCreateNestedOneWithoutTutorInput
    enterpriseTutors?: EnterpriseTutorCreateNestedManyWithoutTutorInput
  }

  export type TutorUncheckedCreateWithoutAcademicTutorsInput = {
    id?: number
    userId: number
    enterpriseTutors?: EnterpriseTutorUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutorCreateOrConnectWithoutAcademicTutorsInput = {
    where: TutorWhereUniqueInput
    create: XOR<TutorCreateWithoutAcademicTutorsInput, TutorUncheckedCreateWithoutAcademicTutorsInput>
  }

  export type StudentCreateWithoutAcademicTutorInput = {
    promotion: string
    user: UserCreateNestedOneWithoutStudentInput
    internship?: InternshipCreateNestedOneWithoutStudentInput
    evaluations?: EvaluationCreateNestedManyWithoutStudentInput
    enterpriseTutor?: EnterpriseTutorCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutAcademicTutorInput = {
    id?: number
    promotion: string
    userId: number
    internshipId?: number | null
    enterpriseTutorId?: number | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicTutorInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicTutorInput, StudentUncheckedCreateWithoutAcademicTutorInput>
  }

  export type StudentCreateManyAcademicTutorInputEnvelope = {
    data: StudentCreateManyAcademicTutorInput | StudentCreateManyAcademicTutorInput[]
    skipDuplicates?: boolean
  }

  export type TutorUpsertWithoutAcademicTutorsInput = {
    update: XOR<TutorUpdateWithoutAcademicTutorsInput, TutorUncheckedUpdateWithoutAcademicTutorsInput>
    create: XOR<TutorCreateWithoutAcademicTutorsInput, TutorUncheckedCreateWithoutAcademicTutorsInput>
    where?: TutorWhereInput
  }

  export type TutorUpdateToOneWithWhereWithoutAcademicTutorsInput = {
    where?: TutorWhereInput
    data: XOR<TutorUpdateWithoutAcademicTutorsInput, TutorUncheckedUpdateWithoutAcademicTutorsInput>
  }

  export type TutorUpdateWithoutAcademicTutorsInput = {
    user?: UserUpdateOneRequiredWithoutTutorNestedInput
    enterpriseTutors?: EnterpriseTutorUpdateManyWithoutTutorNestedInput
  }

  export type TutorUncheckedUpdateWithoutAcademicTutorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    enterpriseTutors?: EnterpriseTutorUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutAcademicTutorInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutAcademicTutorInput, StudentUncheckedUpdateWithoutAcademicTutorInput>
    create: XOR<StudentCreateWithoutAcademicTutorInput, StudentUncheckedCreateWithoutAcademicTutorInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutAcademicTutorInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutAcademicTutorInput, StudentUncheckedUpdateWithoutAcademicTutorInput>
  }

  export type StudentUpdateManyWithWhereWithoutAcademicTutorInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutAcademicTutorInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: IntFilter<"Student"> | number
    promotion?: StringFilter<"Student"> | string
    userId?: IntFilter<"Student"> | number
    internshipId?: IntNullableFilter<"Student"> | number | null
    academicTutorId?: IntNullableFilter<"Student"> | number | null
    enterpriseTutorId?: IntNullableFilter<"Student"> | number | null
  }

  export type TutorCreateWithoutEnterpriseTutorsInput = {
    user: UserCreateNestedOneWithoutTutorInput
    academicTutors?: AcademicTutorCreateNestedManyWithoutTutorInput
  }

  export type TutorUncheckedCreateWithoutEnterpriseTutorsInput = {
    id?: number
    userId: number
    academicTutors?: AcademicTutorUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutorCreateOrConnectWithoutEnterpriseTutorsInput = {
    where: TutorWhereUniqueInput
    create: XOR<TutorCreateWithoutEnterpriseTutorsInput, TutorUncheckedCreateWithoutEnterpriseTutorsInput>
  }

  export type StudentCreateWithoutEnterpriseTutorInput = {
    promotion: string
    user: UserCreateNestedOneWithoutStudentInput
    internship?: InternshipCreateNestedOneWithoutStudentInput
    evaluations?: EvaluationCreateNestedManyWithoutStudentInput
    academicTutor?: AcademicTutorCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutEnterpriseTutorInput = {
    id?: number
    promotion: string
    userId: number
    internshipId?: number | null
    academicTutorId?: number | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEnterpriseTutorInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEnterpriseTutorInput, StudentUncheckedCreateWithoutEnterpriseTutorInput>
  }

  export type StudentCreateManyEnterpriseTutorInputEnvelope = {
    data: StudentCreateManyEnterpriseTutorInput | StudentCreateManyEnterpriseTutorInput[]
    skipDuplicates?: boolean
  }

  export type TutorUpsertWithoutEnterpriseTutorsInput = {
    update: XOR<TutorUpdateWithoutEnterpriseTutorsInput, TutorUncheckedUpdateWithoutEnterpriseTutorsInput>
    create: XOR<TutorCreateWithoutEnterpriseTutorsInput, TutorUncheckedCreateWithoutEnterpriseTutorsInput>
    where?: TutorWhereInput
  }

  export type TutorUpdateToOneWithWhereWithoutEnterpriseTutorsInput = {
    where?: TutorWhereInput
    data: XOR<TutorUpdateWithoutEnterpriseTutorsInput, TutorUncheckedUpdateWithoutEnterpriseTutorsInput>
  }

  export type TutorUpdateWithoutEnterpriseTutorsInput = {
    user?: UserUpdateOneRequiredWithoutTutorNestedInput
    academicTutors?: AcademicTutorUpdateManyWithoutTutorNestedInput
  }

  export type TutorUncheckedUpdateWithoutEnterpriseTutorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    academicTutors?: AcademicTutorUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutEnterpriseTutorInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutEnterpriseTutorInput, StudentUncheckedUpdateWithoutEnterpriseTutorInput>
    create: XOR<StudentCreateWithoutEnterpriseTutorInput, StudentUncheckedCreateWithoutEnterpriseTutorInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutEnterpriseTutorInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutEnterpriseTutorInput, StudentUncheckedUpdateWithoutEnterpriseTutorInput>
  }

  export type StudentUpdateManyWithWhereWithoutEnterpriseTutorInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutEnterpriseTutorInput>
  }

  export type InternshipCreateWithoutCompanyInput = {
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    tutorId: number
    evaluations?: EvaluationCreateNestedManyWithoutInternshipInput
    documents?: DocumentCreateNestedManyWithoutInternshipInput
    student?: StudentCreateNestedOneWithoutInternshipInput
  }

  export type InternshipUncheckedCreateWithoutCompanyInput = {
    id?: number
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    tutorId: number
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutInternshipInput
    documents?: DocumentUncheckedCreateNestedManyWithoutInternshipInput
    student?: StudentUncheckedCreateNestedOneWithoutInternshipInput
  }

  export type InternshipCreateOrConnectWithoutCompanyInput = {
    where: InternshipWhereUniqueInput
    create: XOR<InternshipCreateWithoutCompanyInput, InternshipUncheckedCreateWithoutCompanyInput>
  }

  export type InternshipCreateManyCompanyInputEnvelope = {
    data: InternshipCreateManyCompanyInput | InternshipCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type InternshipUpsertWithWhereUniqueWithoutCompanyInput = {
    where: InternshipWhereUniqueInput
    update: XOR<InternshipUpdateWithoutCompanyInput, InternshipUncheckedUpdateWithoutCompanyInput>
    create: XOR<InternshipCreateWithoutCompanyInput, InternshipUncheckedCreateWithoutCompanyInput>
  }

  export type InternshipUpdateWithWhereUniqueWithoutCompanyInput = {
    where: InternshipWhereUniqueInput
    data: XOR<InternshipUpdateWithoutCompanyInput, InternshipUncheckedUpdateWithoutCompanyInput>
  }

  export type InternshipUpdateManyWithWhereWithoutCompanyInput = {
    where: InternshipScalarWhereInput
    data: XOR<InternshipUpdateManyMutationInput, InternshipUncheckedUpdateManyWithoutCompanyInput>
  }

  export type InternshipScalarWhereInput = {
    AND?: InternshipScalarWhereInput | InternshipScalarWhereInput[]
    OR?: InternshipScalarWhereInput[]
    NOT?: InternshipScalarWhereInput | InternshipScalarWhereInput[]
    id?: IntFilter<"Internship"> | number
    title?: StringFilter<"Internship"> | string
    description?: StringFilter<"Internship"> | string
    startDate?: DateTimeFilter<"Internship"> | Date | string
    endDate?: DateTimeFilter<"Internship"> | Date | string
    salary?: IntFilter<"Internship"> | number
    companyId?: IntFilter<"Internship"> | number
    tutorId?: IntFilter<"Internship"> | number
  }

  export type EvaluationCreateWithoutInternshipInput = {
    evaluation: string
    submissionDate: Date | string
    factor: number
    ReportEvaluation?: ReportEvaluationCreateNestedManyWithoutEvaluationInput
    studentEvals?: StudentEvaluationCreateNestedManyWithoutEvaluationInput
    companyEvals?: CompanyEvaluationCreateNestedManyWithoutEvaluationInput
    Student?: StudentCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutInternshipInput = {
    id?: number
    evaluation: string
    submissionDate: Date | string
    factor: number
    studentId?: number | null
    ReportEvaluation?: ReportEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
    studentEvals?: StudentEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
    companyEvals?: CompanyEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutInternshipInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutInternshipInput, EvaluationUncheckedCreateWithoutInternshipInput>
  }

  export type EvaluationCreateManyInternshipInputEnvelope = {
    data: EvaluationCreateManyInternshipInput | EvaluationCreateManyInternshipInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutInternshipsInput = {
    name: string
  }

  export type CompanyUncheckedCreateWithoutInternshipsInput = {
    id?: number
    name: string
  }

  export type CompanyCreateOrConnectWithoutInternshipsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInternshipsInput, CompanyUncheckedCreateWithoutInternshipsInput>
  }

  export type DocumentCreateWithoutInternshipInput = {
    id?: string
    fileName?: string
    filePath?: string
    fileType?: string
    fileSize?: number | null
    documentType?: string
    CdC?: CdCCreateNestedManyWithoutDocumentInput
    Report?: ReportCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutInternshipInput = {
    id?: string
    fileName?: string
    filePath?: string
    fileType?: string
    fileSize?: number | null
    documentType?: string
    CdC?: CdCUncheckedCreateNestedManyWithoutDocumentInput
    Report?: ReportUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutInternshipInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutInternshipInput, DocumentUncheckedCreateWithoutInternshipInput>
  }

  export type DocumentCreateManyInternshipInputEnvelope = {
    data: DocumentCreateManyInternshipInput | DocumentCreateManyInternshipInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutInternshipInput = {
    promotion: string
    user: UserCreateNestedOneWithoutStudentInput
    evaluations?: EvaluationCreateNestedManyWithoutStudentInput
    academicTutor?: AcademicTutorCreateNestedOneWithoutStudentsInput
    enterpriseTutor?: EnterpriseTutorCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutInternshipInput = {
    id?: number
    promotion: string
    userId: number
    academicTutorId?: number | null
    enterpriseTutorId?: number | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutInternshipInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutInternshipInput, StudentUncheckedCreateWithoutInternshipInput>
  }

  export type EvaluationUpsertWithWhereUniqueWithoutInternshipInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutInternshipInput, EvaluationUncheckedUpdateWithoutInternshipInput>
    create: XOR<EvaluationCreateWithoutInternshipInput, EvaluationUncheckedCreateWithoutInternshipInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutInternshipInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutInternshipInput, EvaluationUncheckedUpdateWithoutInternshipInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutInternshipInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutInternshipInput>
  }

  export type CompanyUpsertWithoutInternshipsInput = {
    update: XOR<CompanyUpdateWithoutInternshipsInput, CompanyUncheckedUpdateWithoutInternshipsInput>
    create: XOR<CompanyCreateWithoutInternshipsInput, CompanyUncheckedCreateWithoutInternshipsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInternshipsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInternshipsInput, CompanyUncheckedUpdateWithoutInternshipsInput>
  }

  export type CompanyUpdateWithoutInternshipsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUncheckedUpdateWithoutInternshipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutInternshipInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutInternshipInput, DocumentUncheckedUpdateWithoutInternshipInput>
    create: XOR<DocumentCreateWithoutInternshipInput, DocumentUncheckedCreateWithoutInternshipInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutInternshipInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutInternshipInput, DocumentUncheckedUpdateWithoutInternshipInput>
  }

  export type DocumentUpdateManyWithWhereWithoutInternshipInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutInternshipInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    documentType?: StringFilter<"Document"> | string
    internshipId?: IntNullableFilter<"Document"> | number | null
  }

  export type StudentUpsertWithoutInternshipInput = {
    update: XOR<StudentUpdateWithoutInternshipInput, StudentUncheckedUpdateWithoutInternshipInput>
    create: XOR<StudentCreateWithoutInternshipInput, StudentUncheckedCreateWithoutInternshipInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutInternshipInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutInternshipInput, StudentUncheckedUpdateWithoutInternshipInput>
  }

  export type StudentUpdateWithoutInternshipInput = {
    promotion?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    evaluations?: EvaluationUpdateManyWithoutStudentNestedInput
    academicTutor?: AcademicTutorUpdateOneWithoutStudentsNestedInput
    enterpriseTutor?: EnterpriseTutorUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutInternshipInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotion?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    academicTutorId?: NullableIntFieldUpdateOperationsInput | number | null
    enterpriseTutorId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CdCCreateWithoutDocumentInput = {
    file: string
  }

  export type CdCUncheckedCreateWithoutDocumentInput = {
    id?: number
    file: string
  }

  export type CdCCreateOrConnectWithoutDocumentInput = {
    where: CdCWhereUniqueInput
    create: XOR<CdCCreateWithoutDocumentInput, CdCUncheckedCreateWithoutDocumentInput>
  }

  export type CdCCreateManyDocumentInputEnvelope = {
    data: CdCCreateManyDocumentInput | CdCCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutDocumentInput = {
    file: string
  }

  export type ReportUncheckedCreateWithoutDocumentInput = {
    id?: number
    file: string
  }

  export type ReportCreateOrConnectWithoutDocumentInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutDocumentInput, ReportUncheckedCreateWithoutDocumentInput>
  }

  export type ReportCreateManyDocumentInputEnvelope = {
    data: ReportCreateManyDocumentInput | ReportCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type InternshipCreateWithoutDocumentsInput = {
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    tutorId: number
    evaluations?: EvaluationCreateNestedManyWithoutInternshipInput
    company: CompanyCreateNestedOneWithoutInternshipsInput
    student?: StudentCreateNestedOneWithoutInternshipInput
  }

  export type InternshipUncheckedCreateWithoutDocumentsInput = {
    id?: number
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    companyId: number
    tutorId: number
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutInternshipInput
    student?: StudentUncheckedCreateNestedOneWithoutInternshipInput
  }

  export type InternshipCreateOrConnectWithoutDocumentsInput = {
    where: InternshipWhereUniqueInput
    create: XOR<InternshipCreateWithoutDocumentsInput, InternshipUncheckedCreateWithoutDocumentsInput>
  }

  export type CdCUpsertWithWhereUniqueWithoutDocumentInput = {
    where: CdCWhereUniqueInput
    update: XOR<CdCUpdateWithoutDocumentInput, CdCUncheckedUpdateWithoutDocumentInput>
    create: XOR<CdCCreateWithoutDocumentInput, CdCUncheckedCreateWithoutDocumentInput>
  }

  export type CdCUpdateWithWhereUniqueWithoutDocumentInput = {
    where: CdCWhereUniqueInput
    data: XOR<CdCUpdateWithoutDocumentInput, CdCUncheckedUpdateWithoutDocumentInput>
  }

  export type CdCUpdateManyWithWhereWithoutDocumentInput = {
    where: CdCScalarWhereInput
    data: XOR<CdCUpdateManyMutationInput, CdCUncheckedUpdateManyWithoutDocumentInput>
  }

  export type CdCScalarWhereInput = {
    AND?: CdCScalarWhereInput | CdCScalarWhereInput[]
    OR?: CdCScalarWhereInput[]
    NOT?: CdCScalarWhereInput | CdCScalarWhereInput[]
    id?: IntFilter<"CdC"> | number
    file?: StringFilter<"CdC"> | string
    documentId?: StringFilter<"CdC"> | string
  }

  export type ReportUpsertWithWhereUniqueWithoutDocumentInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutDocumentInput, ReportUncheckedUpdateWithoutDocumentInput>
    create: XOR<ReportCreateWithoutDocumentInput, ReportUncheckedCreateWithoutDocumentInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutDocumentInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutDocumentInput, ReportUncheckedUpdateWithoutDocumentInput>
  }

  export type ReportUpdateManyWithWhereWithoutDocumentInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutDocumentInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: IntFilter<"Report"> | number
    file?: StringFilter<"Report"> | string
    documentId?: StringFilter<"Report"> | string
  }

  export type InternshipUpsertWithoutDocumentsInput = {
    update: XOR<InternshipUpdateWithoutDocumentsInput, InternshipUncheckedUpdateWithoutDocumentsInput>
    create: XOR<InternshipCreateWithoutDocumentsInput, InternshipUncheckedCreateWithoutDocumentsInput>
    where?: InternshipWhereInput
  }

  export type InternshipUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: InternshipWhereInput
    data: XOR<InternshipUpdateWithoutDocumentsInput, InternshipUncheckedUpdateWithoutDocumentsInput>
  }

  export type InternshipUpdateWithoutDocumentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    evaluations?: EvaluationUpdateManyWithoutInternshipNestedInput
    company?: CompanyUpdateOneRequiredWithoutInternshipsNestedInput
    student?: StudentUpdateOneWithoutInternshipNestedInput
  }

  export type InternshipUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    evaluations?: EvaluationUncheckedUpdateManyWithoutInternshipNestedInput
    student?: StudentUncheckedUpdateOneWithoutInternshipNestedInput
  }

  export type DocumentCreateWithoutCdCInput = {
    id?: string
    fileName?: string
    filePath?: string
    fileType?: string
    fileSize?: number | null
    documentType?: string
    Report?: ReportCreateNestedManyWithoutDocumentInput
    Internship?: InternshipCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutCdCInput = {
    id?: string
    fileName?: string
    filePath?: string
    fileType?: string
    fileSize?: number | null
    documentType?: string
    internshipId?: number | null
    Report?: ReportUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutCdCInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCdCInput, DocumentUncheckedCreateWithoutCdCInput>
  }

  export type DocumentUpsertWithoutCdCInput = {
    update: XOR<DocumentUpdateWithoutCdCInput, DocumentUncheckedUpdateWithoutCdCInput>
    create: XOR<DocumentCreateWithoutCdCInput, DocumentUncheckedCreateWithoutCdCInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutCdCInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutCdCInput, DocumentUncheckedUpdateWithoutCdCInput>
  }

  export type DocumentUpdateWithoutCdCInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
    Report?: ReportUpdateManyWithoutDocumentNestedInput
    Internship?: InternshipUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCdCInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    Report?: ReportUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateWithoutReportInput = {
    id?: string
    fileName?: string
    filePath?: string
    fileType?: string
    fileSize?: number | null
    documentType?: string
    CdC?: CdCCreateNestedManyWithoutDocumentInput
    Internship?: InternshipCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutReportInput = {
    id?: string
    fileName?: string
    filePath?: string
    fileType?: string
    fileSize?: number | null
    documentType?: string
    internshipId?: number | null
    CdC?: CdCUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutReportInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutReportInput, DocumentUncheckedCreateWithoutReportInput>
  }

  export type DocumentUpsertWithoutReportInput = {
    update: XOR<DocumentUpdateWithoutReportInput, DocumentUncheckedUpdateWithoutReportInput>
    create: XOR<DocumentCreateWithoutReportInput, DocumentUncheckedCreateWithoutReportInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutReportInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutReportInput, DocumentUncheckedUpdateWithoutReportInput>
  }

  export type DocumentUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
    CdC?: CdCUpdateManyWithoutDocumentNestedInput
    Internship?: InternshipUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    CdC?: CdCUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type ReportEvaluationCreateWithoutEvaluationInput = {
    reportEvalId: number
  }

  export type ReportEvaluationUncheckedCreateWithoutEvaluationInput = {
    id?: number
    reportEvalId: number
  }

  export type ReportEvaluationCreateOrConnectWithoutEvaluationInput = {
    where: ReportEvaluationWhereUniqueInput
    create: XOR<ReportEvaluationCreateWithoutEvaluationInput, ReportEvaluationUncheckedCreateWithoutEvaluationInput>
  }

  export type ReportEvaluationCreateManyEvaluationInputEnvelope = {
    data: ReportEvaluationCreateManyEvaluationInput | ReportEvaluationCreateManyEvaluationInput[]
    skipDuplicates?: boolean
  }

  export type StudentEvaluationCreateWithoutEvaluationInput = {

  }

  export type StudentEvaluationUncheckedCreateWithoutEvaluationInput = {
    id?: number
  }

  export type StudentEvaluationCreateOrConnectWithoutEvaluationInput = {
    where: StudentEvaluationWhereUniqueInput
    create: XOR<StudentEvaluationCreateWithoutEvaluationInput, StudentEvaluationUncheckedCreateWithoutEvaluationInput>
  }

  export type StudentEvaluationCreateManyEvaluationInputEnvelope = {
    data: StudentEvaluationCreateManyEvaluationInput | StudentEvaluationCreateManyEvaluationInput[]
    skipDuplicates?: boolean
  }

  export type CompanyEvaluationCreateWithoutEvaluationInput = {

  }

  export type CompanyEvaluationUncheckedCreateWithoutEvaluationInput = {
    id?: number
  }

  export type CompanyEvaluationCreateOrConnectWithoutEvaluationInput = {
    where: CompanyEvaluationWhereUniqueInput
    create: XOR<CompanyEvaluationCreateWithoutEvaluationInput, CompanyEvaluationUncheckedCreateWithoutEvaluationInput>
  }

  export type CompanyEvaluationCreateManyEvaluationInputEnvelope = {
    data: CompanyEvaluationCreateManyEvaluationInput | CompanyEvaluationCreateManyEvaluationInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutEvaluationsInput = {
    promotion: string
    user: UserCreateNestedOneWithoutStudentInput
    internship?: InternshipCreateNestedOneWithoutStudentInput
    academicTutor?: AcademicTutorCreateNestedOneWithoutStudentsInput
    enterpriseTutor?: EnterpriseTutorCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutEvaluationsInput = {
    id?: number
    promotion: string
    userId: number
    internshipId?: number | null
    academicTutorId?: number | null
    enterpriseTutorId?: number | null
  }

  export type StudentCreateOrConnectWithoutEvaluationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEvaluationsInput, StudentUncheckedCreateWithoutEvaluationsInput>
  }

  export type InternshipCreateWithoutEvaluationsInput = {
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    tutorId: number
    company: CompanyCreateNestedOneWithoutInternshipsInput
    documents?: DocumentCreateNestedManyWithoutInternshipInput
    student?: StudentCreateNestedOneWithoutInternshipInput
  }

  export type InternshipUncheckedCreateWithoutEvaluationsInput = {
    id?: number
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    companyId: number
    tutorId: number
    documents?: DocumentUncheckedCreateNestedManyWithoutInternshipInput
    student?: StudentUncheckedCreateNestedOneWithoutInternshipInput
  }

  export type InternshipCreateOrConnectWithoutEvaluationsInput = {
    where: InternshipWhereUniqueInput
    create: XOR<InternshipCreateWithoutEvaluationsInput, InternshipUncheckedCreateWithoutEvaluationsInput>
  }

  export type ReportEvaluationUpsertWithWhereUniqueWithoutEvaluationInput = {
    where: ReportEvaluationWhereUniqueInput
    update: XOR<ReportEvaluationUpdateWithoutEvaluationInput, ReportEvaluationUncheckedUpdateWithoutEvaluationInput>
    create: XOR<ReportEvaluationCreateWithoutEvaluationInput, ReportEvaluationUncheckedCreateWithoutEvaluationInput>
  }

  export type ReportEvaluationUpdateWithWhereUniqueWithoutEvaluationInput = {
    where: ReportEvaluationWhereUniqueInput
    data: XOR<ReportEvaluationUpdateWithoutEvaluationInput, ReportEvaluationUncheckedUpdateWithoutEvaluationInput>
  }

  export type ReportEvaluationUpdateManyWithWhereWithoutEvaluationInput = {
    where: ReportEvaluationScalarWhereInput
    data: XOR<ReportEvaluationUpdateManyMutationInput, ReportEvaluationUncheckedUpdateManyWithoutEvaluationInput>
  }

  export type ReportEvaluationScalarWhereInput = {
    AND?: ReportEvaluationScalarWhereInput | ReportEvaluationScalarWhereInput[]
    OR?: ReportEvaluationScalarWhereInput[]
    NOT?: ReportEvaluationScalarWhereInput | ReportEvaluationScalarWhereInput[]
    id?: IntFilter<"ReportEvaluation"> | number
    reportEvalId?: IntFilter<"ReportEvaluation"> | number
    evaluationId?: IntFilter<"ReportEvaluation"> | number
  }

  export type StudentEvaluationUpsertWithWhereUniqueWithoutEvaluationInput = {
    where: StudentEvaluationWhereUniqueInput
    update: XOR<StudentEvaluationUpdateWithoutEvaluationInput, StudentEvaluationUncheckedUpdateWithoutEvaluationInput>
    create: XOR<StudentEvaluationCreateWithoutEvaluationInput, StudentEvaluationUncheckedCreateWithoutEvaluationInput>
  }

  export type StudentEvaluationUpdateWithWhereUniqueWithoutEvaluationInput = {
    where: StudentEvaluationWhereUniqueInput
    data: XOR<StudentEvaluationUpdateWithoutEvaluationInput, StudentEvaluationUncheckedUpdateWithoutEvaluationInput>
  }

  export type StudentEvaluationUpdateManyWithWhereWithoutEvaluationInput = {
    where: StudentEvaluationScalarWhereInput
    data: XOR<StudentEvaluationUpdateManyMutationInput, StudentEvaluationUncheckedUpdateManyWithoutEvaluationInput>
  }

  export type StudentEvaluationScalarWhereInput = {
    AND?: StudentEvaluationScalarWhereInput | StudentEvaluationScalarWhereInput[]
    OR?: StudentEvaluationScalarWhereInput[]
    NOT?: StudentEvaluationScalarWhereInput | StudentEvaluationScalarWhereInput[]
    id?: IntFilter<"StudentEvaluation"> | number
    evaluationId?: IntFilter<"StudentEvaluation"> | number
  }

  export type CompanyEvaluationUpsertWithWhereUniqueWithoutEvaluationInput = {
    where: CompanyEvaluationWhereUniqueInput
    update: XOR<CompanyEvaluationUpdateWithoutEvaluationInput, CompanyEvaluationUncheckedUpdateWithoutEvaluationInput>
    create: XOR<CompanyEvaluationCreateWithoutEvaluationInput, CompanyEvaluationUncheckedCreateWithoutEvaluationInput>
  }

  export type CompanyEvaluationUpdateWithWhereUniqueWithoutEvaluationInput = {
    where: CompanyEvaluationWhereUniqueInput
    data: XOR<CompanyEvaluationUpdateWithoutEvaluationInput, CompanyEvaluationUncheckedUpdateWithoutEvaluationInput>
  }

  export type CompanyEvaluationUpdateManyWithWhereWithoutEvaluationInput = {
    where: CompanyEvaluationScalarWhereInput
    data: XOR<CompanyEvaluationUpdateManyMutationInput, CompanyEvaluationUncheckedUpdateManyWithoutEvaluationInput>
  }

  export type CompanyEvaluationScalarWhereInput = {
    AND?: CompanyEvaluationScalarWhereInput | CompanyEvaluationScalarWhereInput[]
    OR?: CompanyEvaluationScalarWhereInput[]
    NOT?: CompanyEvaluationScalarWhereInput | CompanyEvaluationScalarWhereInput[]
    id?: IntFilter<"CompanyEvaluation"> | number
    evaluationId?: IntFilter<"CompanyEvaluation"> | number
  }

  export type StudentUpsertWithoutEvaluationsInput = {
    update: XOR<StudentUpdateWithoutEvaluationsInput, StudentUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<StudentCreateWithoutEvaluationsInput, StudentUncheckedCreateWithoutEvaluationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutEvaluationsInput, StudentUncheckedUpdateWithoutEvaluationsInput>
  }

  export type StudentUpdateWithoutEvaluationsInput = {
    promotion?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    internship?: InternshipUpdateOneWithoutStudentNestedInput
    academicTutor?: AcademicTutorUpdateOneWithoutStudentsNestedInput
    enterpriseTutor?: EnterpriseTutorUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotion?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    academicTutorId?: NullableIntFieldUpdateOperationsInput | number | null
    enterpriseTutorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InternshipUpsertWithoutEvaluationsInput = {
    update: XOR<InternshipUpdateWithoutEvaluationsInput, InternshipUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<InternshipCreateWithoutEvaluationsInput, InternshipUncheckedCreateWithoutEvaluationsInput>
    where?: InternshipWhereInput
  }

  export type InternshipUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: InternshipWhereInput
    data: XOR<InternshipUpdateWithoutEvaluationsInput, InternshipUncheckedUpdateWithoutEvaluationsInput>
  }

  export type InternshipUpdateWithoutEvaluationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    company?: CompanyUpdateOneRequiredWithoutInternshipsNestedInput
    documents?: DocumentUpdateManyWithoutInternshipNestedInput
    student?: StudentUpdateOneWithoutInternshipNestedInput
  }

  export type InternshipUncheckedUpdateWithoutEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    documents?: DocumentUncheckedUpdateManyWithoutInternshipNestedInput
    student?: StudentUncheckedUpdateOneWithoutInternshipNestedInput
  }

  export type EvaluationCreateWithoutStudentEvalsInput = {
    evaluation: string
    submissionDate: Date | string
    factor: number
    ReportEvaluation?: ReportEvaluationCreateNestedManyWithoutEvaluationInput
    companyEvals?: CompanyEvaluationCreateNestedManyWithoutEvaluationInput
    Student?: StudentCreateNestedOneWithoutEvaluationsInput
    Internship: InternshipCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutStudentEvalsInput = {
    id?: number
    evaluation: string
    submissionDate: Date | string
    factor: number
    internshipId: number
    studentId?: number | null
    ReportEvaluation?: ReportEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
    companyEvals?: CompanyEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutStudentEvalsInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutStudentEvalsInput, EvaluationUncheckedCreateWithoutStudentEvalsInput>
  }

  export type EvaluationUpsertWithoutStudentEvalsInput = {
    update: XOR<EvaluationUpdateWithoutStudentEvalsInput, EvaluationUncheckedUpdateWithoutStudentEvalsInput>
    create: XOR<EvaluationCreateWithoutStudentEvalsInput, EvaluationUncheckedCreateWithoutStudentEvalsInput>
    where?: EvaluationWhereInput
  }

  export type EvaluationUpdateToOneWithWhereWithoutStudentEvalsInput = {
    where?: EvaluationWhereInput
    data: XOR<EvaluationUpdateWithoutStudentEvalsInput, EvaluationUncheckedUpdateWithoutStudentEvalsInput>
  }

  export type EvaluationUpdateWithoutStudentEvalsInput = {
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    ReportEvaluation?: ReportEvaluationUpdateManyWithoutEvaluationNestedInput
    companyEvals?: CompanyEvaluationUpdateManyWithoutEvaluationNestedInput
    Student?: StudentUpdateOneWithoutEvaluationsNestedInput
    Internship?: InternshipUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutStudentEvalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    internshipId?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    ReportEvaluation?: ReportEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
    companyEvals?: CompanyEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationCreateWithoutCompanyEvalsInput = {
    evaluation: string
    submissionDate: Date | string
    factor: number
    ReportEvaluation?: ReportEvaluationCreateNestedManyWithoutEvaluationInput
    studentEvals?: StudentEvaluationCreateNestedManyWithoutEvaluationInput
    Student?: StudentCreateNestedOneWithoutEvaluationsInput
    Internship: InternshipCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutCompanyEvalsInput = {
    id?: number
    evaluation: string
    submissionDate: Date | string
    factor: number
    internshipId: number
    studentId?: number | null
    ReportEvaluation?: ReportEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
    studentEvals?: StudentEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutCompanyEvalsInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutCompanyEvalsInput, EvaluationUncheckedCreateWithoutCompanyEvalsInput>
  }

  export type EvaluationUpsertWithoutCompanyEvalsInput = {
    update: XOR<EvaluationUpdateWithoutCompanyEvalsInput, EvaluationUncheckedUpdateWithoutCompanyEvalsInput>
    create: XOR<EvaluationCreateWithoutCompanyEvalsInput, EvaluationUncheckedCreateWithoutCompanyEvalsInput>
    where?: EvaluationWhereInput
  }

  export type EvaluationUpdateToOneWithWhereWithoutCompanyEvalsInput = {
    where?: EvaluationWhereInput
    data: XOR<EvaluationUpdateWithoutCompanyEvalsInput, EvaluationUncheckedUpdateWithoutCompanyEvalsInput>
  }

  export type EvaluationUpdateWithoutCompanyEvalsInput = {
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    ReportEvaluation?: ReportEvaluationUpdateManyWithoutEvaluationNestedInput
    studentEvals?: StudentEvaluationUpdateManyWithoutEvaluationNestedInput
    Student?: StudentUpdateOneWithoutEvaluationsNestedInput
    Internship?: InternshipUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutCompanyEvalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    internshipId?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    ReportEvaluation?: ReportEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
    studentEvals?: StudentEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type SoutenanceEvaluationCreateWithoutSoutenanceInput = {

  }

  export type SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput = {
    id?: number
  }

  export type SoutenanceEvaluationCreateOrConnectWithoutSoutenanceInput = {
    where: SoutenanceEvaluationWhereUniqueInput
    create: XOR<SoutenanceEvaluationCreateWithoutSoutenanceInput, SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput>
  }

  export type SoutenanceEvaluationCreateManySoutenanceInputEnvelope = {
    data: SoutenanceEvaluationCreateManySoutenanceInput | SoutenanceEvaluationCreateManySoutenanceInput[]
    skipDuplicates?: boolean
  }

  export type SoutenanceEvaluationUpsertWithWhereUniqueWithoutSoutenanceInput = {
    where: SoutenanceEvaluationWhereUniqueInput
    update: XOR<SoutenanceEvaluationUpdateWithoutSoutenanceInput, SoutenanceEvaluationUncheckedUpdateWithoutSoutenanceInput>
    create: XOR<SoutenanceEvaluationCreateWithoutSoutenanceInput, SoutenanceEvaluationUncheckedCreateWithoutSoutenanceInput>
  }

  export type SoutenanceEvaluationUpdateWithWhereUniqueWithoutSoutenanceInput = {
    where: SoutenanceEvaluationWhereUniqueInput
    data: XOR<SoutenanceEvaluationUpdateWithoutSoutenanceInput, SoutenanceEvaluationUncheckedUpdateWithoutSoutenanceInput>
  }

  export type SoutenanceEvaluationUpdateManyWithWhereWithoutSoutenanceInput = {
    where: SoutenanceEvaluationScalarWhereInput
    data: XOR<SoutenanceEvaluationUpdateManyMutationInput, SoutenanceEvaluationUncheckedUpdateManyWithoutSoutenanceInput>
  }

  export type SoutenanceEvaluationScalarWhereInput = {
    AND?: SoutenanceEvaluationScalarWhereInput | SoutenanceEvaluationScalarWhereInput[]
    OR?: SoutenanceEvaluationScalarWhereInput[]
    NOT?: SoutenanceEvaluationScalarWhereInput | SoutenanceEvaluationScalarWhereInput[]
    id?: IntFilter<"SoutenanceEvaluation"> | number
    soutenanceId?: IntFilter<"SoutenanceEvaluation"> | number
  }

  export type SoutenanceCreateWithoutEvaluationsInput = {
    date: Date | string
    status: string
  }

  export type SoutenanceUncheckedCreateWithoutEvaluationsInput = {
    id?: number
    date: Date | string
    status: string
  }

  export type SoutenanceCreateOrConnectWithoutEvaluationsInput = {
    where: SoutenanceWhereUniqueInput
    create: XOR<SoutenanceCreateWithoutEvaluationsInput, SoutenanceUncheckedCreateWithoutEvaluationsInput>
  }

  export type SoutenanceUpsertWithoutEvaluationsInput = {
    update: XOR<SoutenanceUpdateWithoutEvaluationsInput, SoutenanceUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<SoutenanceCreateWithoutEvaluationsInput, SoutenanceUncheckedCreateWithoutEvaluationsInput>
    where?: SoutenanceWhereInput
  }

  export type SoutenanceUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: SoutenanceWhereInput
    data: XOR<SoutenanceUpdateWithoutEvaluationsInput, SoutenanceUncheckedUpdateWithoutEvaluationsInput>
  }

  export type SoutenanceUpdateWithoutEvaluationsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SoutenanceUncheckedUpdateWithoutEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type EvaluationCreateWithoutReportEvaluationInput = {
    evaluation: string
    submissionDate: Date | string
    factor: number
    studentEvals?: StudentEvaluationCreateNestedManyWithoutEvaluationInput
    companyEvals?: CompanyEvaluationCreateNestedManyWithoutEvaluationInput
    Student?: StudentCreateNestedOneWithoutEvaluationsInput
    Internship: InternshipCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutReportEvaluationInput = {
    id?: number
    evaluation: string
    submissionDate: Date | string
    factor: number
    internshipId: number
    studentId?: number | null
    studentEvals?: StudentEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
    companyEvals?: CompanyEvaluationUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutReportEvaluationInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutReportEvaluationInput, EvaluationUncheckedCreateWithoutReportEvaluationInput>
  }

  export type EvaluationUpsertWithoutReportEvaluationInput = {
    update: XOR<EvaluationUpdateWithoutReportEvaluationInput, EvaluationUncheckedUpdateWithoutReportEvaluationInput>
    create: XOR<EvaluationCreateWithoutReportEvaluationInput, EvaluationUncheckedCreateWithoutReportEvaluationInput>
    where?: EvaluationWhereInput
  }

  export type EvaluationUpdateToOneWithWhereWithoutReportEvaluationInput = {
    where?: EvaluationWhereInput
    data: XOR<EvaluationUpdateWithoutReportEvaluationInput, EvaluationUncheckedUpdateWithoutReportEvaluationInput>
  }

  export type EvaluationUpdateWithoutReportEvaluationInput = {
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    studentEvals?: StudentEvaluationUpdateManyWithoutEvaluationNestedInput
    companyEvals?: CompanyEvaluationUpdateManyWithoutEvaluationNestedInput
    Student?: StudentUpdateOneWithoutEvaluationsNestedInput
    Internship?: InternshipUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutReportEvaluationInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    internshipId?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    studentEvals?: StudentEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
    companyEvals?: CompanyEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationCreateManyStudentInput = {
    id?: number
    evaluation: string
    submissionDate: Date | string
    factor: number
    internshipId: number
  }

  export type EvaluationUpdateWithoutStudentInput = {
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    ReportEvaluation?: ReportEvaluationUpdateManyWithoutEvaluationNestedInput
    studentEvals?: StudentEvaluationUpdateManyWithoutEvaluationNestedInput
    companyEvals?: CompanyEvaluationUpdateManyWithoutEvaluationNestedInput
    Internship?: InternshipUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    internshipId?: IntFieldUpdateOperationsInput | number
    ReportEvaluation?: ReportEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
    studentEvals?: StudentEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
    companyEvals?: CompanyEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    internshipId?: IntFieldUpdateOperationsInput | number
  }

  export type AcademicTutorCreateManyTutorInput = {
    id?: number
  }

  export type EnterpriseTutorCreateManyTutorInput = {
    id?: number
  }

  export type AcademicTutorUpdateWithoutTutorInput = {
    students?: StudentUpdateManyWithoutAcademicTutorNestedInput
  }

  export type AcademicTutorUncheckedUpdateWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    students?: StudentUncheckedUpdateManyWithoutAcademicTutorNestedInput
  }

  export type AcademicTutorUncheckedUpdateManyWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type EnterpriseTutorUpdateWithoutTutorInput = {
    students?: StudentUpdateManyWithoutEnterpriseTutorNestedInput
  }

  export type EnterpriseTutorUncheckedUpdateWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    students?: StudentUncheckedUpdateManyWithoutEnterpriseTutorNestedInput
  }

  export type EnterpriseTutorUncheckedUpdateManyWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type StudentCreateManyAcademicTutorInput = {
    id?: number
    promotion: string
    userId: number
    internshipId?: number | null
    enterpriseTutorId?: number | null
  }

  export type StudentUpdateWithoutAcademicTutorInput = {
    promotion?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    internship?: InternshipUpdateOneWithoutStudentNestedInput
    evaluations?: EvaluationUpdateManyWithoutStudentNestedInput
    enterpriseTutor?: EnterpriseTutorUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotion?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    enterpriseTutorId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutAcademicTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotion?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    enterpriseTutorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentCreateManyEnterpriseTutorInput = {
    id?: number
    promotion: string
    userId: number
    internshipId?: number | null
    academicTutorId?: number | null
  }

  export type StudentUpdateWithoutEnterpriseTutorInput = {
    promotion?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    internship?: InternshipUpdateOneWithoutStudentNestedInput
    evaluations?: EvaluationUpdateManyWithoutStudentNestedInput
    academicTutor?: AcademicTutorUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutEnterpriseTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotion?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    academicTutorId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutEnterpriseTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotion?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    internshipId?: NullableIntFieldUpdateOperationsInput | number | null
    academicTutorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InternshipCreateManyCompanyInput = {
    id?: number
    title: string
    description: string
    startDate: Date | string
    endDate: Date | string
    salary: number
    tutorId: number
  }

  export type InternshipUpdateWithoutCompanyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    evaluations?: EvaluationUpdateManyWithoutInternshipNestedInput
    documents?: DocumentUpdateManyWithoutInternshipNestedInput
    student?: StudentUpdateOneWithoutInternshipNestedInput
  }

  export type InternshipUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
    evaluations?: EvaluationUncheckedUpdateManyWithoutInternshipNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutInternshipNestedInput
    student?: StudentUncheckedUpdateOneWithoutInternshipNestedInput
  }

  export type InternshipUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    tutorId?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluationCreateManyInternshipInput = {
    id?: number
    evaluation: string
    submissionDate: Date | string
    factor: number
    studentId?: number | null
  }

  export type DocumentCreateManyInternshipInput = {
    id?: string
    fileName?: string
    filePath?: string
    fileType?: string
    fileSize?: number | null
    documentType?: string
  }

  export type EvaluationUpdateWithoutInternshipInput = {
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    ReportEvaluation?: ReportEvaluationUpdateManyWithoutEvaluationNestedInput
    studentEvals?: StudentEvaluationUpdateManyWithoutEvaluationNestedInput
    companyEvals?: CompanyEvaluationUpdateManyWithoutEvaluationNestedInput
    Student?: StudentUpdateOneWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutInternshipInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    ReportEvaluation?: ReportEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
    studentEvals?: StudentEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
    companyEvals?: CompanyEvaluationUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutInternshipInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    factor?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DocumentUpdateWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
    CdC?: CdCUpdateManyWithoutDocumentNestedInput
    Report?: ReportUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
    CdC?: CdCUncheckedUpdateManyWithoutDocumentNestedInput
    Report?: ReportUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    documentType?: StringFieldUpdateOperationsInput | string
  }

  export type CdCCreateManyDocumentInput = {
    id?: number
    file: string
  }

  export type ReportCreateManyDocumentInput = {
    id?: number
    file: string
  }

  export type CdCUpdateWithoutDocumentInput = {
    file?: StringFieldUpdateOperationsInput | string
  }

  export type CdCUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
  }

  export type CdCUncheckedUpdateManyWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUpdateWithoutDocumentInput = {
    file?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUncheckedUpdateManyWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
  }

  export type ReportEvaluationCreateManyEvaluationInput = {
    id?: number
    reportEvalId: number
  }

  export type StudentEvaluationCreateManyEvaluationInput = {
    id?: number
  }

  export type CompanyEvaluationCreateManyEvaluationInput = {
    id?: number
  }

  export type ReportEvaluationUpdateWithoutEvaluationInput = {
    reportEvalId?: IntFieldUpdateOperationsInput | number
  }

  export type ReportEvaluationUncheckedUpdateWithoutEvaluationInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportEvalId?: IntFieldUpdateOperationsInput | number
  }

  export type ReportEvaluationUncheckedUpdateManyWithoutEvaluationInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportEvalId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentEvaluationUpdateWithoutEvaluationInput = {

  }

  export type StudentEvaluationUncheckedUpdateWithoutEvaluationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type StudentEvaluationUncheckedUpdateManyWithoutEvaluationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyEvaluationUpdateWithoutEvaluationInput = {

  }

  export type CompanyEvaluationUncheckedUpdateWithoutEvaluationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyEvaluationUncheckedUpdateManyWithoutEvaluationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type SoutenanceEvaluationCreateManySoutenanceInput = {
    id?: number
  }

  export type SoutenanceEvaluationUpdateWithoutSoutenanceInput = {

  }

  export type SoutenanceEvaluationUncheckedUpdateWithoutSoutenanceInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type SoutenanceEvaluationUncheckedUpdateManyWithoutSoutenanceInput = {
    id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutorCountOutputTypeDefaultArgs instead
     */
    export type TutorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicTutorCountOutputTypeDefaultArgs instead
     */
    export type AcademicTutorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicTutorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnterpriseTutorCountOutputTypeDefaultArgs instead
     */
    export type EnterpriseTutorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnterpriseTutorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternshipCountOutputTypeDefaultArgs instead
     */
    export type InternshipCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternshipCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentCountOutputTypeDefaultArgs instead
     */
    export type DocumentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationCountOutputTypeDefaultArgs instead
     */
    export type EvaluationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoutenanceCountOutputTypeDefaultArgs instead
     */
    export type SoutenanceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoutenanceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutorDefaultArgs instead
     */
    export type TutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicTutorDefaultArgs instead
     */
    export type AcademicTutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicTutorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnterpriseTutorDefaultArgs instead
     */
    export type EnterpriseTutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnterpriseTutorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternshipDefaultArgs instead
     */
    export type InternshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CdCDefaultArgs instead
     */
    export type CdCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CdCDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationDefaultArgs instead
     */
    export type EvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentEvaluationDefaultArgs instead
     */
    export type StudentEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentEvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyEvaluationDefaultArgs instead
     */
    export type CompanyEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyEvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoutenanceDefaultArgs instead
     */
    export type SoutenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoutenanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoutenanceEvaluationDefaultArgs instead
     */
    export type SoutenanceEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoutenanceEvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportEvaluationDefaultArgs instead
     */
    export type ReportEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportEvaluationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}